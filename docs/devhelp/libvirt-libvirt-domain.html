<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>libvirt-domain: APIs for management of domains</title>
    <meta name="generator" content="Libvirt devhelp stylesheet"/>
    <link rel="start" href="index.html" title="libvirt Reference Manual"/>
    <link rel="up" href="general.html" title="API"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <link rel="chapter" href="general.html" title="API"/>
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
    <table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
      <tr valign="middle">
        <td>
          <a accesskey="p" href="libvirt-libvirt-domain-snapshot.html">
            <img src="left.png" width="24" height="24" border="0" alt="Prev"/>
          </a>
        </td>
        <td>
          <a accesskey="u" href="general.html">
            <img src="up.png" width="24" height="24" border="0" alt="Up"/>
          </a>
        </td>
        <td>
          <a accesskey="h" href="index.html">
            <img src="home.png" width="24" height="24" border="0" alt="Home"/>
          </a>
        </td>
        <td>
          <a accesskey="n" href="libvirt-libvirt-event.html">
            <img src="right.png" width="24" height="24" border="0" alt="Next"/>
          </a>
        </td>
        <th width="100%" align="center">libvirt Reference Manual</th>
      </tr>
    </table>
    <h2>
      <span class="refentrytitle">libvirt-domain</span>
    </h2>
    <p>libvirt-domain - APIs for management of domains</p>
    <p>Provides APIs for the management of domains  Copyright (C) 2006-2015 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </p>
    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>
      <pre class="synopsis">#define <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>(cpumaps, maplen, vcpu, cpumap);
#define <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>(cpu);
#define <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>(cpumaps, maplen, vcpu, cpu);
#define <a href="#VIR_CPU_USED">VIR_CPU_USED</a>(cpumap, cpu);
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_BURST">VIR_DOMAIN_BANDWIDTH_IN_BURST</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_FLOOR">VIR_DOMAIN_BANDWIDTH_IN_FLOOR</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_PEAK">VIR_DOMAIN_BANDWIDTH_IN_PEAK</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_BURST">VIR_DOMAIN_BANDWIDTH_OUT_BURST</a>;
#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_PEAK">VIR_DOMAIN_BANDWIDTH_OUT_PEAK</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_READ_BPS">VIR_DOMAIN_BLKIO_DEVICE_READ_BPS</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS">VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS">VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS</a>;
#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS">VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS</a>;
#define <a href="#VIR_DOMAIN_BLKIO_FIELD_LENGTH">VIR_DOMAIN_BLKIO_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLKIO_WEIGHT">VIR_DOMAIN_BLKIO_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_BLOCK_COPY_BANDWIDTH">VIR_DOMAIN_BLOCK_COPY_BANDWIDTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_COPY_BUF_SIZE">VIR_DOMAIN_BLOCK_COPY_BUF_SIZE</a>;
#define <a href="#VIR_DOMAIN_BLOCK_COPY_GRANULARITY">VIR_DOMAIN_BLOCK_COPY_GRANULARITY</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME">VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_ERRS">VIR_DOMAIN_BLOCK_STATS_ERRS</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_BYTES">VIR_DOMAIN_BLOCK_STATS_READ_BYTES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_REQ">VIR_DOMAIN_BLOCK_STATS_READ_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</a>;
#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_CPUTIME">VIR_DOMAIN_CPU_STATS_CPUTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_SYSTEMTIME">VIR_DOMAIN_CPU_STATS_SYSTEMTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_USERTIME">VIR_DOMAIN_CPU_STATS_USERTIME</a>;
#define <a href="#VIR_DOMAIN_CPU_STATS_VCPUTIME">VIR_DOMAIN_CPU_STATS_VCPUTIME</a>;
#define <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>;
#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_GROW">VIR_DOMAIN_IOTHREAD_POLL_GROW</a>;
#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_MAX_NS">VIR_DOMAIN_IOTHREAD_POLL_MAX_NS</a>;
#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_SHRINK">VIR_DOMAIN_IOTHREAD_POLL_SHRINK</a>;
#define <a href="#VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE">VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_BYTES">VIR_DOMAIN_JOB_COMPRESSION_BYTES</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE">VIR_DOMAIN_JOB_COMPRESSION_CACHE</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</a>;
#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_BPS">VIR_DOMAIN_JOB_DISK_BPS</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_PROCESSED">VIR_DOMAIN_JOB_DISK_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_REMAINING">VIR_DOMAIN_JOB_DISK_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_DISK_TOTAL">VIR_DOMAIN_JOB_DISK_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_DOWNTIME">VIR_DOMAIN_JOB_DOWNTIME</a>;
#define <a href="#VIR_DOMAIN_JOB_DOWNTIME_NET">VIR_DOMAIN_JOB_DOWNTIME_NET</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_BPS">VIR_DOMAIN_JOB_MEMORY_BPS</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_CONSTANT">VIR_DOMAIN_JOB_MEMORY_CONSTANT</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE">VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_ITERATION">VIR_DOMAIN_JOB_MEMORY_ITERATION</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE">VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS">VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_PROCESSED">VIR_DOMAIN_JOB_MEMORY_PROCESSED</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_REMAINING">VIR_DOMAIN_JOB_MEMORY_REMAINING</a>;
#define <a href="#VIR_DOMAIN_JOB_MEMORY_TOTAL">VIR_DOMAIN_JOB_MEMORY_TOTAL</a>;
#define <a href="#VIR_DOMAIN_JOB_OPERATION">VIR_DOMAIN_JOB_OPERATION</a>;
#define <a href="#VIR_DOMAIN_JOB_SETUP_TIME">VIR_DOMAIN_JOB_SETUP_TIME</a>;
#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED">VIR_DOMAIN_JOB_TIME_ELAPSED</a>;
#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED_NET">VIR_DOMAIN_JOB_TIME_ELAPSED_NET</a>;
#define <a href="#VIR_DOMAIN_JOB_TIME_REMAINING">VIR_DOMAIN_JOB_TIME_REMAINING</a>;
#define <a href="#VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT">VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT</a>;
#define <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>;
#define <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>;
#define <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>;
#define <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>;
#define <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>;
#define <a href="#VIR_DOMAIN_NUMA_MODE">VIR_DOMAIN_NUMA_MODE</a>;
#define <a href="#VIR_DOMAIN_NUMA_NODESET">VIR_DOMAIN_NUMA_NODESET</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_CAP">VIR_DOMAIN_SCHEDULER_CAP</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_CPU_SHARES">VIR_DOMAIN_SCHEDULER_CPU_SHARES</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD">VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA">VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD">VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA">VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_LIMIT">VIR_DOMAIN_SCHEDULER_LIMIT</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_RESERVATION">VIR_DOMAIN_SCHEDULER_RESERVATION</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_SHARES">VIR_DOMAIN_SCHEDULER_SHARES</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</a>;
#define <a href="#VIR_DOMAIN_SCHEDULER_WEIGHT">VIR_DOMAIN_SCHEDULER_WEIGHT</a>;
#define <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>;
#define <a href="#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_DISK">VIR_DOMAIN_TUNABLE_BLKDEV_DISK</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME">VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES">VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN">VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD">VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA">VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD">VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA">VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN">VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD">VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA">VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPUPIN">VIR_DOMAIN_TUNABLE_CPU_VCPUPIN</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD">VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD</a>;
#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA">VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA</a>;
#define <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>(cpumaps, maplen, vcpu);
#define <a href="#VIR_KEYCODE_SET_RFB">VIR_KEYCODE_SET_RFB</a>;
#define <a href="#VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT">VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT</a>;
#define <a href="#VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL">VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL</a>;
#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH">VIR_MIGRATE_PARAM_BANDWIDTH</a>;
#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY">VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY</a>;
#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION">VIR_MIGRATE_PARAM_COMPRESSION</a>;
#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS">VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS</a>;
#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL">VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL</a>;
#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS">VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS</a>;
#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE">VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE</a>;
#define <a href="#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a>;
#define <a href="#VIR_MIGRATE_PARAM_DEST_XML">VIR_MIGRATE_PARAM_DEST_XML</a>;
#define <a href="#VIR_MIGRATE_PARAM_DISKS_PORT">VIR_MIGRATE_PARAM_DISKS_PORT</a>;
#define <a href="#VIR_MIGRATE_PARAM_GRAPHICS_URI">VIR_MIGRATE_PARAM_GRAPHICS_URI</a>;
#define <a href="#VIR_MIGRATE_PARAM_LISTEN_ADDRESS">VIR_MIGRATE_PARAM_LISTEN_ADDRESS</a>;
#define <a href="#VIR_MIGRATE_PARAM_MIGRATE_DISKS">VIR_MIGRATE_PARAM_MIGRATE_DISKS</a>;
#define <a href="#VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS">VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS</a>;
#define <a href="#VIR_MIGRATE_PARAM_PERSIST_XML">VIR_MIGRATE_PARAM_PERSIST_XML</a>;
#define <a href="#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a>;
#define <a href="#VIR_PERF_PARAM_ALIGNMENT_FAULTS">VIR_PERF_PARAM_ALIGNMENT_FAULTS</a>;
#define <a href="#VIR_PERF_PARAM_BRANCH_INSTRUCTIONS">VIR_PERF_PARAM_BRANCH_INSTRUCTIONS</a>;
#define <a href="#VIR_PERF_PARAM_BRANCH_MISSES">VIR_PERF_PARAM_BRANCH_MISSES</a>;
#define <a href="#VIR_PERF_PARAM_BUS_CYCLES">VIR_PERF_PARAM_BUS_CYCLES</a>;
#define <a href="#VIR_PERF_PARAM_CACHE_MISSES">VIR_PERF_PARAM_CACHE_MISSES</a>;
#define <a href="#VIR_PERF_PARAM_CACHE_REFERENCES">VIR_PERF_PARAM_CACHE_REFERENCES</a>;
#define <a href="#VIR_PERF_PARAM_CMT">VIR_PERF_PARAM_CMT</a>;
#define <a href="#VIR_PERF_PARAM_CONTEXT_SWITCHES">VIR_PERF_PARAM_CONTEXT_SWITCHES</a>;
#define <a href="#VIR_PERF_PARAM_CPU_CLOCK">VIR_PERF_PARAM_CPU_CLOCK</a>;
#define <a href="#VIR_PERF_PARAM_CPU_CYCLES">VIR_PERF_PARAM_CPU_CYCLES</a>;
#define <a href="#VIR_PERF_PARAM_CPU_MIGRATIONS">VIR_PERF_PARAM_CPU_MIGRATIONS</a>;
#define <a href="#VIR_PERF_PARAM_EMULATION_FAULTS">VIR_PERF_PARAM_EMULATION_FAULTS</a>;
#define <a href="#VIR_PERF_PARAM_INSTRUCTIONS">VIR_PERF_PARAM_INSTRUCTIONS</a>;
#define <a href="#VIR_PERF_PARAM_MBML">VIR_PERF_PARAM_MBML</a>;
#define <a href="#VIR_PERF_PARAM_MBMT">VIR_PERF_PARAM_MBMT</a>;
#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS">VIR_PERF_PARAM_PAGE_FAULTS</a>;
#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS_MAJ">VIR_PERF_PARAM_PAGE_FAULTS_MAJ</a>;
#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS_MIN">VIR_PERF_PARAM_PAGE_FAULTS_MIN</a>;
#define <a href="#VIR_PERF_PARAM_REF_CPU_CYCLES">VIR_PERF_PARAM_REF_CPU_CYCLES</a>;
#define <a href="#VIR_PERF_PARAM_STALLED_CYCLES_BACKEND">VIR_PERF_PARAM_STALLED_CYCLES_BACKEND</a>;
#define <a href="#VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND">VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND</a>;
#define <a href="#VIR_PERF_PARAM_TASK_CLOCK">VIR_PERF_PARAM_TASK_CLOCK</a>;
#define <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>(cpumap, cpu);
#define <a href="#VIR_USE_CPU">VIR_USE_CPU</a>(cpumap, cpu);
#define <a href="#_virBlkioParameter">_virBlkioParameter</a>;
#define <a href="#_virMemoryParameter">_virMemoryParameter</a>;
#define <a href="#_virSchedParameter">_virSchedParameter</a>;
typedef struct _virTypedParameter <a href="#virBlkioParameter">virBlkioParameter</a>;
typedef <a href="libvirt-libvirt-domain.html#virBlkioParameter">virBlkioParameter</a> * <a href="#virBlkioParameterPtr">virBlkioParameterPtr</a>;
typedef enum <a href="#virBlkioParameterType">virBlkioParameterType</a>;
typedef enum <a href="#virConnectDomainEventAgentLifecycleReason">virConnectDomainEventAgentLifecycleReason</a>;
typedef enum <a href="#virConnectDomainEventAgentLifecycleState">virConnectDomainEventAgentLifecycleState</a>;
typedef enum <a href="#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a>;
typedef enum <a href="#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a>;
typedef enum <a href="#virConnectGetAllDomainStatsFlags">virConnectGetAllDomainStatsFlags</a>;
typedef enum <a href="#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a>;
typedef struct _virDomain <a href="#virDomain">virDomain</a>;
typedef enum <a href="#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a>;
typedef enum <a href="#virDomainBlockCopyFlags">virDomainBlockCopyFlags</a>;
typedef struct _virDomainBlockInfo <a href="#virDomainBlockInfo">virDomainBlockInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainBlockInfo">virDomainBlockInfo</a> * <a href="#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a>;
typedef enum <a href="#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a>;
typedef unsigned long long <a href="#virDomainBlockJobCursor">virDomainBlockJobCursor</a>;
typedef struct _virDomainBlockJobInfo <a href="#virDomainBlockJobInfo">virDomainBlockJobInfo</a>;
typedef enum <a href="#virDomainBlockJobInfoFlags">virDomainBlockJobInfoFlags</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> * <a href="#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a>;
typedef enum <a href="#virDomainBlockJobSetSpeedFlags">virDomainBlockJobSetSpeedFlags</a>;
typedef enum <a href="#virDomainBlockJobType">virDomainBlockJobType</a>;
typedef enum <a href="#virDomainBlockPullFlags">virDomainBlockPullFlags</a>;
typedef enum <a href="#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a>;
typedef enum <a href="#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> * <a href="#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a>;
typedef struct _virDomainBlockStats <a href="#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a>;
typedef enum <a href="#virDomainBlockedReason">virDomainBlockedReason</a>;
typedef enum <a href="#virDomainChannelFlags">virDomainChannelFlags</a>;
typedef enum <a href="#virDomainConsoleFlags">virDomainConsoleFlags</a>;
typedef enum <a href="#virDomainControlErrorReason">virDomainControlErrorReason</a>;
typedef struct _virDomainControlInfo <a href="#virDomainControlInfo">virDomainControlInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainControlInfo">virDomainControlInfo</a> * <a href="#virDomainControlInfoPtr">virDomainControlInfoPtr</a>;
typedef enum <a href="#virDomainControlState">virDomainControlState</a>;
typedef enum <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a>;
typedef enum <a href="#virDomainCoreDumpFormat">virDomainCoreDumpFormat</a>;
typedef enum <a href="#virDomainCrashedReason">virDomainCrashedReason</a>;
typedef enum <a href="#virDomainCreateFlags">virDomainCreateFlags</a>;
typedef enum <a href="#virDomainDefineFlags">virDomainDefineFlags</a>;
typedef enum <a href="#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a>;
typedef enum <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a>;
typedef struct _virDomainDiskError <a href="#virDomainDiskError">virDomainDiskError</a>;
typedef enum <a href="#virDomainDiskErrorCode">virDomainDiskErrorCode</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainDiskError">virDomainDiskError</a> * <a href="#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a>;
typedef enum <a href="#virDomainEventCrashedDetailType">virDomainEventCrashedDetailType</a>;
typedef enum <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a>;
typedef struct _virDomainEventGraphicsAddress <a href="#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * <a href="#virDomainEventGraphicsAddressPtr">virDomainEventGraphicsAddressPtr</a>;
typedef enum <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>;
typedef enum <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a>;
typedef struct _virDomainEventGraphicsSubject <a href="#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a>;
typedef struct _virDomainEventGraphicsSubjectIdentity <a href="#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> * <a href="#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * <a href="#virDomainEventGraphicsSubjectPtr">virDomainEventGraphicsSubjectPtr</a>;
typedef enum <a href="#virDomainEventID">virDomainEventID</a>;
typedef enum <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a>;
typedef enum <a href="#virDomainEventPMSuspendedDetailType">virDomainEventPMSuspendedDetailType</a>;
typedef enum <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a>;
typedef enum <a href="#virDomainEventShutdownDetailType">virDomainEventShutdownDetailType</a>;
typedef enum <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a>;
typedef enum <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a>;
typedef enum <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a>;
typedef enum <a href="#virDomainEventTrayChangeReason">virDomainEventTrayChangeReason</a>;
typedef enum <a href="#virDomainEventType">virDomainEventType</a>;
typedef enum <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a>;
typedef enum <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a>;
typedef struct _virDomainFSInfo <a href="#virDomainFSInfo">virDomainFSInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainFSInfo">virDomainFSInfo</a> * <a href="#virDomainFSInfoPtr">virDomainFSInfoPtr</a>;
typedef enum <a href="#virDomainGetJobStatsFlags">virDomainGetJobStatsFlags</a>;
typedef struct _virDomainIOThreadInfo <a href="#virDomainIOThreadInfo">virDomainIOThreadInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainIOThreadInfo">virDomainIOThreadInfo</a> * <a href="#virDomainIOThreadInfoPtr">virDomainIOThreadInfoPtr</a>;
typedef struct _virDomainInterfaceIPAddress <a href="#virDomainIPAddress">virDomainIPAddress</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainIPAddress">virDomainIPAddress</a> * <a href="#virDomainIPAddressPtr">virDomainIPAddressPtr</a>;
typedef struct _virDomainInfo <a href="#virDomainInfo">virDomainInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainInfo">virDomainInfo</a> * <a href="#virDomainInfoPtr">virDomainInfoPtr</a>;
typedef struct _virDomainInterface <a href="#virDomainInterface">virDomainInterface</a>;
typedef enum <a href="#virDomainInterfaceAddressesSource">virDomainInterfaceAddressesSource</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainInterface">virDomainInterface</a> * <a href="#virDomainInterfacePtr">virDomainInterfacePtr</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> * <a href="#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a>;
typedef struct _virDomainInterfaceStats <a href="#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a>;
typedef struct _virDomainJobInfo <a href="#virDomainJobInfo">virDomainJobInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainJobInfo">virDomainJobInfo</a> * <a href="#virDomainJobInfoPtr">virDomainJobInfoPtr</a>;
typedef enum <a href="#virDomainJobOperation">virDomainJobOperation</a>;
typedef enum <a href="#virDomainJobType">virDomainJobType</a>;
typedef enum <a href="#virDomainLifecycle">virDomainLifecycle</a>;
typedef enum <a href="#virDomainLifecycleAction">virDomainLifecycleAction</a>;
typedef enum <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a>;
typedef enum <a href="#virDomainMemoryModFlags">virDomainMemoryModFlags</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> * <a href="#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a>;
typedef struct _virDomainMemoryStat <a href="#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a>;
typedef enum <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a>;
typedef enum <a href="#virDomainMetadataType">virDomainMetadataType</a>;
typedef enum <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a>;
typedef enum <a href="#virDomainMigrateMaxSpeedFlags">virDomainMigrateMaxSpeedFlags</a>;
typedef enum <a href="#virDomainModificationImpact">virDomainModificationImpact</a>;
typedef enum <a href="#virDomainNostateReason">virDomainNostateReason</a>;
typedef enum <a href="#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a>;
typedef enum <a href="#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a>;
typedef enum <a href="#virDomainPMSuspendedDiskReason">virDomainPMSuspendedDiskReason</a>;
typedef enum <a href="#virDomainPMSuspendedReason">virDomainPMSuspendedReason</a>;
typedef enum <a href="#virDomainPausedReason">virDomainPausedReason</a>;
typedef enum <a href="#virDomainProcessSignal">virDomainProcessSignal</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomain">virDomain</a> * <a href="#virDomainPtr">virDomainPtr</a>;
typedef enum <a href="#virDomainRebootFlagValues">virDomainRebootFlagValues</a>;
typedef enum <a href="#virDomainRunningReason">virDomainRunningReason</a>;
typedef enum <a href="#virDomainSaveImageXMLFlags">virDomainSaveImageXMLFlags</a>;
typedef enum <a href="#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a>;
typedef enum <a href="#virDomainSetTimeFlags">virDomainSetTimeFlags</a>;
typedef enum <a href="#virDomainSetUserPasswordFlags">virDomainSetUserPasswordFlags</a>;
typedef enum <a href="#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a>;
typedef enum <a href="#virDomainShutdownReason">virDomainShutdownReason</a>;
typedef enum <a href="#virDomainShutoffReason">virDomainShutoffReason</a>;
typedef enum <a href="#virDomainState">virDomainState</a>;
typedef struct _virDomainStatsRecord <a href="#virDomainStatsRecord">virDomainStatsRecord</a>;
typedef <a href="libvirt-libvirt-domain.html#virDomainStatsRecord">virDomainStatsRecord</a> * <a href="#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a>;
typedef enum <a href="#virDomainStatsTypes">virDomainStatsTypes</a>;
typedef enum <a href="#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a>;
typedef enum <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a>;
typedef enum <a href="#virDomainXMLFlags">virDomainXMLFlags</a>;
typedef enum <a href="#virKeycodeSet">virKeycodeSet</a>;
typedef struct _virTypedParameter <a href="#virMemoryParameter">virMemoryParameter</a>;
typedef <a href="libvirt-libvirt-domain.html#virMemoryParameter">virMemoryParameter</a> * <a href="#virMemoryParameterPtr">virMemoryParameterPtr</a>;
typedef enum <a href="#virMemoryParameterType">virMemoryParameterType</a>;
typedef struct _virTypedParameter <a href="#virSchedParameter">virSchedParameter</a>;
typedef <a href="libvirt-libvirt-domain.html#virSchedParameter">virSchedParameter</a> * <a href="#virSchedParameterPtr">virSchedParameterPtr</a>;
typedef enum <a href="#virSchedParameterType">virSchedParameterType</a>;
typedef struct _virVcpuInfo <a href="#virVcpuInfo">virVcpuInfo</a>;
typedef <a href="libvirt-libvirt-domain.html#virVcpuInfo">virVcpuInfo</a> * <a href="#virVcpuInfoPtr">virVcpuInfoPtr</a>;
typedef enum <a href="#virVcpuState">virVcpuState</a>;
typedef void <a href="#virConnectDomainEventAgentLifecycleCallback">virConnectDomainEventAgentLifecycleCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int state, <br/>							 int reason, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventBalloonChangeCallback">virConnectDomainEventBalloonChangeCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 unsigned long long actual, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventBlockJobCallback">virConnectDomainEventBlockJobCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * disk, <br/>						 int type, <br/>						 int status, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventBlockThresholdCallback">virConnectDomainEventBlockThresholdCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * dev, <br/>							 const char * path, <br/>							 unsigned long long threshold, <br/>							 unsigned long long excess, <br/>							 void * opaque);
typedef int <a href="#virConnectDomainEventCallback">virConnectDomainEventCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 int event, <br/>					 int detail, <br/>					 void * opaque);
int	<a href="#virConnectDomainEventDeregister">virConnectDomainEventDeregister</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb);
int	<a href="#virConnectDomainEventDeregisterAny">virConnectDomainEventDeregisterAny</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID);
typedef void <a href="#virConnectDomainEventDeviceAddedCallback">virConnectDomainEventDeviceAddedCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventDeviceRemovalFailedCallback">virConnectDomainEventDeviceRemovalFailedCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventDeviceRemovedCallback">virConnectDomainEventDeviceRemovedCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventDiskChangeCallback">virConnectDomainEventDiskChangeCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * oldSrcPath, <br/>						 const char * newSrcPath, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventGraphicsCallback">virConnectDomainEventGraphicsCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int phase, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * local, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * remote, <br/>						 const char * authScheme, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * subject, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventIOErrorCallback">virConnectDomainEventIOErrorCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * srcPath, <br/>						 const char * devAlias, <br/>						 int action, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventIOErrorReasonCallback">virConnectDomainEventIOErrorReasonCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * srcPath, <br/>							 const char * devAlias, <br/>							 int action, <br/>							 const char * reason, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventJobCompletedCallback">virConnectDomainEventJobCompletedCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>							 int nparams, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventMetadataChangeCallback">virConnectDomainEventMetadataChangeCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int type, <br/>							 const char * nsuri, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventMigrationIterationCallback">virConnectDomainEventMigrationIterationCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int iteration, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventPMSuspendCallback">virConnectDomainEventPMSuspendCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventPMSuspendDiskCallback">virConnectDomainEventPMSuspendDiskCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int reason, <br/>							 void * opaque);
typedef void <a href="#virConnectDomainEventPMWakeupCallback">virConnectDomainEventPMWakeupCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventRTCChangeCallback">virConnectDomainEventRTCChangeCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 long long utcoffset, <br/>						 void * opaque);
int	<a href="#virConnectDomainEventRegister">virConnectDomainEventRegister</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb);
int	<a href="#virConnectDomainEventRegisterAny">virConnectDomainEventRegisterAny</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt-domain.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb);
typedef void <a href="#virConnectDomainEventTrayChangeCallback">virConnectDomainEventTrayChangeCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventTunableCallback">virConnectDomainEventTunableCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 void * opaque);
typedef void <a href="#virConnectDomainEventWatchdogCallback">virConnectDomainEventWatchdogCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int action, <br/>						 void * opaque);
char *	<a href="#virConnectDomainXMLFromNative">virConnectDomainXMLFromNative</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * nativeConfig, <br/>					 unsigned int flags);
char *	<a href="#virConnectDomainXMLToNative">virConnectDomainXMLToNative</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * domainXml, <br/>					 unsigned int flags);
int	<a href="#virConnectGetAllDomainStats">virConnectGetAllDomainStats</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int stats, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> ** retStats, <br/>					 unsigned int flags);
char *	<a href="#virConnectGetDomainCapabilities">virConnectGetDomainCapabilities</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * emulatorbin, <br/>					 const char * arch, <br/>					 const char * machine, <br/>					 const char * virttype, <br/>					 unsigned int flags);
int	<a href="#virConnectListAllDomains">virConnectListAllDomains</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> ** domains, <br/>					 unsigned int flags);
int	<a href="#virConnectListDefinedDomains">virConnectListDefinedDomains</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames);
int	<a href="#virConnectListDomains">virConnectListDomains</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int * ids, <br/>					 int maxids);
int	<a href="#virConnectNumOfDefinedDomains">virConnectNumOfDefinedDomains</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virConnectNumOfDomains">virConnectNumOfDomains</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn);
int	<a href="#virDomainAbortJob">virDomainAbortJob</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainAddIOThread">virDomainAddIOThread</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned int flags);
int	<a href="#virDomainAttachDevice">virDomainAttachDevice</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml);
int	<a href="#virDomainAttachDeviceFlags">virDomainAttachDeviceFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockCommit">virDomainBlockCommit</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 const char * top, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockCopy">virDomainBlockCopy</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * destxml, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockJobAbort">virDomainBlockJobAbort</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockJobSetSpeed">virDomainBlockJobSetSpeed</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockPeek">virDomainBlockPeek</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long offset, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockPull">virDomainBlockPull</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockRebase">virDomainBlockRebase</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockResize">virDomainBlockResize</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long size, <br/>					 unsigned int flags);
int	<a href="#virDomainBlockStats">virDomainBlockStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br/>					 size_t size);
int	<a href="#virDomainBlockStatsFlags">virDomainBlockStatsFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainCoreDump">virDomainCoreDump</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int flags);
int	<a href="#virDomainCoreDumpWithFormat">virDomainCoreDumpWithFormat</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int dumpformat, <br/>					 unsigned int flags);
int	<a href="#virDomainCreate">virDomainCreate</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateLinux">virDomainCreateLinux</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags);
int	<a href="#virDomainCreateWithFiles">virDomainCreateWithFiles</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nfiles, <br/>					 int * files, <br/>					 unsigned int flags);
int	<a href="#virDomainCreateWithFlags">virDomainCreateWithFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateXML">virDomainCreateXML</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainCreateXMLWithFiles">virDomainCreateXMLWithFiles</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int nfiles, <br/>						 int * files, <br/>						 unsigned int flags);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainDefineXML">virDomainDefineXML</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainDefineXMLFlags">virDomainDefineXMLFlags</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virDomainDelIOThread">virDomainDelIOThread</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned int flags);
int	<a href="#virDomainDestroy">virDomainDestroy</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainDestroyFlags">virDomainDestroyFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainDetachDevice">virDomainDetachDevice</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml);
int	<a href="#virDomainDetachDeviceAlias">virDomainDetachDeviceAlias</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * alias, <br/>					 unsigned int flags);
int	<a href="#virDomainDetachDeviceFlags">virDomainDetachDeviceFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
int	<a href="#virDomainFSFreeze">virDomainFSFreeze</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char ** mountpoints, <br/>					 unsigned int nmountpoints, <br/>					 unsigned int flags);
void	<a href="#virDomainFSInfoFree">virDomainFSInfoFree</a>		(<a href="libvirt-libvirt-domain.html#virDomainFSInfoPtr">virDomainFSInfoPtr</a> info);
int	<a href="#virDomainFSThaw">virDomainFSThaw</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char ** mountpoints, <br/>					 unsigned int nmountpoints, <br/>					 unsigned int flags);
int	<a href="#virDomainFSTrim">virDomainFSTrim</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * mountPoint, <br/>					 unsigned long long minimum, <br/>					 unsigned int flags);
int	<a href="#virDomainFree">virDomainFree</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetAutostart">virDomainGetAutostart</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * autostart);
int	<a href="#virDomainGetBlkioParameters">virDomainGetBlkioParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockInfo">virDomainGetBlockInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockIoTune">virDomainGetBlockIoTune</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetBlockJobInfo">virDomainGetBlockJobInfo</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetCPUStats">virDomainGetCPUStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 int start_cpu, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags);
<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a>	<a href="#virDomainGetConnect">virDomainGetConnect</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainGetControlInfo">virDomainGetControlInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a> info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetDiskErrors">virDomainGetDiskErrors</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a> errors, <br/>					 unsigned int maxerrors, <br/>					 unsigned int flags);
int	<a href="#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainGetFSInfo">virDomainGetFSInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainFSInfoPtr">virDomainFSInfoPtr</a> ** info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetGuestVcpus">virDomainGetGuestVcpus</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 unsigned int * nparams, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetHostname">virDomainGetHostname</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
unsigned int	<a href="#virDomainGetID">virDomainGetID</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetIOThreadInfo">virDomainGetIOThreadInfo</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainIOThreadInfoPtr">virDomainIOThreadInfoPtr</a> ** info, <br/>					 unsigned int flags);
int	<a href="#virDomainGetInfo">virDomainGetInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInfoPtr">virDomainInfoPtr</a> info);
int	<a href="#virDomainGetInterfaceParameters">virDomainGetInterfaceParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetJobInfo">virDomainGetJobInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info);
int	<a href="#virDomainGetJobStats">virDomainGetJobStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * type, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetLaunchSecurityInfo">virDomainGetLaunchSecurityInfo</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags);
unsigned long	<a href="#virDomainGetMaxMemory">virDomainGetMaxMemory</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetMaxVcpus">virDomainGetMaxVcpus</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetMemoryParameters">virDomainGetMemoryParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetMetadata">virDomainGetMetadata</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * uri, <br/>					 unsigned int flags);
const char *	<a href="#virDomainGetName">virDomainGetName</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetNumaParameters">virDomainGetNumaParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetOSType">virDomainGetOSType</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainGetPerfEvents">virDomainGetPerfEvents</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainGetSchedulerParameters">virDomainGetSchedulerParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams);
int	<a href="#virDomainGetSchedulerParametersFlags">virDomainGetSchedulerParametersFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int * nparams, <br/>						 unsigned int flags);
char *	<a href="#virDomainGetSchedulerType">virDomainGetSchedulerType</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * nparams);
int	<a href="#virDomainGetSecurityLabel">virDomainGetSecurityLabel</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel);
int	<a href="#virDomainGetSecurityLabelList">virDomainGetSecurityLabelList</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virSecurityLabelPtr">virSecurityLabelPtr</a> * seclabels);
int	<a href="#virDomainGetState">virDomainGetState</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * state, <br/>					 int * reason, <br/>					 unsigned int flags);
int	<a href="#virDomainGetTime">virDomainGetTime</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 long long * seconds, <br/>					 unsigned int * nseconds, <br/>					 unsigned int flags);
int	<a href="#virDomainGetUUID">virDomainGetUUID</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * uuid);
int	<a href="#virDomainGetUUIDString">virDomainGetUUIDString</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char * buf);
int	<a href="#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int ncpumaps, <br/>					 unsigned char * cpumaps, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainGetVcpus">virDomainGetVcpus</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br/>					 int maxinfo, <br/>					 unsigned char * cpumaps, <br/>					 int maplen);
int	<a href="#virDomainGetVcpusFlags">virDomainGetVcpusFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
char *	<a href="#virDomainGetXMLDesc">virDomainGetXMLDesc</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainHasManagedSaveImage">virDomainHasManagedSaveImage</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
void	<a href="#virDomainIOThreadInfoFree">virDomainIOThreadInfoFree</a>	(<a href="libvirt-libvirt-domain.html#virDomainIOThreadInfoPtr">virDomainIOThreadInfoPtr</a> info);
int	<a href="#virDomainInjectNMI">virDomainInjectNMI</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainInterfaceAddresses">virDomainInterfaceAddresses</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> ** ifaces, <br/>					 unsigned int source, <br/>					 unsigned int flags);
void	<a href="#virDomainInterfaceFree">virDomainInterfaceFree</a>		(<a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> iface);
int	<a href="#virDomainInterfaceStats">virDomainInterfaceStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br/>					 size_t size);
int	<a href="#virDomainIsActive">virDomainIsActive</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainIsPersistent">virDomainIsPersistent</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainIsUpdated">virDomainIsUpdated</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom);
int	<a href="#virDomainListGetStats">virDomainListGetStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> * doms, <br/>					 unsigned int stats, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> ** retStats, <br/>					 unsigned int flags);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByID">virDomainLookupByID</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int id);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByName">virDomainLookupByName</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUID">virDomainLookupByUUID</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainLookupByUUIDString">virDomainLookupByUUIDString</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr);
int	<a href="#virDomainManagedSave">virDomainManagedSave</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainManagedSaveDefineXML">virDomainManagedSaveDefineXML</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dxml, <br/>					 unsigned int flags);
char *	<a href="#virDomainManagedSaveGetXMLDesc">virDomainManagedSaveGetXMLDesc</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainManagedSaveRemove">virDomainManagedSaveRemove</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainMemoryPeek">virDomainMemoryPeek</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned long long start, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags);
int	<a href="#virDomainMemoryStats">virDomainMemoryStats</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br/>					 unsigned int nr_stats, <br/>					 unsigned int flags);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate">virDomainMigrate</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate2">virDomainMigrate2</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth);
<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	<a href="#virDomainMigrate3">virDomainMigrate3</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateGetCompressionCache">virDomainMigrateGetCompressionCache</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long * cacheSize, <br/>						 unsigned int flags);
int	<a href="#virDomainMigrateGetMaxDowntime">virDomainMigrateGetMaxDowntime</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long * downtime, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateGetMaxSpeed">virDomainMigrateGetMaxSpeed</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long * bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateSetCompressionCache">virDomainMigrateSetCompressionCache</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long cacheSize, <br/>						 unsigned int flags);
int	<a href="#virDomainMigrateSetMaxDowntime">virDomainMigrateSetMaxDowntime</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long downtime, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateSetMaxSpeed">virDomainMigrateSetMaxSpeed</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateStartPostCopy">virDomainMigrateStartPostCopy</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainMigrateToURI">virDomainMigrateToURI</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * duri, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth);
int	<a href="#virDomainMigrateToURI2">virDomainMigrateToURI2</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 const char * miguri, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth);
int	<a href="#virDomainMigrateToURI3">virDomainMigrateToURI3</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenChannel">virDomainOpenChannel</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * name, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenConsole">virDomainOpenConsole</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * dev_name, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenGraphics">virDomainOpenGraphics</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 int fd, <br/>					 unsigned int flags);
int	<a href="#virDomainOpenGraphicsFD">virDomainOpenGraphicsFD</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 unsigned int flags);
int	<a href="#virDomainPMSuspendForDuration">virDomainPMSuspendForDuration</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags);
int	<a href="#virDomainPMWakeup">virDomainPMWakeup</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags);
int	<a href="#virDomainPinEmulator">virDomainPinEmulator</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainPinIOThread">virDomainPinIOThread</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainPinVcpu">virDomainPinVcpu</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen);
int	<a href="#virDomainPinVcpuFlags">virDomainPinVcpuFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags);
int	<a href="#virDomainReboot">virDomainReboot</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainRef">virDomainRef</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainRename">virDomainRename</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * new_name, <br/>					 unsigned int flags);
int	<a href="#virDomainReset">virDomainReset</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainRestore">virDomainRestore</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from);
int	<a href="#virDomainRestoreFlags">virDomainRestoreFlags</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from, <br/>					 const char * dxml, <br/>					 unsigned int flags);
int	<a href="#virDomainResume">virDomainResume</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainSave">virDomainSave</a>			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to);
int	<a href="#virDomainSaveFlags">virDomainSaveFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 const char * dxml, <br/>					 unsigned int flags);
int	<a href="#virDomainSaveImageDefineXML">virDomainSaveImageDefineXML</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 const char * dxml, <br/>					 unsigned int flags);
char *	<a href="#virDomainSaveImageGetXMLDesc">virDomainSaveImageGetXMLDesc</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 unsigned int flags);
char *	<a href="#virDomainScreenshot">virDomainScreenshot</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned int screen, <br/>					 unsigned int flags);
int	<a href="#virDomainSendKey">virDomainSendKey</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int codeset, <br/>					 unsigned int holdtime, <br/>					 unsigned int * keycodes, <br/>					 int nkeycodes, <br/>					 unsigned int flags);
int	<a href="#virDomainSendProcessSignal">virDomainSendProcessSignal</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 long long pid_value, <br/>					 unsigned int signum, <br/>					 unsigned int flags);
int	<a href="#virDomainSetAutostart">virDomainSetAutostart</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int autostart);
int	<a href="#virDomainSetBlkioParameters">virDomainSetBlkioParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetBlockIoTune">virDomainSetBlockIoTune</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetBlockThreshold">virDomainSetBlockThreshold</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dev, <br/>					 unsigned long long threshold, <br/>					 unsigned int flags);
int	<a href="#virDomainSetGuestVcpus">virDomainSetGuestVcpus</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * cpumap, <br/>					 int state, <br/>					 unsigned int flags);
int	<a href="#virDomainSetIOThreadParams">virDomainSetIOThreadParams</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetInterfaceParameters">virDomainSetInterfaceParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetLifecycleAction">virDomainSetLifecycleAction</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int type, <br/>					 unsigned int action, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMaxMemory">virDomainSetMaxMemory</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory);
int	<a href="#virDomainSetMemory">virDomainSetMemory</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory);
int	<a href="#virDomainSetMemoryFlags">virDomainSetMemoryFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMemoryParameters">virDomainSetMemoryParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMemoryStatsPeriod">virDomainSetMemoryStatsPeriod</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int period, <br/>					 unsigned int flags);
int	<a href="#virDomainSetMetadata">virDomainSetMetadata</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * metadata, <br/>					 const char * key, <br/>					 const char * uri, <br/>					 unsigned int flags);
int	<a href="#virDomainSetNumaParameters">virDomainSetNumaParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetPerfEvents">virDomainSetPerfEvents</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags);
int	<a href="#virDomainSetSchedulerParameters">virDomainSetSchedulerParameters</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams);
int	<a href="#virDomainSetSchedulerParametersFlags">virDomainSetSchedulerParametersFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 unsigned int flags);
int	<a href="#virDomainSetTime">virDomainSetTime</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 long long seconds, <br/>					 unsigned int nseconds, <br/>					 unsigned int flags);
int	<a href="#virDomainSetUserPassword">virDomainSetUserPassword</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * user, <br/>					 const char * password, <br/>					 unsigned int flags);
int	<a href="#virDomainSetVcpu">virDomainSetVcpu</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * vcpumap, <br/>					 int state, <br/>					 unsigned int flags);
int	<a href="#virDomainSetVcpus">virDomainSetVcpus</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus);
int	<a href="#virDomainSetVcpusFlags">virDomainSetVcpusFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus, <br/>					 unsigned int flags);
int	<a href="#virDomainShutdown">virDomainShutdown</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainShutdownFlags">virDomainShutdownFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
void	<a href="#virDomainStatsRecordListFree">virDomainStatsRecordListFree</a>	(<a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> * stats);
int	<a href="#virDomainSuspend">virDomainSuspend</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainUndefine">virDomainUndefine</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain);
int	<a href="#virDomainUndefineFlags">virDomainUndefineFlags</a>		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags);
int	<a href="#virDomainUpdateDeviceFlags">virDomainUpdateDeviceFlags</a>	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags);
</pre>
    </div>
    <div class="refsect1" lang="en">
      <h2>Description</h2>
    </div>
    <div class="refsect1" lang="en">
      <h2>Details</h2>
      <div class="refsect2" lang="en">
        <div class="refsect2" lang="en"><h3><a name="VIR_COPY_CPUMAP">Macro </a>VIR_COPY_CPUMAP</h3><pre class="programlisting">#define <a href="#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a>(cpumaps, maplen, vcpu, cpumap);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt-domain.html#VIR_COPY_CPUMAP">VIR_COPY_CPUMAP</a> macro extracts the cpumap of the specified vcpu from cpumaps array and copies it into cpumap to be used later by virDomainPinVcpu() API.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_MAPLEN">Macro </a>VIR_CPU_MAPLEN</h3><pre class="programlisting">#define <a href="#VIR_CPU_MAPLEN">VIR_CPU_MAPLEN</a>(cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>number of physical CPUs</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_USABLE">Macro </a>VIR_CPU_USABLE</h3><pre class="programlisting">#define <a href="#VIR_CPU_USABLE">VIR_CPU_USABLE</a>(cpumaps, maplen, vcpu, cpu);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() API. <a href="libvirt-libvirt-domain.html#VIR_CPU_USABLE">VIR_CPU_USABLE</a> macro returns a non-zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_CPU_USED">Macro </a>VIR_CPU_USED</h3><pre class="programlisting">#define <a href="#VIR_CPU_USED">VIR_CPU_USED</a>(cpumap, cpu);
</pre><p>This macro can be used in conjunction with virNodeGetCPUMap() API. It returns non-zero if the bit of the related CPU is set.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_AVERAGE">VIR_DOMAIN_BANDWIDTH_IN_AVERAGE</a>;
</pre><p>Macro represents the inbound average of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_BURST">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_BURST</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_BURST">VIR_DOMAIN_BANDWIDTH_IN_BURST</a>;
</pre><p>Macro represents the inbound burst of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_FLOOR">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_FLOOR</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_FLOOR">VIR_DOMAIN_BANDWIDTH_IN_FLOOR</a>;
</pre><p>Macro represents the inbound floor of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_IN_PEAK">Macro </a>VIR_DOMAIN_BANDWIDTH_IN_PEAK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_IN_PEAK">VIR_DOMAIN_BANDWIDTH_IN_PEAK</a>;
</pre><p>Macro represents the inbound peak of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE">VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE</a>;
</pre><p>Macro represents the outbound average of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_BURST">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_BURST</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_BURST">VIR_DOMAIN_BANDWIDTH_OUT_BURST</a>;
</pre><p>Macro represents the outbound burst of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BANDWIDTH_OUT_PEAK">Macro </a>VIR_DOMAIN_BANDWIDTH_OUT_PEAK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BANDWIDTH_OUT_PEAK">VIR_DOMAIN_BANDWIDTH_OUT_PEAK</a>;
</pre><p>Macro represents the outbound peak of NIC bandwidth, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_READ_BPS">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_READ_BPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_READ_BPS">VIR_DOMAIN_BLKIO_DEVICE_READ_BPS</a>;
</pre><p>Macro for the blkio tunable throttle.read_iops_device: it represents the bytes of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_bps elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS">VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS</a>;
</pre><p>Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_iops elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WEIGHT">VIR_DOMAIN_BLKIO_DEVICE_WEIGHT</a>;
</pre><p>Macro for the blkio tunable weight_device: it represents the per-device weight, as a string. The string is parsed as a series of /path/to/device,weight elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS">VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS</a>;
</pre><p>Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, write_bps elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS">Macro </a>VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS">VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS</a>;
</pre><p>Macro for the blkio tunable throttle.write_iops_device: it represents the number of writing the block device per second, as a string. The string is parsed as a series of /path/to/device, write_iops elements, separated by ','.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_FIELD_LENGTH">Macro </a>VIR_DOMAIN_BLKIO_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_FIELD_LENGTH">VIR_DOMAIN_BLKIO_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virBlkioParameter. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLKIO_WEIGHT">Macro </a>VIR_DOMAIN_BLKIO_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLKIO_WEIGHT">VIR_DOMAIN_BLKIO_WEIGHT</a>;
</pre><p>Macro for the Blkio tunable weight: it represents the io weight the guest can use, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_COPY_BANDWIDTH">Macro </a>VIR_DOMAIN_BLOCK_COPY_BANDWIDTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_COPY_BANDWIDTH">VIR_DOMAIN_BLOCK_COPY_BANDWIDTH</a>;
</pre><p>Macro for the <a href="libvirt-libvirt-domain.html#virDomainBlockCopy">virDomainBlockCopy</a> bandwidth tunable: it represents the maximum bandwidth in bytes/s, and is used while getting the copy operation into the mirrored phase, with a type of ullong. For compatibility with virDomainBlockJobSetSpeed(), values larger than 2^52 bytes/sec (a 32-bit MiB/s value) may be rejected on input due to overflow considerations (but do you really have an interface with that much bandwidth?), and values larger than 2^31 bytes/sec may cause overflow problems if queried in bytes/sec. Hypervisors may further restrict the set of valid values. Specifying 0 is the same as omitting this parameter, to request no bandwidth limiting. Some hypervisors may lack support for this parameter, while still allowing a subsequent change of bandwidth via virDomainBlockJobSetSpeed(). The actual speed can be determined with virDomainGetBlockJobInfo().</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_COPY_BUF_SIZE">Macro </a>VIR_DOMAIN_BLOCK_COPY_BUF_SIZE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_COPY_BUF_SIZE">VIR_DOMAIN_BLOCK_COPY_BUF_SIZE</a>;
</pre><p>Macro for the <a href="libvirt-libvirt-domain.html#virDomainBlockCopy">virDomainBlockCopy</a> buffer size tunable: it represents how much data in bytes can be in flight between source and destination, as an unsigned long long. Specifying 0 is the same as omitting this parameter, to request the hypervisor default.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_COPY_GRANULARITY">Macro </a>VIR_DOMAIN_BLOCK_COPY_GRANULARITY</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_COPY_GRANULARITY">VIR_DOMAIN_BLOCK_COPY_GRANULARITY</a>;
</pre><p>Macro for the <a href="libvirt-libvirt-domain.html#virDomainBlockCopy">virDomainBlockCopy</a> granularity tunable: it represents the granularity in bytes at which the copy operation recognizes dirty blocks that need copying, as an unsigned int. Hypervisors may restrict this to be a power of two or fall within a certain range. Specifying 0 is the same as omitting this parameter, to request the hypervisor default.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME">VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents a group name to allow sharing of I/O throttling quota between multiple drives, as a string.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the read bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum read bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_bytes_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the read I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum read I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_iops_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the size I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the total bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum total bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_bytes_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the total I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_iops_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the write bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum write bytes per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_bytes_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the write I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the maximum write I/O operations per second permitted through a block device, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_iops_sec_max, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_ERRS">Macro </a>VIR_DOMAIN_BLOCK_STATS_ERRS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_ERRS">VIR_DOMAIN_BLOCK_STATS_ERRS</a>;
</pre><p>In Xen this returns the mysterious 'oo_req', as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">Macro </a>VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH">VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of parameter names when using virDomainBlockStatsFlags().</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ">VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ</a>;
</pre><p>Macro represents the total flush requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache flushing in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_BYTES">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_BYTES">VIR_DOMAIN_BLOCK_STATS_READ_BYTES</a>;
</pre><p>Macro represents the total number of read bytes of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_REQ">VIR_DOMAIN_BLOCK_STATS_READ_REQ</a>;
</pre><p>Macro represents the total read requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache reads in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES">VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES</a>;
</pre><p>Macro represents the total number of write bytes of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_REQ">VIR_DOMAIN_BLOCK_STATS_WRITE_REQ</a>;
</pre><p>Macro represents the total write requests of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">Macro </a>VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES">VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES</a>;
</pre><p>Macro represents the total time spend on cache writes in nano-seconds of the block device, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_CPUTIME">Macro </a>VIR_DOMAIN_CPU_STATS_CPUTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_CPUTIME">VIR_DOMAIN_CPU_STATS_CPUTIME</a>;
</pre><p>cpu usage (sum of both vcpu and hypervisor usage) in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_SYSTEMTIME">Macro </a>VIR_DOMAIN_CPU_STATS_SYSTEMTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_SYSTEMTIME">VIR_DOMAIN_CPU_STATS_SYSTEMTIME</a>;
</pre><p>cpu time charged to system instructions in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_USERTIME">Macro </a>VIR_DOMAIN_CPU_STATS_USERTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_USERTIME">VIR_DOMAIN_CPU_STATS_USERTIME</a>;
</pre><p>cpu time charged to user instructions in nanoseconds, as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_CPU_STATS_VCPUTIME">Macro </a>VIR_DOMAIN_CPU_STATS_VCPUTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_CPU_STATS_VCPUTIME">VIR_DOMAIN_CPU_STATS_VCPUTIME</a>;
</pre><p>vcpu usage in nanoseconds (cpu_time excluding hypervisor time), as a ullong</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_EVENT_CALLBACK">Macro </a>VIR_DOMAIN_EVENT_CALLBACK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_EVENT_CALLBACK">VIR_DOMAIN_EVENT_CALLBACK</a>;
</pre><p>Used to cast the event specific callback into the generic one for use for virConnectDomainEventRegisterAny()</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_IOTHREAD_POLL_GROW">Macro </a>VIR_DOMAIN_IOTHREAD_POLL_GROW</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_GROW">VIR_DOMAIN_IOTHREAD_POLL_GROW</a>;
</pre><p>This provides a value for the dynamic polling adjustment algorithm to use to grow its polling interval up to the poll_max_ns value. A value of 0 (zero) allows the hypervisor to choose its own value. The algorithm to use for adjustment is hypervisor specific.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_IOTHREAD_POLL_MAX_NS">Macro </a>VIR_DOMAIN_IOTHREAD_POLL_MAX_NS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_MAX_NS">VIR_DOMAIN_IOTHREAD_POLL_MAX_NS</a>;
</pre><p>The maximum polling time that can be used by polling algorithm in ns. The polling time starts at 0 (zero) and is the time spent by the guest to process IOThread data before returning the CPU to the host. The polling time will be dynamically modified over time based on the poll_grow and poll_shrink parameters provided. A value set too large will cause more CPU time to be allocated the guest. A value set too small will not provide enough cycles for the guest to process data. The polling interval is not available for statistical purposes.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_IOTHREAD_POLL_SHRINK">Macro </a>VIR_DOMAIN_IOTHREAD_POLL_SHRINK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_IOTHREAD_POLL_SHRINK">VIR_DOMAIN_IOTHREAD_POLL_SHRINK</a>;
</pre><p>This provides a value for the dynamic polling adjustment algorithm to use to shrink its polling interval when the polling interval exceeds the poll_max_ns value. A value of 0 (zero) allows the hypervisor to choose its own value. The algorithm to use for adjustment is hypervisor specific.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE">Macro </a>VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE">VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: current percentage guest CPUs are throttled to when auto-convergence decided migration was not converging, as VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_BYTES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_BYTES">VIR_DOMAIN_JOB_COMPRESSION_BYTES</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed bytes transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_CACHE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE">VIR_DOMAIN_JOB_COMPRESSION_CACHE</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES">VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were not found in compression cache and thus could not be compressed, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW">VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of repeatedly changing pages that were found in compression cache but were sent uncompressed because the result of compression was larger than the original page as a whole, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_COMPRESSION_PAGES">Macro </a>VIR_DOMAIN_JOB_COMPRESSION_PAGES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of compressed pages transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_PROCESSED">Macro </a>VIR_DOMAIN_JOB_DATA_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred from the beginning of the job, as VIR_TYPED_PARAM_ULLONG. This field corresponds to dataProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_REMAINING">Macro </a>VIR_DOMAIN_JOB_DATA_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes that still need to be transferred, as VIR_TYPED_PARAM_ULLONG. This field corresponds to dataRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DATA_TOTAL">Macro </a>VIR_DOMAIN_JOB_DATA_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: total number of bytes supposed to be transferred, as VIR_TYPED_PARAM_ULLONG. For <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a> jobs, this may be less than the sum of <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> and <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> in the event that the hypervisor has to repeat some data, e.g., due to dirtied pages during migration. For <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> shall always equal <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> + VIR_DOMAIN_JOB_DATA_REMAINING. This field corresponds to dataTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_BPS">Macro </a>VIR_DOMAIN_JOB_DISK_BPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_BPS">VIR_DOMAIN_JOB_DISK_BPS</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: network throughput used while migrating disks in Bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_PROCESSED">Macro </a>VIR_DOMAIN_JOB_DISK_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_PROCESSED">VIR_DOMAIN_JOB_DISK_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_REMAINING">Macro </a>VIR_DOMAIN_JOB_DISK_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_REMAINING">VIR_DOMAIN_JOB_DISK_REMAINING</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DISK_TOTAL">Macro </a>VIR_DOMAIN_JOB_DISK_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DISK_TOTAL">VIR_DOMAIN_JOB_DISK_TOTAL</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to fileTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DOWNTIME">Macro </a>VIR_DOMAIN_JOB_DOWNTIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DOWNTIME">VIR_DOMAIN_JOB_DOWNTIME</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: downtime (ms) that is expected to happen during migration, as VIR_TYPED_PARAM_ULLONG. The real computed downtime between the time guest CPUs were paused and the time they were resumed is reported for completed migration.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_DOWNTIME_NET">Macro </a>VIR_DOMAIN_JOB_DOWNTIME_NET</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_DOWNTIME_NET">VIR_DOMAIN_JOB_DOWNTIME_NET</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: real measured downtime (ms) NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_BPS">Macro </a>VIR_DOMAIN_JOB_MEMORY_BPS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_BPS">VIR_DOMAIN_JOB_MEMORY_BPS</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: network throughput used while migrating memory in Bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_CONSTANT">Macro </a>VIR_DOMAIN_JOB_MEMORY_CONSTANT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_CONSTANT">VIR_DOMAIN_JOB_MEMORY_CONSTANT</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages filled with a constant byte (all bytes in a single page are identical) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG. The most common example of such pages are zero pages, i.e., pages filled with zero bytes.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE">Macro </a>VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE">VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of memory pages dirtied by the guest per second, as VIR_TYPED_PARAM_ULLONG. This statistics makes sense only when live migration is running.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_ITERATION">Macro </a>VIR_DOMAIN_JOB_MEMORY_ITERATION</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_ITERATION">VIR_DOMAIN_JOB_MEMORY_ITERATION</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: current iteration over domain's memory during live migration, as VIR_TYPED_PARAM_ULLONG. This is set to zero when memory starts to be transferred and the value is increased by one every time a new iteration is started to transfer memory pages dirtied since the last iteration.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL">Macro </a>VIR_DOMAIN_JOB_MEMORY_NORMAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of pages that were transferred without any kind of compression (i.e., pages which were not filled with a constant byte and which could not be compressed) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">Macro </a>VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES">VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number of bytes transferred as normal pages, as VIR_TYPED_PARAM_ULLONG. See <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_MEMORY_NORMAL">VIR_DOMAIN_JOB_MEMORY_NORMAL</a> for more details.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE">Macro </a>VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE">VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: memory page size in bytes, as VIR_TYPED_PARAM_ULLONG. If present, this parameter can be used to convert other page based statistics, such as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE">VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_COMPRESSION_PAGES">VIR_DOMAIN_JOB_COMPRESSION_PAGES</a> to bytes.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS">Macro </a>VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS">VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: number page requests received from the destination host during post-copy migration, as VIR_TYPED_PARAM_ULLONG. This counter is incremented whenever the migrated domain tries to access a memory page which has not been transferred from the source host yet.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_PROCESSED">Macro </a>VIR_DOMAIN_JOB_MEMORY_PROCESSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_PROCESSED">VIR_DOMAIN_JOB_MEMORY_PROCESSED</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_PROCESSED">VIR_DOMAIN_JOB_DATA_PROCESSED</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memProcessed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_REMAINING">Macro </a>VIR_DOMAIN_JOB_MEMORY_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_REMAINING">VIR_DOMAIN_JOB_MEMORY_REMAINING</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_REMAINING">VIR_DOMAIN_JOB_DATA_REMAINING</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_MEMORY_TOTAL">Macro </a>VIR_DOMAIN_JOB_MEMORY_TOTAL</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_MEMORY_TOTAL">VIR_DOMAIN_JOB_MEMORY_TOTAL</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: as <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_DATA_TOTAL">VIR_DOMAIN_JOB_DATA_TOTAL</a> but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG. This field corresponds to memTotal field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_OPERATION">Macro </a>VIR_DOMAIN_JOB_OPERATION</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_OPERATION">VIR_DOMAIN_JOB_OPERATION</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: the operation which started the job as VIR_TYPED_PARAM_INT. The values correspond to the items in <a href="libvirt-libvirt-domain.html#virDomainJobOperation">virDomainJobOperation</a> enum.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_SETUP_TIME">Macro </a>VIR_DOMAIN_JOB_SETUP_TIME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_SETUP_TIME">VIR_DOMAIN_JOB_SETUP_TIME</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: total time in milliseconds spent preparing the migration in the 'setup' phase before the iterations begin, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_TIME_ELAPSED">Macro </a>VIR_DOMAIN_JOB_TIME_ELAPSED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED">VIR_DOMAIN_JOB_TIME_ELAPSED</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: time (ms) since the beginning of the job, as VIR_TYPED_PARAM_ULLONG. This field corresponds to timeElapsed field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_TIME_ELAPSED_NET">Macro </a>VIR_DOMAIN_JOB_TIME_ELAPSED_NET</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_TIME_ELAPSED_NET">VIR_DOMAIN_JOB_TIME_ELAPSED_NET</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: time (ms) since the beginning of the migration job NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_JOB_TIME_REMAINING">Macro </a>VIR_DOMAIN_JOB_TIME_REMAINING</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_JOB_TIME_REMAINING">VIR_DOMAIN_JOB_TIME_REMAINING</a>;
</pre><p><a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> field: remaining time (ms) for <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> jobs, as VIR_TYPED_PARAM_ULLONG. This field corresponds to timeRemaining field in virDomainJobInfo.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT">Macro </a>VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT">VIR_DOMAIN_LAUNCH_SECURITY_SEV_MEASUREMENT</a>;
</pre><p>Macro represents the launch measurement of the SEV guest, as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_FIELD_LENGTH">Macro </a>VIR_DOMAIN_MEMORY_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_FIELD_LENGTH">VIR_DOMAIN_MEMORY_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virMemoryParameter. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_HARD_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_HARD_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_HARD_LIMIT">VIR_DOMAIN_MEMORY_HARD_LIMIT</a>;
</pre><p>Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_MIN_GUARANTEE">Macro </a>VIR_DOMAIN_MEMORY_MIN_GUARANTEE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_MIN_GUARANTEE">VIR_DOMAIN_MEMORY_MIN_GUARANTEE</a>;
</pre><p>Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">Macro </a>VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_PARAM_UNLIMITED">VIR_DOMAIN_MEMORY_PARAM_UNLIMITED</a>;
</pre><p>Macro providing the <a href="libvirt-libvirt-domain.html#virMemoryParameter">virMemoryParameter</a> value that indicates "unlimited"</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_SOFT_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_SOFT_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_SOFT_LIMIT">VIR_DOMAIN_MEMORY_SOFT_LIMIT</a>;
</pre><p>Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">Macro </a>VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT">VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT</a>;
</pre><p>Macro for the swap tunable swap_hard_limit: it represents the maximum swap plus memory the guest can use, as a ullong. This limit has to be more than VIR_DOMAIN_MEMORY_HARD_LIMIT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_NUMA_MODE">Macro </a>VIR_DOMAIN_NUMA_MODE</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_NUMA_MODE">VIR_DOMAIN_NUMA_MODE</a>;
</pre><p>Macro for typed parameter name that lists the numa mode of a domain, as an int containing a <a href="libvirt-libvirt-domain.html#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a> value.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_NUMA_NODESET">Macro </a>VIR_DOMAIN_NUMA_NODESET</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_NUMA_NODESET">VIR_DOMAIN_NUMA_NODESET</a>;
</pre><p>Macro for typed parameter name that lists the numa nodeset of a domain, as a string.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_CAP">Macro </a>VIR_DOMAIN_SCHEDULER_CAP</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_CAP">VIR_DOMAIN_SCHEDULER_CAP</a>;
</pre><p>Macro represents the maximum scheduler cap, when using the credit scheduler, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_CPU_SHARES">Macro </a>VIR_DOMAIN_SCHEDULER_CPU_SHARES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_CPU_SHARES">VIR_DOMAIN_SCHEDULER_CPU_SHARES</a>;
</pre><p>Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD">VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA">VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD">VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA">VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD">VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for IOThreads only, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA">VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for IOThreads only, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_LIMIT">Macro </a>VIR_DOMAIN_SCHEDULER_LIMIT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_LIMIT">VIR_DOMAIN_SCHEDULER_LIMIT</a>;
</pre><p>Macro represents the scheduler limit value, when using the allocation scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_RESERVATION">Macro </a>VIR_DOMAIN_SCHEDULER_RESERVATION</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_RESERVATION">VIR_DOMAIN_SCHEDULER_RESERVATION</a>;
</pre><p>Macro represents the scheduler reservation value, when using the allocation scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_SHARES">Macro </a>VIR_DOMAIN_SCHEDULER_SHARES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_SHARES">VIR_DOMAIN_SCHEDULER_SHARES</a>;
</pre><p>Macro represents the scheduler shares value, when using the allocation scheduler, as an int.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">Macro </a>VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_PERIOD">VIR_DOMAIN_SCHEDULER_VCPU_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as a ullong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">Macro </a>VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_VCPU_QUOTA">VIR_DOMAIN_SCHEDULER_VCPU_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as an llong.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHEDULER_WEIGHT">Macro </a>VIR_DOMAIN_SCHEDULER_WEIGHT</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHEDULER_WEIGHT">VIR_DOMAIN_SCHEDULER_WEIGHT</a>;
</pre><p>Macro represents the relative weight, when using the credit scheduler, as a uint.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SCHED_FIELD_LENGTH">Macro </a>VIR_DOMAIN_SCHED_FIELD_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SCHED_FIELD_LENGTH">VIR_DOMAIN_SCHED_FIELD_LENGTH</a>;
</pre><p>Macro providing the field length of virSchedParameter. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#VIR_TYPED_PARAM_FIELD_LENGTH">VIR_TYPED_PARAM_FIELD_LENGTH</a> is the preferred value since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_SEND_KEY_MAX_KEYS">Macro </a>VIR_DOMAIN_SEND_KEY_MAX_KEYS</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a>;
</pre><p>Maximum number of keycodes that can be sent in one virDomainSendKey() call.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_DISK">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_DISK</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_DISK">VIR_DOMAIN_TUNABLE_BLKDEV_DISK</a>;
</pre><p>Macro represents the name of guest disk for which the values are updated, as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME">VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME</a>;
</pre><p>Macro represents the group name to be used, as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC</a>;
</pre><p>Macro represents the read throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX</a>;
</pre><p>Macro represents the read throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_bytes_sec_max as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC</a>;
</pre><p>Macro represents the read I/O operations per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX</a>;
</pre><p>Macro represents the read maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_iops_sec_max as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC</a>;
</pre><p>Macro represents the size maximum I/O operations per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC</a>;
</pre><p>Macro represents the total throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX</a>;
</pre><p>Macro represents the total throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_bytes_sec_max, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC</a>;
</pre><p>Macro represents the total I/O operations per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX</a>;
</pre><p>Macro represents the total maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_iops_sec_max as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC</a>;
</pre><p>Macro represents the write throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX</a>;
</pre><p>Macro represents the write throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_bytes_sec_max as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC</a>;
</pre><p>Macro represents the write I/O operations per second, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX</a>;
</pre><p>Macro represents the write maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH">Macro </a>VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH">VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH</a>;
</pre><p>Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_iops_sec_max as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES">Macro </a>VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES">VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES</a>;
</pre><p>Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN">Macro </a>VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN">VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN</a>;
</pre><p>Macro represents formatted pinning for emulator process, as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD">Macro </a>VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD">VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA">Macro </a>VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA">VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an VIR_TYPED_PARAM_LLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD">Macro </a>VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD">VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA">Macro </a>VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA">VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN">Macro </a>VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN">VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN</a>;
</pre><p>Macro represents formatted pinning for one IOThread specified by id which is appended to the parameter name, for example "cputune.iothreadpin1", as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD">Macro </a>VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD">VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA">Macro </a>VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA">VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_VCPUPIN">Macro </a>VIR_DOMAIN_TUNABLE_CPU_VCPUPIN</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPUPIN">VIR_DOMAIN_TUNABLE_CPU_VCPUPIN</a>;
</pre><p>Macro represents formatted pinning for one vcpu specified by id which is appended to the parameter name, for example "cputune.vcpupin1", as VIR_TYPED_PARAM_STRING.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD">Macro </a>VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD">VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD</a>;
</pre><p>Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA">Macro </a>VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA</h3><pre class="programlisting">#define <a href="#VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA">VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA</a>;
</pre><p>Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_GET_CPUMAP">Macro </a>VIR_GET_CPUMAP</h3><pre class="programlisting">#define <a href="#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a>(cpumaps, maplen, vcpu);
</pre><p>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. <a href="libvirt-libvirt-domain.html#VIR_GET_CPUMAP">VIR_GET_CPUMAP</a> macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to an array of cpumap (in 8-bit bytes) (IN)</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the length (in bytes) of one cpumap</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>the virtual CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_KEYCODE_SET_RFB">Macro </a>VIR_KEYCODE_SET_RFB</h3><pre class="programlisting">#define <a href="#VIR_KEYCODE_SET_RFB">VIR_KEYCODE_SET_RFB</a>;
</pre><p>Compatibility alias for VIR_KEYCODE_SET_QNUM, which replaced it since 4.2.0.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT">Macro </a>VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT">VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT</a>;
</pre><p>virDomainMigrate* params field: the increment added to <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL">VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL</a> whenever the hypervisor decides the current rate is not enough to ensure convergence of the migration. As VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL">Macro </a>VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL">VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL</a>;
</pre><p>virDomainMigrate* params field: the initial percentage guest CPUs are throttled to when auto-convergence decides migration is not converging. As VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_BANDWIDTH">Macro </a>VIR_MIGRATE_PARAM_BANDWIDTH</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH">VIR_MIGRATE_PARAM_BANDWIDTH</a>;
</pre><p>virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if this field is used and is not 0.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY">Macro </a>VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY">VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY</a>;
</pre><p>virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for post-copy phase of a migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, post-copy migration speed will not be limited.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_COMPRESSION">Macro </a>VIR_MIGRATE_PARAM_COMPRESSION</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION">VIR_MIGRATE_PARAM_COMPRESSION</a>;
</pre><p>virDomainMigrate* params multiple field: name of the method used to compress migration traffic. Supported compression methods: xbzrle, mt. The parameter may be specified multiple times if more than one method should be used.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS">Macro </a>VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS">VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS</a>;
</pre><p>virDomainMigrate* params field: the number of decompression threads for multithread compression as VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL">Macro </a>VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL">VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL</a>;
</pre><p>virDomainMigrate* params field: the level of compression for multithread compression as VIR_TYPED_PARAM_INT. Accepted values are in range 0-9. 0 is no compression, 1 is maximum speed and 9 is maximum compression.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS">Macro </a>VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS">VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS</a>;
</pre><p>virDomainMigrate* params field: the number of compression threads for multithread compression as VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE">Macro </a>VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE">VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE</a>;
</pre><p>virDomainMigrate* params field: the size of page cache for xbzrle compression as VIR_TYPED_PARAM_ULLONG.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_DEST_NAME">Macro </a>VIR_MIGRATE_PARAM_DEST_NAME</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a>;
</pre><p>virDomainMigrate* params field: the name to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. Omitting this parameter keeps the domain name the same. This field is only allowed to be used with hypervisors that support domain renaming during migration.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_DEST_XML">Macro </a>VIR_MIGRATE_PARAM_DEST_XML</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_DEST_XML">VIR_MIGRATE_PARAM_DEST_XML</a>;
</pre><p>virDomainMigrate* params field: the new configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors which support this field will forbid migration if the provided XML would cause a change in the guest ABI. This field cannot be used to rename the domain during migration (use <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a> field for that purpose). Domain name in the destination XML must match the original domain name. Omitting this parameter keeps the original domain configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_DISKS_PORT">Macro </a>VIR_MIGRATE_PARAM_DISKS_PORT</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_DISKS_PORT">VIR_MIGRATE_PARAM_DISKS_PORT</a>;
</pre><p>virDomainMigrate* params field: port that destination server should use for incoming disks migration. Type is VIR_TYPED_PARAM_INT. If set to 0 or omitted, libvirt will choose a suitable default. At the moment this is only supported by the QEMU driver.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_GRAPHICS_URI">Macro </a>VIR_MIGRATE_PARAM_GRAPHICS_URI</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_GRAPHICS_URI">VIR_MIGRATE_PARAM_GRAPHICS_URI</a>;
</pre><p>virDomainMigrate* params field: URI to use for migrating client's connection to domain's graphical console as VIR_TYPED_PARAM_STRING. If specified, the client will be asked to automatically reconnect using these parameters instead of the automatically computed ones. This can be useful if, e.g., the client does not have a direct access to the network virtualization hosts are connected to and needs to connect through a proxy. The URI is formed as follows: protocol://hostname[:port]/[?parameters] where protocol is either "spice" or "vnc" and parameters is a list of protocol specific parameters separated by '&amp;'. Currently recognized parameters are "tlsPort" and "tlsSubject". For example, spice://target.host.com:1234/?tlsPort=4567</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_LISTEN_ADDRESS">Macro </a>VIR_MIGRATE_PARAM_LISTEN_ADDRESS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_LISTEN_ADDRESS">VIR_MIGRATE_PARAM_LISTEN_ADDRESS</a>;
</pre><p>virDomainMigrate* params field: The listen address that hypervisor on the destination side should bind to for incoming migration. Both IPv4 and IPv6 addresses are accepted as well as hostnames (the resolving is done on destination). Some hypervisors do not support this feature and will return an error if this field is used.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_MIGRATE_DISKS">Macro </a>VIR_MIGRATE_PARAM_MIGRATE_DISKS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_MIGRATE_DISKS">VIR_MIGRATE_PARAM_MIGRATE_DISKS</a>;
</pre><p>virDomainMigrate* params multiple field: The multiple values that list the block devices to be migrated. At the moment this is only supported by the QEMU driver but not for the tunnelled migration.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS">Macro </a>VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS">VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS</a>;
</pre><p>virDomainMigrate* params field: number of connections used during parallel migration. As VIR_TYPED_PARAM_INT.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_PERSIST_XML">Macro </a>VIR_MIGRATE_PARAM_PERSIST_XML</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_PERSIST_XML">VIR_MIGRATE_PARAM_PERSIST_XML</a>;
</pre><p>virDomainMigrate* params field: the new persistent configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. This field cannot be used to rename the domain during migration (use <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_DEST_NAME">VIR_MIGRATE_PARAM_DEST_NAME</a> field for that purpose). Domain name in the destination XML must match the original domain name. Omitting this parameter keeps the original domain persistent configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_MIGRATE_PARAM_URI">Macro </a>VIR_MIGRATE_PARAM_URI</h3><pre class="programlisting">#define <a href="#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a>;
</pre><p>virDomainMigrate* params field: URI to use for initiating domain migration as VIR_TYPED_PARAM_STRING. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. When omitted libvirt will auto-generate suitable default URI. It is typically only necessary to specify this URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data. This field may not be used when <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> flag is set.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_ALIGNMENT_FAULTS">Macro </a>VIR_PERF_PARAM_ALIGNMENT_FAULTS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_ALIGNMENT_FAULTS">VIR_PERF_PARAM_ALIGNMENT_FAULTS</a>;
</pre><p>Macro for typed parameter name that represents alignment_faults perf event which can be used to measure the count of alignment faults by applications running on the platform. It corresponds to the "perf.alignment_faults" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_BRANCH_INSTRUCTIONS">Macro </a>VIR_PERF_PARAM_BRANCH_INSTRUCTIONS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_BRANCH_INSTRUCTIONS">VIR_PERF_PARAM_BRANCH_INSTRUCTIONS</a>;
</pre><p>Macro for typed parameter name that represents branch_instructions perf event which can be used to measure the count of branch instructions by applications running on the platform. It corresponds to the "perf.branch_instructions" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_BRANCH_MISSES">Macro </a>VIR_PERF_PARAM_BRANCH_MISSES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_BRANCH_MISSES">VIR_PERF_PARAM_BRANCH_MISSES</a>;
</pre><p>Macro for typed parameter name that represents branch_misses perf event which can be used to measure the count of branch misses by applications running on the platform. It corresponds to the "perf.branch_misses" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_BUS_CYCLES">Macro </a>VIR_PERF_PARAM_BUS_CYCLES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_BUS_CYCLES">VIR_PERF_PARAM_BUS_CYCLES</a>;
</pre><p>Macro for typed parameter name that represents bus_cycles perf event which can be used to measure the count of bus cycles by applications running on the platform. It corresponds to the "perf.bus_cycles" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CACHE_MISSES">Macro </a>VIR_PERF_PARAM_CACHE_MISSES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CACHE_MISSES">VIR_PERF_PARAM_CACHE_MISSES</a>;
</pre><p>Macro for typed parameter name that represents cache_misses perf event which can be used to measure the count of cache misses by applications running on the platform. It corresponds to the "perf.cache_misses" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CACHE_REFERENCES">Macro </a>VIR_PERF_PARAM_CACHE_REFERENCES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CACHE_REFERENCES">VIR_PERF_PARAM_CACHE_REFERENCES</a>;
</pre><p>Macro for typed parameter name that represents cache_references perf event which can be used to measure the count of cache hits by applications running on the platform. It corresponds to the "perf.cache_references" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CMT">Macro </a>VIR_PERF_PARAM_CMT</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CMT">VIR_PERF_PARAM_CMT</a>;
</pre><p>Macro for typed parameter name that represents CMT perf event which can be used to measure the usage of cache (bytes) by applications running on the platform. It corresponds to the "perf.cmt" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CONTEXT_SWITCHES">Macro </a>VIR_PERF_PARAM_CONTEXT_SWITCHES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CONTEXT_SWITCHES">VIR_PERF_PARAM_CONTEXT_SWITCHES</a>;
</pre><p>Macro for typed parameter name that represents context_switches perf event which can be used to measure the count of context switches by applications running on the platform. It corresponds to the "perf.context_switches" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CPU_CLOCK">Macro </a>VIR_PERF_PARAM_CPU_CLOCK</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CPU_CLOCK">VIR_PERF_PARAM_CPU_CLOCK</a>;
</pre><p>Macro for typed parameter name that represents cpu_clock perf event which can be used to measure the count of cpu clock time by applications running on the platform. It corresponds to the "perf.cpu_clock" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CPU_CYCLES">Macro </a>VIR_PERF_PARAM_CPU_CYCLES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CPU_CYCLES">VIR_PERF_PARAM_CPU_CYCLES</a>;
</pre><p>Macro for typed parameter name that represents cpu_cycles perf event describing the total/elapsed cpu cycles. This can be used to measure how many cpu cycles one instruction needs. It corresponds to the "perf.cpu_cycles" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_CPU_MIGRATIONS">Macro </a>VIR_PERF_PARAM_CPU_MIGRATIONS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_CPU_MIGRATIONS">VIR_PERF_PARAM_CPU_MIGRATIONS</a>;
</pre><p>Macro for typed parameter name that represents cpu_migrations perf event which can be used to measure the count of cpu migrations by applications running on the platform. It corresponds to the "perf.cpu_migrations" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_EMULATION_FAULTS">Macro </a>VIR_PERF_PARAM_EMULATION_FAULTS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_EMULATION_FAULTS">VIR_PERF_PARAM_EMULATION_FAULTS</a>;
</pre><p>Macro for typed parameter name that represents emulation_faults perf event which can be used to measure the count of emulation faults by applications running on the platform. It corresponds to the "perf.emulation_faults" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_INSTRUCTIONS">Macro </a>VIR_PERF_PARAM_INSTRUCTIONS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_INSTRUCTIONS">VIR_PERF_PARAM_INSTRUCTIONS</a>;
</pre><p>Macro for typed parameter name that represents instructions perf event which can be used to measure the count of instructions by applications running on the platform. It corresponds to the "perf.instructions" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_MBML">Macro </a>VIR_PERF_PARAM_MBML</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_MBML">VIR_PERF_PARAM_MBML</a>;
</pre><p>Macro for typed parameter name that represents MBML perf event which can be used to monitor the amount of data (bytes/s) sent through the memory controller on the socket. It corresponds to the "perf.mbml" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_MBMT">Macro </a>VIR_PERF_PARAM_MBMT</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_MBMT">VIR_PERF_PARAM_MBMT</a>;
</pre><p>Macro for typed parameter name that represents MBMT perf event which can be used to monitor total system bandwidth (bytes/s) from one level of cache to another. It corresponds to the "perf.mbmt" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_PAGE_FAULTS">Macro </a>VIR_PERF_PARAM_PAGE_FAULTS</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS">VIR_PERF_PARAM_PAGE_FAULTS</a>;
</pre><p>Macro for typed parameter name that represents page_faults perf event which can be used to measure the count of page faults by applications running on the platform. It corresponds to the "perf.page_faults" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_PAGE_FAULTS_MAJ">Macro </a>VIR_PERF_PARAM_PAGE_FAULTS_MAJ</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS_MAJ">VIR_PERF_PARAM_PAGE_FAULTS_MAJ</a>;
</pre><p>Macro for typed parameter name that represents page_faults_maj perf event which can be used to measure the count of major page faults by applications running on the platform. It corresponds to the "perf.page_faults_maj" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_PAGE_FAULTS_MIN">Macro </a>VIR_PERF_PARAM_PAGE_FAULTS_MIN</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_PAGE_FAULTS_MIN">VIR_PERF_PARAM_PAGE_FAULTS_MIN</a>;
</pre><p>Macro for typed parameter name that represents page_faults_min perf event which can be used to measure the count of minor page faults by applications running on the platform. It corresponds to the "perf.page_faults_min" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_REF_CPU_CYCLES">Macro </a>VIR_PERF_PARAM_REF_CPU_CYCLES</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_REF_CPU_CYCLES">VIR_PERF_PARAM_REF_CPU_CYCLES</a>;
</pre><p>Macro for typed parameter name that represents ref_cpu_cycles perf event which can be used to measure the count of total cpu cycles not affected by CPU frequency scaling by applications running on the platform. It corresponds to the "perf.ref_cpu_cycles" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_STALLED_CYCLES_BACKEND">Macro </a>VIR_PERF_PARAM_STALLED_CYCLES_BACKEND</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_STALLED_CYCLES_BACKEND">VIR_PERF_PARAM_STALLED_CYCLES_BACKEND</a>;
</pre><p>Macro for typed parameter name that represents stalled_cycles_backend perf event which can be used to measure the count of stalled cpu cycles in the backend of the instruction processor pipeline by application running on the platform. It corresponds to the "perf.stalled_cycles_backend" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND">Macro </a>VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND">VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND</a>;
</pre><p>Macro for typed parameter name that represents stalled_cycles_frontend perf event which can be used to measure the count of stalled cpu cycles in the frontend of the instruction processor pipeline by applications running on the platform. It corresponds to the "perf.stalled_cycles_frontend" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_PERF_PARAM_TASK_CLOCK">Macro </a>VIR_PERF_PARAM_TASK_CLOCK</h3><pre class="programlisting">#define <a href="#VIR_PERF_PARAM_TASK_CLOCK">VIR_PERF_PARAM_TASK_CLOCK</a>;
</pre><p>Macro for typed parameter name that represents task_clock perf event which can be used to measure the count of task clock time by applications running on the platform. It corresponds to the "perf.task_clock" field in the *Stats APIs.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_UNUSE_CPU">Macro </a>VIR_UNUSE_CPU</h3><pre class="programlisting">#define <a href="#VIR_UNUSE_CPU">VIR_UNUSE_CPU</a>(cpumap, cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It resets the bit (CPU not usable) of the related cpu in cpumap.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="VIR_USE_CPU">Macro </a>VIR_USE_CPU</h3><pre class="programlisting">#define <a href="#VIR_USE_CPU">VIR_USE_CPU</a>(cpumap, cpu);
</pre><p>This macro is to be used in conjunction with virDomainPinVcpu() API. It sets the bit (CPU usable) of the related cpu in cpumap.</p><div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)</td></tr><tr><td><span class="term"><i><tt>cpu</tt></i>:</span></td><td>the physical CPU number</td></tr></tbody></table></div>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virBlkioParameter">Macro </a>_virBlkioParameter</h3><pre class="programlisting">#define <a href="#_virBlkioParameter">_virBlkioParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virMemoryParameter">Macro </a>_virMemoryParameter</h3><pre class="programlisting">#define <a href="#_virMemoryParameter">_virMemoryParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="_virSchedParameter">Macro </a>_virSchedParameter</h3><pre class="programlisting">#define <a href="#_virSchedParameter">_virSchedParameter</a>;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameter">Structure </a>virBlkioParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt-common.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virBlkioParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameterPtr">Typedef </a>virBlkioParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virBlkioParameter">virBlkioParameter</a> * virBlkioParameterPtr;
</pre><p>a <a href="libvirt-libvirt-domain.html#virBlkioParameterPtr">virBlkioParameterPtr</a> is a pointer to a <a href="libvirt-libvirt-domain.html#virBlkioParameter">virBlkioParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virBlkioParameterType">Enum </a>virBlkioParameterType</h3><pre class="programlisting">enum <a href="#virBlkioParameterType">virBlkioParameterType</a> {
    <a name="VIR_DOMAIN_BLKIO_PARAM_BOOLEAN">VIR_DOMAIN_BLKIO_PARAM_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_BLKIO_PARAM_DOUBLE">VIR_DOMAIN_BLKIO_PARAM_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_BLKIO_PARAM_INT">VIR_DOMAIN_BLKIO_PARAM_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_BLKIO_PARAM_LLONG">VIR_DOMAIN_BLKIO_PARAM_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_BLKIO_PARAM_UINT">VIR_DOMAIN_BLKIO_PARAM_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_BLKIO_PARAM_ULLONG">VIR_DOMAIN_BLKIO_PARAM_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventAgentLifecycleReason">Enum </a>virConnectDomainEventAgentLifecycleReason</h3><pre class="programlisting">enum <a href="#virConnectDomainEventAgentLifecycleReason">virConnectDomainEventAgentLifecycleReason</a> {
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN</a> = 0 /* unknown state change reason */
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED</a> = 1 /* state changed due to domain start */
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL</a> = 2 /* channel state changed */
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventAgentLifecycleState">Enum </a>virConnectDomainEventAgentLifecycleState</h3><pre class="programlisting">enum <a href="#virConnectDomainEventAgentLifecycleState">virConnectDomainEventAgentLifecycleState</a> {
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED</a> = 1 /* agent connected */
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED</a> = 2 /* agent disconnected */
    <a name="VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST">VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBlockJobStatus">Enum </a>virConnectDomainEventBlockJobStatus</h3><pre class="programlisting">enum <a href="#virConnectDomainEventBlockJobStatus">virConnectDomainEventBlockJobStatus</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_COMPLETED">VIR_DOMAIN_BLOCK_JOB_COMPLETED</a> = 0
    <a name="VIR_DOMAIN_BLOCK_JOB_FAILED">VIR_DOMAIN_BLOCK_JOB_FAILED</a> = 1
    <a name="VIR_DOMAIN_BLOCK_JOB_CANCELED">VIR_DOMAIN_BLOCK_JOB_CANCELED</a> = 2
    <a name="VIR_DOMAIN_BLOCK_JOB_READY">VIR_DOMAIN_BLOCK_JOB_READY</a> = 3
    <a name="VIR_DOMAIN_BLOCK_JOB_LAST">VIR_DOMAIN_BLOCK_JOB_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDiskChangeReason">Enum </a>virConnectDomainEventDiskChangeReason</h3><pre class="programlisting">enum <a href="#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a> {
    <a name="VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START</a> = 0 /* Removable media changed to empty according to startup policy as source  was missing. oldSrcPath is set, newSrcPath is NULL */
    <a name="VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START">VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START</a> = 1 /* Disk was dropped from domain as source file was missing.  oldSrcPath is set, newSrcPath is NULL */
    <a name="VIR_DOMAIN_EVENT_DISK_CHANGE_LAST">VIR_DOMAIN_EVENT_DISK_CHANGE_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetAllDomainStatsFlags">Enum </a>virConnectGetAllDomainStatsFlags</h3><pre class="programlisting">enum <a href="#virConnectGetAllDomainStatsFlags">virConnectGetAllDomainStatsFlags</a> {
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE">VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE</a> = VIR_CONNECT_LIST_DOMAINS_ACTIVE
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE">VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE</a> = VIR_CONNECT_LIST_DOMAINS_INACTIVE
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER">VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER</a> = VIR_CONNECT_LIST_DOMAINS_OTHER
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED">VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED</a> = VIR_CONNECT_LIST_DOMAINS_PAUSED
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT">VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT</a> = VIR_CONNECT_LIST_DOMAINS_PERSISTENT
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING">VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING</a> = VIR_CONNECT_LIST_DOMAINS_RUNNING
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF">VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF</a> = VIR_CONNECT_LIST_DOMAINS_SHUTOFF
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT">VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT</a> = VIR_CONNECT_LIST_DOMAINS_TRANSIENT
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT">VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT</a> = 536870912 /* report statistics that can be obtained immediately without any blocking */
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING">VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING</a> = 1073741824 /* include backing chain for block stats */
    <a name="VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS">VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS</a> = 2147483648 /* enforce requested stats */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllDomainsFlags">Enum </a>virConnectListAllDomainsFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a> {
    <a name="VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a> = 1
    <a name="VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a> = 2
    <a name="VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a> = 4
    <a name="VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a> = 8
    <a name="VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a> = 16
    <a name="VIR_CONNECT_LIST_DOMAINS_PAUSED">VIR_CONNECT_LIST_DOMAINS_PAUSED</a> = 32
    <a name="VIR_CONNECT_LIST_DOMAINS_SHUTOFF">VIR_CONNECT_LIST_DOMAINS_SHUTOFF</a> = 64
    <a name="VIR_CONNECT_LIST_DOMAINS_OTHER">VIR_CONNECT_LIST_DOMAINS_OTHER</a> = 128
    <a name="VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a> = 256
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE</a> = 512
    <a name="VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a> = 1024
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART</a> = 2048
    <a name="VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT</a> = 4096
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT">VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT</a> = 8192
    <a name="VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT">VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT</a> = 16384
    <a name="VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT">VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT</a> = 32768
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomain">Structure </a>virDomain</h3><pre class="programlisting">struct _virDomain {
The content of this structure is not made public by the API.
} virDomain;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCommitFlags">Enum </a>virDomainBlockCommitFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_COMMIT_SHALLOW">VIR_DOMAIN_BLOCK_COMMIT_SHALLOW</a> = 1 /* NULL base means next backing file, not whole chain */
    <a name="VIR_DOMAIN_BLOCK_COMMIT_DELETE">VIR_DOMAIN_BLOCK_COMMIT_DELETE</a> = 2 /* Delete any files that are now invalid after their contents have been committed */
    <a name="VIR_DOMAIN_BLOCK_COMMIT_ACTIVE">VIR_DOMAIN_BLOCK_COMMIT_ACTIVE</a> = 4 /* Allow a two-phase commit when top is the active layer */
    <a name="VIR_DOMAIN_BLOCK_COMMIT_RELATIVE">VIR_DOMAIN_BLOCK_COMMIT_RELATIVE</a> = 8 /* keep the backing chain referenced using relative names */
    <a name="VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES">VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES</a> = 16 /* bandwidth in bytes/s instead of MiB/s */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCopyFlags">Enum </a>virDomainBlockCopyFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockCopyFlags">virDomainBlockCopyFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_COPY_SHALLOW">VIR_DOMAIN_BLOCK_COPY_SHALLOW</a> = 1 /* Limit copy to top of source backing chain */
    <a name="VIR_DOMAIN_BLOCK_COPY_REUSE_EXT">VIR_DOMAIN_BLOCK_COPY_REUSE_EXT</a> = 2 /* Reuse existing external file for a copy */
    <a name="VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB">VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB</a> = 4 /* Don't force usage of recoverable job for the copy operation */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockInfo">Structure </a>virDomainBlockInfo</h3><pre class="programlisting">struct _virDomainBlockInfo {
    unsigned long long	capacity	: logical size in bytes of the image (how much storage the guest will
    unsigned long long	allocation	: host storage in bytes occupied by the image (such as highest allocat
    unsigned long long	physical	: host physical size in bytes of the image container (last offset, sim
} virDomainBlockInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockInfoPtr">Typedef </a>virDomainBlockInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainBlockInfo">virDomainBlockInfo</a> * virDomainBlockInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobAbortFlags">Enum </a>virDomainBlockJobAbortFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> = 1
    <a name="VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobCursor">Typedef </a>virDomainBlockJobCursor</h3><pre class="programlisting">unsigned long long virDomainBlockJobCursor;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobInfo">Structure </a>virDomainBlockJobInfo</h3><pre class="programlisting">struct _virDomainBlockJobInfo {
    int	type	: <a href="libvirt-libvirt-domain.html#virDomainBlockJobType">virDomainBlockJobType</a>
    unsigned long	bandwidth	: The following fields provide an indication of block job progress. @cu
    <a href="libvirt-libvirt-domain.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a>	cur
    <a href="libvirt-libvirt-domain.html#virDomainBlockJobCursor">virDomainBlockJobCursor</a>	end
} virDomainBlockJobInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobInfoFlags">Enum </a>virDomainBlockJobInfoFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockJobInfoFlags">virDomainBlockJobInfoFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES">VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES</a> = 1 /* bandwidth in bytes/s instead of MiB/s */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobInfoPtr">Typedef </a>virDomainBlockJobInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> * virDomainBlockJobInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobSetSpeedFlags">Enum </a>virDomainBlockJobSetSpeedFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockJobSetSpeedFlags">virDomainBlockJobSetSpeedFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES">VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES</a> = 1 /* bandwidth in bytes/s instead of MiB/s */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobType">Enum </a>virDomainBlockJobType</h3><pre class="programlisting">enum <a href="#virDomainBlockJobType">virDomainBlockJobType</a> {
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN">VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN</a> = 0 /* Placeholder */
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_PULL">VIR_DOMAIN_BLOCK_JOB_TYPE_PULL</a> = 1 /* Block Pull (virDomainBlockPull, or virDomainBlockRebase without  flags), job ends on completion */
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COPY">VIR_DOMAIN_BLOCK_JOB_TYPE_COPY</a> = 2 /* Block Copy (virDomainBlockCopy, or virDomainBlockRebase with  flags), job exists as long as mirroring is active */
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT">VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT</a> = 3 /* Block Commit (virDomainBlockCommit without flags), job ends on  completion */
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT">VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT</a> = 4 /* Active Block Commit (virDomainBlockCommit with flags), job  exists as long as sync is active */
    <a name="VIR_DOMAIN_BLOCK_JOB_TYPE_LAST">VIR_DOMAIN_BLOCK_JOB_TYPE_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockPullFlags">Enum </a>virDomainBlockPullFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockPullFlags">virDomainBlockPullFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES">VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES</a> = 64 /* bandwidth in bytes/s instead of MiB/s */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockRebaseFlags">Enum </a>virDomainBlockRebaseFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_REBASE_SHALLOW">VIR_DOMAIN_BLOCK_REBASE_SHALLOW</a> = 1 /* Limit copy to top of source backing chain */
    <a name="VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a> = 2 /* Reuse existing external file for a copy */
    <a name="VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a> = 4 /* Make destination file raw */
    <a name="VIR_DOMAIN_BLOCK_REBASE_COPY">VIR_DOMAIN_BLOCK_REBASE_COPY</a> = 8 /* Start a copy job */
    <a name="VIR_DOMAIN_BLOCK_REBASE_RELATIVE">VIR_DOMAIN_BLOCK_REBASE_RELATIVE</a> = 16 /* Keep backing chain referenced using relative names */
    <a name="VIR_DOMAIN_BLOCK_REBASE_COPY_DEV">VIR_DOMAIN_BLOCK_REBASE_COPY_DEV</a> = 32 /* Treat destination as block device instead of file */
    <a name="VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES">VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES</a> = 64 /* bandwidth in bytes/s instead of MiB/s */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockResizeFlags">Enum </a>virDomainBlockResizeFlags</h3><pre class="programlisting">enum <a href="#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a> {
    <a name="VIR_DOMAIN_BLOCK_RESIZE_BYTES">VIR_DOMAIN_BLOCK_RESIZE_BYTES</a> = 1 /* size in bytes instead of KiB */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsPtr">Typedef </a>virDomainBlockStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainBlockStatsStruct">virDomainBlockStatsStruct</a> * virDomainBlockStatsPtr;
</pre><p>A pointer to a <a href="libvirt-libvirt-domain.html#virDomainBlockStats">virDomainBlockStats</a> structure</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsStruct">Structure </a>virDomainBlockStatsStruct</h3><pre class="programlisting">struct _virDomainBlockStats {
    long long	rd_req	: number of read requests
    long long	rd_bytes	: number of read bytes
    long long	wr_req	: number of write requests
    long long	wr_bytes	: number of written bytes
    long long	errs	: In Xen this returns the mysterious 'oo_req'.
} virDomainBlockStatsStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockedReason">Enum </a>virDomainBlockedReason</h3><pre class="programlisting">enum <a href="#virDomainBlockedReason">virDomainBlockedReason</a> {
    <a name="VIR_DOMAIN_BLOCKED_UNKNOWN">VIR_DOMAIN_BLOCKED_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_BLOCKED_LAST">VIR_DOMAIN_BLOCKED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainChannelFlags">Enum </a>virDomainChannelFlags</h3><pre class="programlisting">enum <a href="#virDomainChannelFlags">virDomainChannelFlags</a> {
    <a name="VIR_DOMAIN_CHANNEL_FORCE">VIR_DOMAIN_CHANNEL_FORCE</a> = 1 /* abort a (possibly) active channel connection to force a new connection */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainConsoleFlags">Enum </a>virDomainConsoleFlags</h3><pre class="programlisting">enum <a href="#virDomainConsoleFlags">virDomainConsoleFlags</a> {
    <a name="VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a> = 1 /* abort a (possibly) active console connection to force a new connection */
    <a name="VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a> = 2 /* check if the console driver supports safe console operations */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlErrorReason">Enum </a>virDomainControlErrorReason</h3><pre class="programlisting">enum <a href="#virDomainControlErrorReason">virDomainControlErrorReason</a> {
    <a name="VIR_DOMAIN_CONTROL_ERROR_REASON_NONE">VIR_DOMAIN_CONTROL_ERROR_REASON_NONE</a> = 0 /* server didn't provide a reason */
    <a name="VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN">VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN</a> = 1 /* unknown reason for the error */
    <a name="VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR">VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR</a> = 2 /* monitor connection is broken */
    <a name="VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL">VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL</a> = 3 /* error caused due to internal failure in libvirt */
    <a name="VIR_DOMAIN_CONTROL_ERROR_REASON_LAST">VIR_DOMAIN_CONTROL_ERROR_REASON_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlInfo">Structure </a>virDomainControlInfo</h3><pre class="programlisting">struct _virDomainControlInfo {
    unsigned int	state	: control state, one of <a href="libvirt-libvirt-domain.html#virDomainControlState">virDomainControlState</a>
    unsigned int	details	: state details, currently 0 except for ERROR state (one of virDomainCon
    unsigned long long	stateTime	: for how long (in msec) control interface has been in current state (ex
} virDomainControlInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlInfoPtr">Typedef </a>virDomainControlInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainControlInfo">virDomainControlInfo</a> * virDomainControlInfoPtr;
</pre><p>Pointer to <a href="libvirt-libvirt-domain.html#virDomainControlInfo">virDomainControlInfo</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainControlState">Enum </a>virDomainControlState</h3><pre class="programlisting">enum <a href="#virDomainControlState">virDomainControlState</a> {
    <a name="VIR_DOMAIN_CONTROL_OK">VIR_DOMAIN_CONTROL_OK</a> = 0 /* operational, ready to accept commands */
    <a name="VIR_DOMAIN_CONTROL_JOB">VIR_DOMAIN_CONTROL_JOB</a> = 1 /* background job is running (can be monitored by virDomainGetJobInfo); only limited set of commands may be allowed */
    <a name="VIR_DOMAIN_CONTROL_OCCUPIED">VIR_DOMAIN_CONTROL_OCCUPIED</a> = 2 /* occupied by a running command */
    <a name="VIR_DOMAIN_CONTROL_ERROR">VIR_DOMAIN_CONTROL_ERROR</a> = 3 /* unusable, domain cannot be fully operated, possible reason is provided in the details field */
    <a name="VIR_DOMAIN_CONTROL_LAST">VIR_DOMAIN_CONTROL_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDumpFlags">Enum </a>virDomainCoreDumpFlags</h3><pre class="programlisting">enum <a href="#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a> {
    <a name="VIR_DUMP_CRASH">VIR_DUMP_CRASH</a> = 1 /* crash after dump */
    <a name="VIR_DUMP_LIVE">VIR_DUMP_LIVE</a> = 2 /* live dump */
    <a name="VIR_DUMP_BYPASS_CACHE">VIR_DUMP_BYPASS_CACHE</a> = 4 /* avoid file system cache pollution */
    <a name="VIR_DUMP_RESET">VIR_DUMP_RESET</a> = 8 /* reset domain after dump finishes */
    <a name="VIR_DUMP_MEMORY_ONLY">VIR_DUMP_MEMORY_ONLY</a> = 16 /* use dump-guest-memory */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDumpFormat">Enum </a>virDomainCoreDumpFormat</h3><pre class="programlisting">enum <a href="#virDomainCoreDumpFormat">virDomainCoreDumpFormat</a> {
    <a name="VIR_DOMAIN_CORE_DUMP_FORMAT_RAW">VIR_DOMAIN_CORE_DUMP_FORMAT_RAW</a> = 0 /* dump guest memory in raw format */
    <a name="VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB">VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB</a> = 1 /* kdump-compressed format, with  zlib compression */
    <a name="VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO">VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO</a> = 2 /* kdump-compressed format, with  lzo compression */
    <a name="VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY">VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY</a> = 3 /* kdump-compressed format, with  snappy compression */
    <a name="VIR_DOMAIN_CORE_DUMP_FORMAT_LAST">VIR_DOMAIN_CORE_DUMP_FORMAT_LAST</a> = 4 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last state supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCrashedReason">Enum </a>virDomainCrashedReason</h3><pre class="programlisting">enum <a href="#virDomainCrashedReason">virDomainCrashedReason</a> {
    <a name="VIR_DOMAIN_CRASHED_UNKNOWN">VIR_DOMAIN_CRASHED_UNKNOWN</a> = 0 /* crashed for unknown reason */
    <a name="VIR_DOMAIN_CRASHED_PANICKED">VIR_DOMAIN_CRASHED_PANICKED</a> = 1 /* domain panicked */
    <a name="VIR_DOMAIN_CRASHED_LAST">VIR_DOMAIN_CRASHED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateFlags">Enum </a>virDomainCreateFlags</h3><pre class="programlisting">enum <a href="#virDomainCreateFlags">virDomainCreateFlags</a> {
    <a name="VIR_DOMAIN_NONE">VIR_DOMAIN_NONE</a> = 0 /* Default behavior */
    <a name="VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> = 1 /* Launch guest in paused state */
    <a name="VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> = 2 /* Automatically kill guest when virConnectPtr is closed */
    <a name="VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> = 4 /* Avoid file system cache pollution */
    <a name="VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> = 8 /* Boot, discarding any managed save */
    <a name="VIR_DOMAIN_START_VALIDATE">VIR_DOMAIN_START_VALIDATE</a> = 16 /* Validate the XML document against schema */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDefineFlags">Enum </a>virDomainDefineFlags</h3><pre class="programlisting">enum <a href="#virDomainDefineFlags">virDomainDefineFlags</a> {
    <a name="VIR_DOMAIN_DEFINE_VALIDATE">VIR_DOMAIN_DEFINE_VALIDATE</a> = 1 /* Validate the XML document against schema */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroyFlagsValues">Enum </a>virDomainDestroyFlagsValues</h3><pre class="programlisting">enum <a href="#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a> {
    <a name="VIR_DOMAIN_DESTROY_DEFAULT">VIR_DOMAIN_DESTROY_DEFAULT</a> = 0 /* Default behavior - could lead to data loss!! */
    <a name="VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> = 1 /* only SIGTERM, no SIGKILL */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDeviceModifyFlags">Enum </a>virDomainDeviceModifyFlags</h3><pre class="programlisting">enum <a href="#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a> {
    <a name="VIR_DOMAIN_DEVICE_MODIFY_CONFIG">VIR_DOMAIN_DEVICE_MODIFY_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG
    <a name="VIR_DOMAIN_DEVICE_MODIFY_CURRENT">VIR_DOMAIN_DEVICE_MODIFY_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT /* See virDomainModificationImpact for these flags. */
    <a name="VIR_DOMAIN_DEVICE_MODIFY_LIVE">VIR_DOMAIN_DEVICE_MODIFY_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_DEVICE_MODIFY_FORCE">VIR_DOMAIN_DEVICE_MODIFY_FORCE</a> = 4 /* Additionally, these flags may be bitwise-OR'd in. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskError">Structure </a>virDomainDiskError</h3><pre class="programlisting">struct _virDomainDiskError {
    char *	disk	: disk target
    int	error	: <a href="libvirt-libvirt-domain.html#virDomainDiskErrorCode">virDomainDiskErrorCode</a>
} virDomainDiskError;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskErrorCode">Enum </a>virDomainDiskErrorCode</h3><pre class="programlisting">enum <a href="#virDomainDiskErrorCode">virDomainDiskErrorCode</a> {
    <a name="VIR_DOMAIN_DISK_ERROR_NONE">VIR_DOMAIN_DISK_ERROR_NONE</a> = 0 /* no error */
    <a name="VIR_DOMAIN_DISK_ERROR_UNSPEC">VIR_DOMAIN_DISK_ERROR_UNSPEC</a> = 1 /* unspecified I/O error */
    <a name="VIR_DOMAIN_DISK_ERROR_NO_SPACE">VIR_DOMAIN_DISK_ERROR_NO_SPACE</a> = 2 /* no space left on the device */
    <a name="VIR_DOMAIN_DISK_ERROR_LAST">VIR_DOMAIN_DISK_ERROR_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDiskErrorPtr">Typedef </a>virDomainDiskErrorPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainDiskError">virDomainDiskError</a> * virDomainDiskErrorPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventCrashedDetailType">Enum </a>virDomainEventCrashedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventCrashedDetailType">virDomainEventCrashedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_CRASHED_PANICKED">VIR_DOMAIN_EVENT_CRASHED_PANICKED</a> = 0 /* Guest was panicked */
    <a name="VIR_DOMAIN_EVENT_CRASHED_LAST">VIR_DOMAIN_EVENT_CRASHED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventDefinedDetailType">Enum </a>virDomainEventDefinedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventDefinedDetailType">virDomainEventDefinedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_DEFINED_ADDED">VIR_DOMAIN_EVENT_DEFINED_ADDED</a> = 0 /* Newly created config file */
    <a name="VIR_DOMAIN_EVENT_DEFINED_UPDATED">VIR_DOMAIN_EVENT_DEFINED_UPDATED</a> = 1 /* Changed config file */
    <a name="VIR_DOMAIN_EVENT_DEFINED_RENAMED">VIR_DOMAIN_EVENT_DEFINED_RENAMED</a> = 2 /* Domain was renamed */
    <a name="VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT</a> = 3 /* Config was restored from a snapshot */
    <a name="VIR_DOMAIN_EVENT_DEFINED_LAST">VIR_DOMAIN_EVENT_DEFINED_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddress">Structure </a>virDomainEventGraphicsAddress</h3><pre class="programlisting">struct _virDomainEventGraphicsAddress {
    int	family	: Address family, <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a>
    char *	node	: Address of node (eg IP address, or UNIX path)
    char *	service	: Service name/number (eg TCP port, or NULL)
} virDomainEventGraphicsAddress;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddressPtr">Typedef </a>virDomainEventGraphicsAddressPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * virDomainEventGraphicsAddressPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsAddressType">Enum </a>virDomainEventGraphicsAddressType</h3><pre class="programlisting">enum <a href="#virDomainEventGraphicsAddressType">virDomainEventGraphicsAddressType</a> {
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4</a> = 0 /* IPv4 address */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6</a> = 1 /* IPv6 address */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX</a> = 2 /* UNIX socket path */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsPhase">Enum </a>virDomainEventGraphicsPhase</h3><pre class="programlisting">enum <a href="#virDomainEventGraphicsPhase">virDomainEventGraphicsPhase</a> {
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_CONNECT">VIR_DOMAIN_EVENT_GRAPHICS_CONNECT</a> = 0 /* Initial socket connection established */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE">VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE</a> = 1 /* Authentication &amp; setup completed */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT">VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT</a> = 2 /* Final socket disconnection */
    <a name="VIR_DOMAIN_EVENT_GRAPHICS_LAST">VIR_DOMAIN_EVENT_GRAPHICS_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubject">Structure </a>virDomainEventGraphicsSubject</h3><pre class="programlisting">struct _virDomainEventGraphicsSubject {
    int	nidentity	: Number of identities in arra
    <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubjectIdentityPtr">virDomainEventGraphicsSubjectIdentityPtr</a>	identities	: Array of identities for subject
} virDomainEventGraphicsSubject;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectIdentity">Structure </a>virDomainEventGraphicsSubjectIdentity</h3><pre class="programlisting">struct _virDomainEventGraphicsSubjectIdentity {
    char *	type	: Type of identity
    char *	name	: Identity value
} virDomainEventGraphicsSubjectIdentity;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectIdentityPtr">Typedef </a>virDomainEventGraphicsSubjectIdentityPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubjectIdentity">virDomainEventGraphicsSubjectIdentity</a> * virDomainEventGraphicsSubjectIdentityPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventGraphicsSubjectPtr">Typedef </a>virDomainEventGraphicsSubjectPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * virDomainEventGraphicsSubjectPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventID">Enum </a>virDomainEventID</h3><pre class="programlisting">enum <a href="#virDomainEventID">virDomainEventID</a> {
    <a name="VIR_DOMAIN_EVENT_ID_LIFECYCLE">VIR_DOMAIN_EVENT_ID_LIFECYCLE</a> = 0 /* virConnectDomainEventCallback */
    <a name="VIR_DOMAIN_EVENT_ID_REBOOT">VIR_DOMAIN_EVENT_ID_REBOOT</a> = 1 /* virConnectDomainEventGenericCallback */
    <a name="VIR_DOMAIN_EVENT_ID_RTC_CHANGE">VIR_DOMAIN_EVENT_ID_RTC_CHANGE</a> = 2 /* virConnectDomainEventRTCChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_WATCHDOG">VIR_DOMAIN_EVENT_ID_WATCHDOG</a> = 3 /* virConnectDomainEventWatchdogCallback */
    <a name="VIR_DOMAIN_EVENT_ID_IO_ERROR">VIR_DOMAIN_EVENT_ID_IO_ERROR</a> = 4 /* virConnectDomainEventIOErrorCallback */
    <a name="VIR_DOMAIN_EVENT_ID_GRAPHICS">VIR_DOMAIN_EVENT_ID_GRAPHICS</a> = 5 /* virConnectDomainEventGraphicsCallback */
    <a name="VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON">VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON</a> = 6 /* virConnectDomainEventIOErrorReasonCallback */
    <a name="VIR_DOMAIN_EVENT_ID_CONTROL_ERROR">VIR_DOMAIN_EVENT_ID_CONTROL_ERROR</a> = 7 /* virConnectDomainEventGenericCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BLOCK_JOB">VIR_DOMAIN_EVENT_ID_BLOCK_JOB</a> = 8 /* virConnectDomainEventBlockJobCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DISK_CHANGE">VIR_DOMAIN_EVENT_ID_DISK_CHANGE</a> = 9 /* virConnectDomainEventDiskChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_TRAY_CHANGE">VIR_DOMAIN_EVENT_ID_TRAY_CHANGE</a> = 10 /* virConnectDomainEventTrayChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMWAKEUP">VIR_DOMAIN_EVENT_ID_PMWAKEUP</a> = 11 /* virConnectDomainEventPMWakeupCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND">VIR_DOMAIN_EVENT_ID_PMSUSPEND</a> = 12 /* virConnectDomainEventPMSuspendCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE">VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE</a> = 13 /* virConnectDomainEventBalloonChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK">VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK</a> = 14 /* virConnectDomainEventPMSuspendDiskCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a> = 15 /* virConnectDomainEventDeviceRemovedCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2">VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2</a> = 16 /* virConnectDomainEventBlockJobCallback */
    <a name="VIR_DOMAIN_EVENT_ID_TUNABLE">VIR_DOMAIN_EVENT_ID_TUNABLE</a> = 17 /* virConnectDomainEventTunableCallback */
    <a name="VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE">VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE</a> = 18 /* virConnectDomainEventAgentLifecycleCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DEVICE_ADDED">VIR_DOMAIN_EVENT_ID_DEVICE_ADDED</a> = 19 /* virConnectDomainEventDeviceAddedCallback */
    <a name="VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION">VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION</a> = 20 /* virConnectDomainEventMigrationIterationCallback */
    <a name="VIR_DOMAIN_EVENT_ID_JOB_COMPLETED">VIR_DOMAIN_EVENT_ID_JOB_COMPLETED</a> = 21 /* virConnectDomainEventJobCompletedCallback */
    <a name="VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED</a> = 22 /* virConnectDomainEventDeviceRemovalFailedCallback */
    <a name="VIR_DOMAIN_EVENT_ID_METADATA_CHANGE">VIR_DOMAIN_EVENT_ID_METADATA_CHANGE</a> = 23 /* virConnectDomainEventMetadataChangeCallback */
    <a name="VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD">VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD</a> = 24 /* virConnectDomainEventBlockThresholdCallback */
    <a name="VIR_DOMAIN_EVENT_ID_LAST">VIR_DOMAIN_EVENT_ID_LAST</a> = 25 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last event ID supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventIOErrorAction">Enum </a>virDomainEventIOErrorAction</h3><pre class="programlisting">enum <a href="#virDomainEventIOErrorAction">virDomainEventIOErrorAction</a> {
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_NONE">VIR_DOMAIN_EVENT_IO_ERROR_NONE</a> = 0 /* No action, IO error ignored */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_PAUSE">VIR_DOMAIN_EVENT_IO_ERROR_PAUSE</a> = 1 /* Guest CPUs are paused */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_REPORT">VIR_DOMAIN_EVENT_IO_ERROR_REPORT</a> = 2 /* IO error reported to guest OS */
    <a name="VIR_DOMAIN_EVENT_IO_ERROR_LAST">VIR_DOMAIN_EVENT_IO_ERROR_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventPMSuspendedDetailType">Enum </a>virDomainEventPMSuspendedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventPMSuspendedDetailType">virDomainEventPMSuspendedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY">VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY</a> = 0 /* Guest was PM suspended to memory */
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_DISK">VIR_DOMAIN_EVENT_PMSUSPENDED_DISK</a> = 1 /* Guest was PM suspended to disk */
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED_LAST">VIR_DOMAIN_EVENT_PMSUSPENDED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventResumedDetailType">Enum </a>virDomainEventResumedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventResumedDetailType">virDomainEventResumedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_RESUMED_UNPAUSED">VIR_DOMAIN_EVENT_RESUMED_UNPAUSED</a> = 0 /* Normal resume due to admin unpause */
    <a name="VIR_DOMAIN_EVENT_RESUMED_MIGRATED">VIR_DOMAIN_EVENT_RESUMED_MIGRATED</a> = 1 /* Resumed for completion of migration */
    <a name="VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT</a> = 2 /* Resumed from snapshot */
    <a name="VIR_DOMAIN_EVENT_RESUMED_POSTCOPY">VIR_DOMAIN_EVENT_RESUMED_POSTCOPY</a> = 3 /* Resumed, but migration is still running in post-copy mode */
    <a name="VIR_DOMAIN_EVENT_RESUMED_LAST">VIR_DOMAIN_EVENT_RESUMED_LAST</a> = 4
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventShutdownDetailType">Enum </a>virDomainEventShutdownDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventShutdownDetailType">virDomainEventShutdownDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED">VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED</a> = 0 /* Guest finished shutdown sequence */
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_GUEST">VIR_DOMAIN_EVENT_SHUTDOWN_GUEST</a> = 1 /* Domain finished shutting down after request from the guest itself  (e.g. hardware-specific action) */
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_HOST">VIR_DOMAIN_EVENT_SHUTDOWN_HOST</a> = 2 /* Domain finished shutting down after request from the host (e.g. killed by  a signal) */
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN_LAST">VIR_DOMAIN_EVENT_SHUTDOWN_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventStartedDetailType">Enum </a>virDomainEventStartedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventStartedDetailType">virDomainEventStartedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_STARTED_BOOTED">VIR_DOMAIN_EVENT_STARTED_BOOTED</a> = 0 /* Normal startup from boot */
    <a name="VIR_DOMAIN_EVENT_STARTED_MIGRATED">VIR_DOMAIN_EVENT_STARTED_MIGRATED</a> = 1 /* Incoming migration from another host */
    <a name="VIR_DOMAIN_EVENT_STARTED_RESTORED">VIR_DOMAIN_EVENT_STARTED_RESTORED</a> = 2 /* Restored from a state file */
    <a name="VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT</a> = 3 /* Restored from snapshot */
    <a name="VIR_DOMAIN_EVENT_STARTED_WAKEUP">VIR_DOMAIN_EVENT_STARTED_WAKEUP</a> = 4 /* Started due to wakeup event */
    <a name="VIR_DOMAIN_EVENT_STARTED_LAST">VIR_DOMAIN_EVENT_STARTED_LAST</a> = 5
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventStoppedDetailType">Enum </a>virDomainEventStoppedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventStoppedDetailType">virDomainEventStoppedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN">VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN</a> = 0 /* Normal shutdown */
    <a name="VIR_DOMAIN_EVENT_STOPPED_DESTROYED">VIR_DOMAIN_EVENT_STOPPED_DESTROYED</a> = 1 /* Forced poweroff from host */
    <a name="VIR_DOMAIN_EVENT_STOPPED_CRASHED">VIR_DOMAIN_EVENT_STOPPED_CRASHED</a> = 2 /* Guest crashed */
    <a name="VIR_DOMAIN_EVENT_STOPPED_MIGRATED">VIR_DOMAIN_EVENT_STOPPED_MIGRATED</a> = 3 /* Migrated off to another host */
    <a name="VIR_DOMAIN_EVENT_STOPPED_SAVED">VIR_DOMAIN_EVENT_STOPPED_SAVED</a> = 4 /* Saved to a state file */
    <a name="VIR_DOMAIN_EVENT_STOPPED_FAILED">VIR_DOMAIN_EVENT_STOPPED_FAILED</a> = 5 /* Host emulator/mgmt failed */
    <a name="VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT</a> = 6 /* offline snapshot loaded */
    <a name="VIR_DOMAIN_EVENT_STOPPED_LAST">VIR_DOMAIN_EVENT_STOPPED_LAST</a> = 7
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventSuspendedDetailType">Enum </a>virDomainEventSuspendedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventSuspendedDetailType">virDomainEventSuspendedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_PAUSED">VIR_DOMAIN_EVENT_SUSPENDED_PAUSED</a> = 0 /* Normal suspend due to admin pause */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED">VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED</a> = 1 /* Suspended for offline migration */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_IOERROR">VIR_DOMAIN_EVENT_SUSPENDED_IOERROR</a> = 2 /* Suspended due to a disk I/O error */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG">VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG</a> = 3 /* Suspended due to a watchdog firing */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_RESTORED">VIR_DOMAIN_EVENT_SUSPENDED_RESTORED</a> = 4 /* Restored from paused state file */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT">VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT</a> = 5 /* Restored from paused snapshot */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR">VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR</a> = 6 /* suspended after failure during libvirt API call */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY">VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY</a> = 7 /* suspended for post-copy migration */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED">VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED</a> = 8 /* suspended after failed post-copy */
    <a name="VIR_DOMAIN_EVENT_SUSPENDED_LAST">VIR_DOMAIN_EVENT_SUSPENDED_LAST</a> = 9
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventTrayChangeReason">Enum </a>virDomainEventTrayChangeReason</h3><pre class="programlisting">enum <a href="#virDomainEventTrayChangeReason">virDomainEventTrayChangeReason</a> {
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN">VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN</a> = 0
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE">VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE</a> = 1
    <a name="VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST">VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventType">Enum </a>virDomainEventType</h3><pre class="programlisting">enum <a href="#virDomainEventType">virDomainEventType</a> {
    <a name="VIR_DOMAIN_EVENT_DEFINED">VIR_DOMAIN_EVENT_DEFINED</a> = 0
    <a name="VIR_DOMAIN_EVENT_UNDEFINED">VIR_DOMAIN_EVENT_UNDEFINED</a> = 1
    <a name="VIR_DOMAIN_EVENT_STARTED">VIR_DOMAIN_EVENT_STARTED</a> = 2
    <a name="VIR_DOMAIN_EVENT_SUSPENDED">VIR_DOMAIN_EVENT_SUSPENDED</a> = 3
    <a name="VIR_DOMAIN_EVENT_RESUMED">VIR_DOMAIN_EVENT_RESUMED</a> = 4
    <a name="VIR_DOMAIN_EVENT_STOPPED">VIR_DOMAIN_EVENT_STOPPED</a> = 5
    <a name="VIR_DOMAIN_EVENT_SHUTDOWN">VIR_DOMAIN_EVENT_SHUTDOWN</a> = 6
    <a name="VIR_DOMAIN_EVENT_PMSUSPENDED">VIR_DOMAIN_EVENT_PMSUSPENDED</a> = 7
    <a name="VIR_DOMAIN_EVENT_CRASHED">VIR_DOMAIN_EVENT_CRASHED</a> = 8
    <a name="VIR_DOMAIN_EVENT_LAST">VIR_DOMAIN_EVENT_LAST</a> = 9
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventUndefinedDetailType">Enum </a>virDomainEventUndefinedDetailType</h3><pre class="programlisting">enum <a href="#virDomainEventUndefinedDetailType">virDomainEventUndefinedDetailType</a> {
    <a name="VIR_DOMAIN_EVENT_UNDEFINED_REMOVED">VIR_DOMAIN_EVENT_UNDEFINED_REMOVED</a> = 0 /* Deleted the config file */
    <a name="VIR_DOMAIN_EVENT_UNDEFINED_RENAMED">VIR_DOMAIN_EVENT_UNDEFINED_RENAMED</a> = 1 /* Domain was renamed */
    <a name="VIR_DOMAIN_EVENT_UNDEFINED_LAST">VIR_DOMAIN_EVENT_UNDEFINED_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainEventWatchdogAction">Enum </a>virDomainEventWatchdogAction</h3><pre class="programlisting">enum <a href="#virDomainEventWatchdogAction">virDomainEventWatchdogAction</a> {
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_NONE">VIR_DOMAIN_EVENT_WATCHDOG_NONE</a> = 0 /* No action, watchdog ignored */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_PAUSE">VIR_DOMAIN_EVENT_WATCHDOG_PAUSE</a> = 1 /* Guest CPUs are paused */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_RESET">VIR_DOMAIN_EVENT_WATCHDOG_RESET</a> = 2 /* Guest CPUs are reset */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF">VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF</a> = 3 /* Guest is forcibly powered off */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN">VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN</a> = 4 /* Guest is requested to gracefully shutdown */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_DEBUG">VIR_DOMAIN_EVENT_WATCHDOG_DEBUG</a> = 5 /* No action, a debug message logged */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI">VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI</a> = 6 /* Inject a non-maskable interrupt into guest */
    <a name="VIR_DOMAIN_EVENT_WATCHDOG_LAST">VIR_DOMAIN_EVENT_WATCHDOG_LAST</a> = 7
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSInfo">Structure </a>virDomainFSInfo</h3><pre class="programlisting">struct _virDomainFSInfo {
    char *	mountpoint	: path to mount point
    char *	name	: device name in the guest (e.g. "sda1")
    char *	fstype	: filesystem type
    size_t	ndevAlias	: number of elements in devAlias
    char **	devAlias	: array of disk device aliases
} virDomainFSInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSInfoPtr">Typedef </a>virDomainFSInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainFSInfo">virDomainFSInfo</a> * virDomainFSInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetJobStatsFlags">Enum </a>virDomainGetJobStatsFlags</h3><pre class="programlisting">enum <a href="#virDomainGetJobStatsFlags">virDomainGetJobStatsFlags</a> {
    <a name="VIR_DOMAIN_JOB_STATS_COMPLETED">VIR_DOMAIN_JOB_STATS_COMPLETED</a> = 1 /* return stats of a recently  completed job */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIOThreadInfo">Structure </a>virDomainIOThreadInfo</h3><pre class="programlisting">struct _virDomainIOThreadInfo {
    unsigned int	iothread_id	: IOThread ID
    unsigned char *	cpumap	: CPU map for thread. A pointer to an array of real CPUs (in 8-bit bytes
    int	cpumaplen	: cpumap size
} virDomainIOThreadInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIOThreadInfoPtr">Typedef </a>virDomainIOThreadInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainIOThreadInfo">virDomainIOThreadInfo</a> * virDomainIOThreadInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIPAddress">Structure </a>virDomainIPAddress</h3><pre class="programlisting">struct _virDomainInterfaceIPAddress {
    int	type	: <a href="libvirt-libvirt-network.html#virIPAddrType">virIPAddrType</a>
    char *	addr	: IP address
    unsigned int	prefix	: IP address prefix
} virDomainIPAddress;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIPAddressPtr">Typedef </a>virDomainIPAddressPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainIPAddress">virDomainIPAddress</a> * virDomainIPAddressPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInfo">Structure </a>virDomainInfo</h3><pre class="programlisting">struct _virDomainInfo {
    unsigned char	state	: the running state, one of <a href="libvirt-libvirt-domain.html#virDomainState">virDomainState</a>
    unsigned long	maxMem	: the maximum memory in KBytes allowed
    unsigned long	memory	: the memory in KBytes used by the domain
    unsigned short	nrVirtCpu	: the number of virtual CPUs for the domain
    unsigned long long	cpuTime	: the CPU time used in nanoseconds
} virDomainInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInfoPtr">Typedef </a>virDomainInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainInfo">virDomainInfo</a> * virDomainInfoPtr;
</pre><p>a <a href="libvirt-libvirt-domain.html#virDomainInfoPtr">virDomainInfoPtr</a> is a pointer to a <a href="libvirt-libvirt-domain.html#virDomainInfo">virDomainInfo</a> structure.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterface">Structure </a>virDomainInterface</h3><pre class="programlisting">struct _virDomainInterface {
    char *	name	: interface name
    char *	hwaddr	: hardware address, may be NULL
    unsigned int	naddrs	: number of items in @addrs
    <a href="libvirt-libvirt-domain.html#virDomainIPAddressPtr">virDomainIPAddressPtr</a>	addrs	: array of IP addresses
} virDomainInterface;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceAddressesSource">Enum </a>virDomainInterfaceAddressesSource</h3><pre class="programlisting">enum <a href="#virDomainInterfaceAddressesSource">virDomainInterfaceAddressesSource</a> {
    <a name="VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE">VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE</a> = 0 /* Parse DHCP lease file */
    <a name="VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT">VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT</a> = 1 /* Query qemu guest agent */
    <a name="VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP">VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP</a> = 2 /* Query ARP tables */
    <a name="VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST">VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfacePtr">Typedef </a>virDomainInterfacePtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainInterface">virDomainInterface</a> * virDomainInterfacePtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStatsPtr">Typedef </a>virDomainInterfaceStatsPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainInterfaceStatsStruct">virDomainInterfaceStatsStruct</a> * virDomainInterfaceStatsPtr;
</pre><p>A pointer to a <a href="libvirt-libvirt-domain.html#virDomainInterfaceStats">virDomainInterfaceStats</a> structure</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStatsStruct">Structure </a>virDomainInterfaceStatsStruct</h3><pre class="programlisting">struct _virDomainInterfaceStats {
    long long	rx_bytes
    long long	rx_packets
    long long	rx_errs
    long long	rx_drop
    long long	tx_bytes
    long long	tx_packets
    long long	tx_errs
    long long	tx_drop
} virDomainInterfaceStatsStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobInfo">Structure </a>virDomainJobInfo</h3><pre class="programlisting">struct _virDomainJobInfo {
    int	type	: Time is measured in milliseconds
    unsigned long long	timeElapsed	: Always set
    unsigned long long	timeRemaining	: Only for <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> Data is measured in bytes unless other
    unsigned long long	dataTotal
    unsigned long long	dataProcessed
    unsigned long long	dataRemaining	: As above, but only tracking guest memory progress
    unsigned long long	memTotal
    unsigned long long	memProcessed
    unsigned long long	memRemaining	: As above, but only tracking guest disk file progress
    unsigned long long	fileTotal
    unsigned long long	fileProcessed
    unsigned long long	fileRemaining
} virDomainJobInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobInfoPtr">Typedef </a>virDomainJobInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainJobInfo">virDomainJobInfo</a> * virDomainJobInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobOperation">Enum </a>virDomainJobOperation</h3><pre class="programlisting">enum <a href="#virDomainJobOperation">virDomainJobOperation</a> {
    <a name="VIR_DOMAIN_JOB_OPERATION_UNKNOWN">VIR_DOMAIN_JOB_OPERATION_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_JOB_OPERATION_START">VIR_DOMAIN_JOB_OPERATION_START</a> = 1
    <a name="VIR_DOMAIN_JOB_OPERATION_SAVE">VIR_DOMAIN_JOB_OPERATION_SAVE</a> = 2
    <a name="VIR_DOMAIN_JOB_OPERATION_RESTORE">VIR_DOMAIN_JOB_OPERATION_RESTORE</a> = 3
    <a name="VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN">VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN</a> = 4
    <a name="VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT">VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT</a> = 5
    <a name="VIR_DOMAIN_JOB_OPERATION_SNAPSHOT">VIR_DOMAIN_JOB_OPERATION_SNAPSHOT</a> = 6
    <a name="VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT">VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT</a> = 7
    <a name="VIR_DOMAIN_JOB_OPERATION_DUMP">VIR_DOMAIN_JOB_OPERATION_DUMP</a> = 8
    <a name="VIR_DOMAIN_JOB_OPERATION_LAST">VIR_DOMAIN_JOB_OPERATION_LAST</a> = 9
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainJobType">Enum </a>virDomainJobType</h3><pre class="programlisting">enum <a href="#virDomainJobType">virDomainJobType</a> {
    <a name="VIR_DOMAIN_JOB_NONE">VIR_DOMAIN_JOB_NONE</a> = 0 /* No job is active */
    <a name="VIR_DOMAIN_JOB_BOUNDED">VIR_DOMAIN_JOB_BOUNDED</a> = 1 /* Job with a finite completion time */
    <a name="VIR_DOMAIN_JOB_UNBOUNDED">VIR_DOMAIN_JOB_UNBOUNDED</a> = 2 /* Job without a finite completion time */
    <a name="VIR_DOMAIN_JOB_COMPLETED">VIR_DOMAIN_JOB_COMPLETED</a> = 3 /* Job has finished, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_FAILED">VIR_DOMAIN_JOB_FAILED</a> = 4 /* Job hit error, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_CANCELLED">VIR_DOMAIN_JOB_CANCELLED</a> = 5 /* Job was aborted, but isn't cleaned up */
    <a name="VIR_DOMAIN_JOB_LAST">VIR_DOMAIN_JOB_LAST</a> = 6
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLifecycle">Enum </a>virDomainLifecycle</h3><pre class="programlisting">enum <a href="#virDomainLifecycle">virDomainLifecycle</a> {
    <a name="VIR_DOMAIN_LIFECYCLE_POWEROFF">VIR_DOMAIN_LIFECYCLE_POWEROFF</a> = 0
    <a name="VIR_DOMAIN_LIFECYCLE_REBOOT">VIR_DOMAIN_LIFECYCLE_REBOOT</a> = 1
    <a name="VIR_DOMAIN_LIFECYCLE_CRASH">VIR_DOMAIN_LIFECYCLE_CRASH</a> = 2
    <a name="VIR_DOMAIN_LIFECYCLE_LAST">VIR_DOMAIN_LIFECYCLE_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLifecycleAction">Enum </a>virDomainLifecycleAction</h3><pre class="programlisting">enum <a href="#virDomainLifecycleAction">virDomainLifecycleAction</a> {
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY">VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY</a> = 0
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_RESTART">VIR_DOMAIN_LIFECYCLE_ACTION_RESTART</a> = 1
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME">VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME</a> = 2
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE">VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE</a> = 3
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY">VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY</a> = 4
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART">VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART</a> = 5
    <a name="VIR_DOMAIN_LIFECYCLE_ACTION_LAST">VIR_DOMAIN_LIFECYCLE_ACTION_LAST</a> = 6
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryFlags">Enum </a>virDomainMemoryFlags</h3><pre class="programlisting">enum <a href="#virDomainMemoryFlags">virDomainMemoryFlags</a> {
    <a name="VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> = 1 /* addresses are virtual addresses */
    <a name="VIR_MEMORY_PHYSICAL">VIR_MEMORY_PHYSICAL</a> = 2 /* addresses are physical addresses */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryModFlags">Enum </a>virDomainMemoryModFlags</h3><pre class="programlisting">enum <a href="#virDomainMemoryModFlags">virDomainMemoryModFlags</a> {
    <a name="VIR_DOMAIN_MEM_CONFIG">VIR_DOMAIN_MEM_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG
    <a name="VIR_DOMAIN_MEM_CURRENT">VIR_DOMAIN_MEM_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT /* See virDomainModificationImpact for these flags. */
    <a name="VIR_DOMAIN_MEM_LIVE">VIR_DOMAIN_MEM_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a> = 4 /* Additionally, these flags may be bitwise-OR'd in. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatPtr">Typedef </a>virDomainMemoryStatPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainMemoryStatStruct">virDomainMemoryStatStruct</a> * virDomainMemoryStatPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatStruct">Structure </a>virDomainMemoryStatStruct</h3><pre class="programlisting">struct _virDomainMemoryStat {
    int	tag
    unsigned long long	val
} virDomainMemoryStatStruct;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStatTags">Enum </a>virDomainMemoryStatTags</h3><pre class="programlisting">enum <a href="#virDomainMemoryStatTags">virDomainMemoryStatTags</a> {
    <a name="VIR_DOMAIN_MEMORY_STAT_LAST">VIR_DOMAIN_MEMORY_STAT_LAST</a> = VIR_DOMAIN_MEMORY_STAT_NR
    <a name="VIR_DOMAIN_MEMORY_STAT_SWAP_IN">VIR_DOMAIN_MEMORY_STAT_SWAP_IN</a> = 0 /* The total amount of data read from swap space (in kB). */
    <a name="VIR_DOMAIN_MEMORY_STAT_SWAP_OUT">VIR_DOMAIN_MEMORY_STAT_SWAP_OUT</a> = 1 /* The total amount of memory written out to swap space (in kB). */
    <a name="VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT</a> = 2 /* Page faults occur when a process makes a valid access to virtual memory  that is not available.  When servicing the page fault, if disk IO is  required, it is considered a major fault.  If not, it is a minor fault.  These are expressed as the number of faults that have occurred. */
    <a name="VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT">VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT</a> = 3
    <a name="VIR_DOMAIN_MEMORY_STAT_UNUSED">VIR_DOMAIN_MEMORY_STAT_UNUSED</a> = 4 /* The amount of memory left completely unused by the system.  Memory that  is available but used for reclaimable caches should NOT be reported as  free.  This value is expressed in kB. */
    <a name="VIR_DOMAIN_MEMORY_STAT_AVAILABLE">VIR_DOMAIN_MEMORY_STAT_AVAILABLE</a> = 5 /* The total amount of usable memory as seen by the domain.  This value  may be less than the amount of memory assigned to the domain if a  balloon driver is in use or if the guest OS does not initialize all  assigned pages.  This value is expressed in kB. */
    <a name="VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON">VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON</a> = 6 /* Current balloon value (in KB). */
    <a name="VIR_DOMAIN_MEMORY_STAT_RSS">VIR_DOMAIN_MEMORY_STAT_RSS</a> = 7 /* Resident Set Size of the process running the domain. This value  is in kB */
    <a name="VIR_DOMAIN_MEMORY_STAT_USABLE">VIR_DOMAIN_MEMORY_STAT_USABLE</a> = 8 /* How much the balloon can be inflated without pushing the guest system  to swap, corresponds to 'Available' in /proc/meminfo */
    <a name="VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE">VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE</a> = 9 /* Timestamp of the last update of statistics, in seconds. */
    <a name="VIR_DOMAIN_MEMORY_STAT_DISK_CACHES">VIR_DOMAIN_MEMORY_STAT_DISK_CACHES</a> = 10 /* The amount of memory, that can be quickly reclaimed without  additional I/O (in kB). Typically these pages are used for caching files  from disk. */
    <a name="VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC">VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC</a> = 11 /* The amount of successful huge page allocations from inside the domain via  virtio balloon. */
    <a name="VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL">VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL</a> = 12 /* The amount of failed huge page allocations from inside the domain via  virtio balloon. */
    <a name="VIR_DOMAIN_MEMORY_STAT_NR">VIR_DOMAIN_MEMORY_STAT_NR</a> = 13 /* The number of statistics supported by this version of the interface.  To add new statistics, add them to the enum and increase this value. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMetadataType">Enum </a>virDomainMetadataType</h3><pre class="programlisting">enum <a href="#virDomainMetadataType">virDomainMetadataType</a> {
    <a name="VIR_DOMAIN_METADATA_DESCRIPTION">VIR_DOMAIN_METADATA_DESCRIPTION</a> = 0 /* Operate on &lt;description&gt; */
    <a name="VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a> = 1 /* Operate on &lt;title&gt; */
    <a name="VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> = 2 /* Operate on &lt;metadata&gt; */
    <a name="VIR_DOMAIN_METADATA_LAST">VIR_DOMAIN_METADATA_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateFlags">Enum </a>virDomainMigrateFlags</h3><pre class="programlisting">enum <a href="#virDomainMigrateFlags">virDomainMigrateFlags</a> {
    <a name="VIR_MIGRATE_LIVE">VIR_MIGRATE_LIVE</a> = 1 /* Do not pause the domain during migration. The domain's memory will  be transferred to the destination host while the domain is running.  The migration may never converge if the domain is changing its memory  faster then it can be transferred. The domain can be manually paused  anytime during migration using virDomainSuspend. */
    <a name="VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> = 2 /* Tell the source libvirtd to connect directly to the destination host.  Without this flag the client (e.g., virsh) connects to both hosts and  controls the migration process. In peer-to-peer mode, the source  libvirtd controls the migration by calling the destination daemon  directly. */
    <a name="VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a> = 4 /* Tunnel migration data over libvirtd connection. Without this flag the  source hypervisor sends migration data directly to the destination  hypervisor. This flag can only be used when VIR_MIGRATE_PEER2PEER is  set as well.   Note the less-common spelling that we're stuck with:  VIR_MIGRATE_TUNNELLED should be VIR_MIGRATE_TUNNELED. */
    <a name="VIR_MIGRATE_PERSIST_DEST">VIR_MIGRATE_PERSIST_DEST</a> = 8 /* Define the domain as persistent on the destination host after successful  migration. If the domain was persistent on the source host and  VIR_MIGRATE_UNDEFINE_SOURCE is not used, it will end up persistent on  both hosts. */
    <a name="VIR_MIGRATE_UNDEFINE_SOURCE">VIR_MIGRATE_UNDEFINE_SOURCE</a> = 16 /* Undefine the domain on the source host once migration successfully  finishes. */
    <a name="VIR_MIGRATE_PAUSED">VIR_MIGRATE_PAUSED</a> = 32 /* Leave the domain suspended on the destination host. virDomainResume (on  the virDomainPtr returned by the migration API) has to be called  explicitly to resume domain's virtual CPUs. */
    <a name="VIR_MIGRATE_NON_SHARED_DISK">VIR_MIGRATE_NON_SHARED_DISK</a> = 64 /* Migrate full disk images in addition to domain's memory. By default  only non-shared non-readonly disk images are transferred. The  VIR_MIGRATE_PARAM_MIGRATE_DISKS parameter can be used to specify which  disks should be migrated.   This flag and VIR_MIGRATE_NON_SHARED_INC are mutually exclusive. */
    <a name="VIR_MIGRATE_NON_SHARED_INC">VIR_MIGRATE_NON_SHARED_INC</a> = 128 /* Migrate disk images in addition to domain's memory. This is similar to  VIR_MIGRATE_NON_SHARED_DISK, but only the top level of each disk's  backing chain is copied. That is, the rest of the backing chain is  expected to be present on the destination and to be exactly the same as  on the source host.   This flag and VIR_MIGRATE_NON_SHARED_DISK are mutually exclusive. */
    <a name="VIR_MIGRATE_CHANGE_PROTECTION">VIR_MIGRATE_CHANGE_PROTECTION</a> = 256 /* Protect against domain configuration changes during the migration  process. This flag is used automatically when both sides support it.  Explicitly setting this flag will cause migration to fail if either the  source or the destination does not support it. */
    <a name="VIR_MIGRATE_UNSAFE">VIR_MIGRATE_UNSAFE</a> = 512 /* Force migration even if it is considered unsafe. In some cases libvirt  may refuse to migrate the domain because doing so may lead to potential  problems such as data corruption, and thus the migration is considered  unsafe. For a QEMU domain this may happen if the domain uses disks  without explicitly setting cache mode to "none". Migrating such domains  is unsafe unless the disk images are stored on coherent clustered  filesystem, such as GFS2 or GPFS. */
    <a name="VIR_MIGRATE_OFFLINE">VIR_MIGRATE_OFFLINE</a> = 1024 /* Migrate a domain definition without starting the domain on the  destination and without stopping it on the source host. Offline  migration requires VIR_MIGRATE_PERSIST_DEST to be set.   Offline migration may not copy disk storage or any other file based  storage (such as UEFI variables). */
    <a name="VIR_MIGRATE_COMPRESSED">VIR_MIGRATE_COMPRESSED</a> = 2048 /* Compress migration data. The compression methods can be specified using  VIR_MIGRATE_PARAM_COMPRESSION. A hypervisor default method will be used  if this parameter is omitted. Individual compression methods can be  tuned via their specific VIR_MIGRATE_PARAM_COMPRESSION_* parameters. */
    <a name="VIR_MIGRATE_ABORT_ON_ERROR">VIR_MIGRATE_ABORT_ON_ERROR</a> = 4096 /* Cancel migration if a soft error (such as I/O error) happens during  migration. */
    <a name="VIR_MIGRATE_AUTO_CONVERGE">VIR_MIGRATE_AUTO_CONVERGE</a> = 8192 /* Enable algorithms that ensure a live migration will eventually converge.  This usually means the domain will be slowed down to make sure it does  not change its memory faster than a hypervisor can transfer the changed  memory to the destination host. VIR_MIGRATE_PARAM_AUTO_CONVERGE_*  parameters can be used to tune the algorithm. */
    <a name="VIR_MIGRATE_RDMA_PIN_ALL">VIR_MIGRATE_RDMA_PIN_ALL</a> = 16384 /* This flag can be used with RDMA migration (i.e., when  VIR_MIGRATE_PARAM_URI starts with "rdma://") to tell the hypervisor  to pin all domain's memory at once before migration starts rather then  letting it pin memory pages as needed. This means that all memory pages  belonging to the domain will be locked in host's memory and the host  will not be allowed to swap them out.   For QEMU/KVM this requires hard_limit memory tuning element (in the  domain XML) to be used and set to the maximum memory configured for the  domain plus any memory consumed by the QEMU process itself. Beware of  setting the memory limit too high (and thus allowing the domain to lock  most of the host's memory). Doing so may be dangerous to both the  domain and the host itself since the host's kernel may run out of  memory. */
    <a name="VIR_MIGRATE_POSTCOPY">VIR_MIGRATE_POSTCOPY</a> = 32768 /* Setting the VIR_MIGRATE_POSTCOPY flag tells libvirt to enable post-copy  migration. However, the migration will start normally and  virDomainMigrateStartPostCopy needs to be called to switch it into the  post-copy mode. See virDomainMigrateStartPostCopy for more details. */
    <a name="VIR_MIGRATE_TLS">VIR_MIGRATE_TLS</a> = 65536 /* Setting the VIR_MIGRATE_TLS flag will cause the migration to attempt  to use the TLS environment configured by the hypervisor in order to  perform the migration. If incorrectly configured on either source or  destination, the migration will fail. */
    <a name="VIR_MIGRATE_PARALLEL">VIR_MIGRATE_PARALLEL</a> = 131072 /* Send memory pages to the destination host through several network  connections. See VIR_MIGRATE_PARAM_PARALLEL_* parameters for  configuring the parallel migration. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateMaxSpeedFlags">Enum </a>virDomainMigrateMaxSpeedFlags</h3><pre class="programlisting">enum <a href="#virDomainMigrateMaxSpeedFlags">virDomainMigrateMaxSpeedFlags</a> {
    <a name="VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY">VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY</a> = 1 /* Set or get maximum speed of post-copy migration. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainModificationImpact">Enum </a>virDomainModificationImpact</h3><pre class="programlisting">enum <a href="#virDomainModificationImpact">virDomainModificationImpact</a> {
    <a name="VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> = 0 /* Affect current domain state. */
    <a name="VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> = 1 /* Affect running domain state. */
    <a name="VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> = 2 /* Affect persistent domain state.  1 &lt;&lt; 2 is reserved for virTypedParameterFlags */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainNostateReason">Enum </a>virDomainNostateReason</h3><pre class="programlisting">enum <a href="#virDomainNostateReason">virDomainNostateReason</a> {
    <a name="VIR_DOMAIN_NOSTATE_UNKNOWN">VIR_DOMAIN_NOSTATE_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_NOSTATE_LAST">VIR_DOMAIN_NOSTATE_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainNumatuneMemMode">Enum </a>virDomainNumatuneMemMode</h3><pre class="programlisting">enum <a href="#virDomainNumatuneMemMode">virDomainNumatuneMemMode</a> {
    <a name="VIR_DOMAIN_NUMATUNE_MEM_STRICT">VIR_DOMAIN_NUMATUNE_MEM_STRICT</a> = 0
    <a name="VIR_DOMAIN_NUMATUNE_MEM_PREFERRED">VIR_DOMAIN_NUMATUNE_MEM_PREFERRED</a> = 1
    <a name="VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE">VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE</a> = 2
    <a name="VIR_DOMAIN_NUMATUNE_MEM_LAST">VIR_DOMAIN_NUMATUNE_MEM_LAST</a> = 3 /* This constant is subject to change */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenGraphicsFlags">Enum </a>virDomainOpenGraphicsFlags</h3><pre class="programlisting">enum <a href="#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a> {
    <a name="VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH">VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendedDiskReason">Enum </a>virDomainPMSuspendedDiskReason</h3><pre class="programlisting">enum <a href="#virDomainPMSuspendedDiskReason">virDomainPMSuspendedDiskReason</a> {
    <a name="VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_PMSUSPENDED_DISK_LAST">VIR_DOMAIN_PMSUSPENDED_DISK_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendedReason">Enum </a>virDomainPMSuspendedReason</h3><pre class="programlisting">enum <a href="#virDomainPMSuspendedReason">virDomainPMSuspendedReason</a> {
    <a name="VIR_DOMAIN_PMSUSPENDED_UNKNOWN">VIR_DOMAIN_PMSUSPENDED_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_PMSUSPENDED_LAST">VIR_DOMAIN_PMSUSPENDED_LAST</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPausedReason">Enum </a>virDomainPausedReason</h3><pre class="programlisting">enum <a href="#virDomainPausedReason">virDomainPausedReason</a> {
    <a name="VIR_DOMAIN_PAUSED_UNKNOWN">VIR_DOMAIN_PAUSED_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_PAUSED_USER">VIR_DOMAIN_PAUSED_USER</a> = 1 /* paused on user request */
    <a name="VIR_DOMAIN_PAUSED_MIGRATION">VIR_DOMAIN_PAUSED_MIGRATION</a> = 2 /* paused for offline migration */
    <a name="VIR_DOMAIN_PAUSED_SAVE">VIR_DOMAIN_PAUSED_SAVE</a> = 3 /* paused for save */
    <a name="VIR_DOMAIN_PAUSED_DUMP">VIR_DOMAIN_PAUSED_DUMP</a> = 4 /* paused for offline core dump */
    <a name="VIR_DOMAIN_PAUSED_IOERROR">VIR_DOMAIN_PAUSED_IOERROR</a> = 5 /* paused due to a disk I/O error */
    <a name="VIR_DOMAIN_PAUSED_WATCHDOG">VIR_DOMAIN_PAUSED_WATCHDOG</a> = 6 /* paused due to a watchdog event */
    <a name="VIR_DOMAIN_PAUSED_FROM_SNAPSHOT">VIR_DOMAIN_PAUSED_FROM_SNAPSHOT</a> = 7 /* paused after restoring from snapshot */
    <a name="VIR_DOMAIN_PAUSED_SHUTTING_DOWN">VIR_DOMAIN_PAUSED_SHUTTING_DOWN</a> = 8 /* paused during shutdown process */
    <a name="VIR_DOMAIN_PAUSED_SNAPSHOT">VIR_DOMAIN_PAUSED_SNAPSHOT</a> = 9 /* paused while creating a snapshot */
    <a name="VIR_DOMAIN_PAUSED_CRASHED">VIR_DOMAIN_PAUSED_CRASHED</a> = 10 /* paused due to a guest crash */
    <a name="VIR_DOMAIN_PAUSED_STARTING_UP">VIR_DOMAIN_PAUSED_STARTING_UP</a> = 11 /* the domain is being started */
    <a name="VIR_DOMAIN_PAUSED_POSTCOPY">VIR_DOMAIN_PAUSED_POSTCOPY</a> = 12 /* paused for post-copy migration */
    <a name="VIR_DOMAIN_PAUSED_POSTCOPY_FAILED">VIR_DOMAIN_PAUSED_POSTCOPY_FAILED</a> = 13 /* paused after failed post-copy */
    <a name="VIR_DOMAIN_PAUSED_LAST">VIR_DOMAIN_PAUSED_LAST</a> = 14
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainProcessSignal">Enum </a>virDomainProcessSignal</h3><pre class="programlisting">enum <a href="#virDomainProcessSignal">virDomainProcessSignal</a> {
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a> = 0 /* No constant in POSIX/Linux */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_HUP">VIR_DOMAIN_PROCESS_SIGNAL_HUP</a> = 1 /* SIGHUP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_INT">VIR_DOMAIN_PROCESS_SIGNAL_INT</a> = 2 /* SIGINT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_QUIT">VIR_DOMAIN_PROCESS_SIGNAL_QUIT</a> = 3 /* SIGQUIT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ILL">VIR_DOMAIN_PROCESS_SIGNAL_ILL</a> = 4 /* SIGILL */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TRAP">VIR_DOMAIN_PROCESS_SIGNAL_TRAP</a> = 5 /* SIGTRAP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ABRT">VIR_DOMAIN_PROCESS_SIGNAL_ABRT</a> = 6 /* SIGABRT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_BUS">VIR_DOMAIN_PROCESS_SIGNAL_BUS</a> = 7 /* SIGBUS */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_FPE">VIR_DOMAIN_PROCESS_SIGNAL_FPE</a> = 8 /* SIGFPE */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_KILL">VIR_DOMAIN_PROCESS_SIGNAL_KILL</a> = 9 /* SIGKILL */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_USR1">VIR_DOMAIN_PROCESS_SIGNAL_USR1</a> = 10 /* SIGUSR1 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_SEGV">VIR_DOMAIN_PROCESS_SIGNAL_SEGV</a> = 11 /* SIGSEGV */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_USR2">VIR_DOMAIN_PROCESS_SIGNAL_USR2</a> = 12 /* SIGUSR2 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PIPE">VIR_DOMAIN_PROCESS_SIGNAL_PIPE</a> = 13 /* SIGPIPE */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_ALRM">VIR_DOMAIN_PROCESS_SIGNAL_ALRM</a> = 14 /* SIGALRM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TERM">VIR_DOMAIN_PROCESS_SIGNAL_TERM</a> = 15 /* SIGTERM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_STKFLT">VIR_DOMAIN_PROCESS_SIGNAL_STKFLT</a> = 16 /* Not in POSIX (SIGSTKFLT on Linux */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_CHLD">VIR_DOMAIN_PROCESS_SIGNAL_CHLD</a> = 17 /* SIGCHLD */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_CONT">VIR_DOMAIN_PROCESS_SIGNAL_CONT</a> = 18 /* SIGCONT */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_STOP">VIR_DOMAIN_PROCESS_SIGNAL_STOP</a> = 19 /* SIGSTOP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TSTP">VIR_DOMAIN_PROCESS_SIGNAL_TSTP</a> = 20 /* SIGTSTP */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TTIN">VIR_DOMAIN_PROCESS_SIGNAL_TTIN</a> = 21 /* SIGTTIN */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_TTOU">VIR_DOMAIN_PROCESS_SIGNAL_TTOU</a> = 22 /* SIGTTOU */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_URG">VIR_DOMAIN_PROCESS_SIGNAL_URG</a> = 23 /* SIGURG */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_XCPU">VIR_DOMAIN_PROCESS_SIGNAL_XCPU</a> = 24 /* SIGXCPU */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_XFSZ">VIR_DOMAIN_PROCESS_SIGNAL_XFSZ</a> = 25 /* SIGXFSZ */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_VTALRM">VIR_DOMAIN_PROCESS_SIGNAL_VTALRM</a> = 26 /* SIGVTALRM */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PROF">VIR_DOMAIN_PROCESS_SIGNAL_PROF</a> = 27 /* SIGPROF */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_WINCH">VIR_DOMAIN_PROCESS_SIGNAL_WINCH</a> = 28 /* Not in POSIX (SIGWINCH on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_POLL">VIR_DOMAIN_PROCESS_SIGNAL_POLL</a> = 29 /* SIGPOLL (also known as SIGIO on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_PWR">VIR_DOMAIN_PROCESS_SIGNAL_PWR</a> = 30 /* Not in POSIX (SIGPWR on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_SYS">VIR_DOMAIN_PROCESS_SIGNAL_SYS</a> = 31 /* SIGSYS (also known as SIGUNUSED on Linux) */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT0">VIR_DOMAIN_PROCESS_SIGNAL_RT0</a> = 32 /* SIGRTMIN */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT1">VIR_DOMAIN_PROCESS_SIGNAL_RT1</a> = 33 /* SIGRTMIN + 1 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT2">VIR_DOMAIN_PROCESS_SIGNAL_RT2</a> = 34 /* SIGRTMIN + 2 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT3">VIR_DOMAIN_PROCESS_SIGNAL_RT3</a> = 35 /* SIGRTMIN + 3 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT4">VIR_DOMAIN_PROCESS_SIGNAL_RT4</a> = 36 /* SIGRTMIN + 4 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT5">VIR_DOMAIN_PROCESS_SIGNAL_RT5</a> = 37 /* SIGRTMIN + 5 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT6">VIR_DOMAIN_PROCESS_SIGNAL_RT6</a> = 38 /* SIGRTMIN + 6 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT7">VIR_DOMAIN_PROCESS_SIGNAL_RT7</a> = 39 /* SIGRTMIN + 7 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT8">VIR_DOMAIN_PROCESS_SIGNAL_RT8</a> = 40 /* SIGRTMIN + 8 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT9">VIR_DOMAIN_PROCESS_SIGNAL_RT9</a> = 41 /* SIGRTMIN + 9 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT10">VIR_DOMAIN_PROCESS_SIGNAL_RT10</a> = 42 /* SIGRTMIN + 10 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT11">VIR_DOMAIN_PROCESS_SIGNAL_RT11</a> = 43 /* SIGRTMIN + 11 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT12">VIR_DOMAIN_PROCESS_SIGNAL_RT12</a> = 44 /* SIGRTMIN + 12 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT13">VIR_DOMAIN_PROCESS_SIGNAL_RT13</a> = 45 /* SIGRTMIN + 13 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT14">VIR_DOMAIN_PROCESS_SIGNAL_RT14</a> = 46 /* SIGRTMIN + 14 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT15">VIR_DOMAIN_PROCESS_SIGNAL_RT15</a> = 47 /* SIGRTMIN + 15 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT16">VIR_DOMAIN_PROCESS_SIGNAL_RT16</a> = 48 /* SIGRTMIN + 16 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT17">VIR_DOMAIN_PROCESS_SIGNAL_RT17</a> = 49 /* SIGRTMIN + 17 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT18">VIR_DOMAIN_PROCESS_SIGNAL_RT18</a> = 50 /* SIGRTMIN + 18 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT19">VIR_DOMAIN_PROCESS_SIGNAL_RT19</a> = 51 /* SIGRTMIN + 19 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT20">VIR_DOMAIN_PROCESS_SIGNAL_RT20</a> = 52 /* SIGRTMIN + 20 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT21">VIR_DOMAIN_PROCESS_SIGNAL_RT21</a> = 53 /* SIGRTMIN + 21 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT22">VIR_DOMAIN_PROCESS_SIGNAL_RT22</a> = 54 /* SIGRTMIN + 22 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT23">VIR_DOMAIN_PROCESS_SIGNAL_RT23</a> = 55 /* SIGRTMIN + 23 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT24">VIR_DOMAIN_PROCESS_SIGNAL_RT24</a> = 56 /* SIGRTMIN + 24 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT25">VIR_DOMAIN_PROCESS_SIGNAL_RT25</a> = 57 /* SIGRTMIN + 25 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT26">VIR_DOMAIN_PROCESS_SIGNAL_RT26</a> = 58 /* SIGRTMIN + 26 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT27">VIR_DOMAIN_PROCESS_SIGNAL_RT27</a> = 59 /* SIGRTMIN + 27 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT28">VIR_DOMAIN_PROCESS_SIGNAL_RT28</a> = 60 /* SIGRTMIN + 28 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT29">VIR_DOMAIN_PROCESS_SIGNAL_RT29</a> = 61 /* SIGRTMIN + 29 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT30">VIR_DOMAIN_PROCESS_SIGNAL_RT30</a> = 62 /* SIGRTMIN + 30 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT31">VIR_DOMAIN_PROCESS_SIGNAL_RT31</a> = 63 /* SIGRTMIN + 31 */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_RT32">VIR_DOMAIN_PROCESS_SIGNAL_RT32</a> = 64 /* SIGRTMIN + 32 / SIGRTMAX */
    <a name="VIR_DOMAIN_PROCESS_SIGNAL_LAST">VIR_DOMAIN_PROCESS_SIGNAL_LAST</a> = 65
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPtr">Typedef </a>virDomainPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomain">virDomain</a> * virDomainPtr;
</pre><p>a <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> is pointer to a <a href="libvirt-libvirt-domain.html#virDomain">virDomain</a> private structure, this is the type used to reference a domain in the API.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRebootFlagValues">Enum </a>virDomainRebootFlagValues</h3><pre class="programlisting">enum <a href="#virDomainRebootFlagValues">virDomainRebootFlagValues</a> {
    <a name="VIR_DOMAIN_REBOOT_DEFAULT">VIR_DOMAIN_REBOOT_DEFAULT</a> = 0 /* hypervisor choice */
    <a name="VIR_DOMAIN_REBOOT_ACPI_POWER_BTN">VIR_DOMAIN_REBOOT_ACPI_POWER_BTN</a> = 1 /* Send ACPI event */
    <a name="VIR_DOMAIN_REBOOT_GUEST_AGENT">VIR_DOMAIN_REBOOT_GUEST_AGENT</a> = 2 /* Use guest agent */
    <a name="VIR_DOMAIN_REBOOT_INITCTL">VIR_DOMAIN_REBOOT_INITCTL</a> = 4 /* Use initctl */
    <a name="VIR_DOMAIN_REBOOT_SIGNAL">VIR_DOMAIN_REBOOT_SIGNAL</a> = 8 /* Send a signal */
    <a name="VIR_DOMAIN_REBOOT_PARAVIRT">VIR_DOMAIN_REBOOT_PARAVIRT</a> = 16 /* Use paravirt guest control */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRunningReason">Enum </a>virDomainRunningReason</h3><pre class="programlisting">enum <a href="#virDomainRunningReason">virDomainRunningReason</a> {
    <a name="VIR_DOMAIN_RUNNING_UNKNOWN">VIR_DOMAIN_RUNNING_UNKNOWN</a> = 0
    <a name="VIR_DOMAIN_RUNNING_BOOTED">VIR_DOMAIN_RUNNING_BOOTED</a> = 1 /* normal startup from boot */
    <a name="VIR_DOMAIN_RUNNING_MIGRATED">VIR_DOMAIN_RUNNING_MIGRATED</a> = 2 /* migrated from another host */
    <a name="VIR_DOMAIN_RUNNING_RESTORED">VIR_DOMAIN_RUNNING_RESTORED</a> = 3 /* restored from a state file */
    <a name="VIR_DOMAIN_RUNNING_FROM_SNAPSHOT">VIR_DOMAIN_RUNNING_FROM_SNAPSHOT</a> = 4 /* restored from snapshot */
    <a name="VIR_DOMAIN_RUNNING_UNPAUSED">VIR_DOMAIN_RUNNING_UNPAUSED</a> = 5 /* returned from paused state */
    <a name="VIR_DOMAIN_RUNNING_MIGRATION_CANCELED">VIR_DOMAIN_RUNNING_MIGRATION_CANCELED</a> = 6 /* returned from migration */
    <a name="VIR_DOMAIN_RUNNING_SAVE_CANCELED">VIR_DOMAIN_RUNNING_SAVE_CANCELED</a> = 7 /* returned from failed save process */
    <a name="VIR_DOMAIN_RUNNING_WAKEUP">VIR_DOMAIN_RUNNING_WAKEUP</a> = 8 /* returned from pmsuspended due to wakeup event */
    <a name="VIR_DOMAIN_RUNNING_CRASHED">VIR_DOMAIN_RUNNING_CRASHED</a> = 9 /* resumed from crashed */
    <a name="VIR_DOMAIN_RUNNING_POSTCOPY">VIR_DOMAIN_RUNNING_POSTCOPY</a> = 10 /* running in post-copy migration mode */
    <a name="VIR_DOMAIN_RUNNING_LAST">VIR_DOMAIN_RUNNING_LAST</a> = 11
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveImageXMLFlags">Enum </a>virDomainSaveImageXMLFlags</h3><pre class="programlisting">enum <a href="#virDomainSaveImageXMLFlags">virDomainSaveImageXMLFlags</a> {
    <a name="VIR_DOMAIN_SAVE_IMAGE_XML_SECURE">VIR_DOMAIN_SAVE_IMAGE_XML_SECURE</a> = VIR_DOMAIN_XML_SECURE /* dump security sensitive information too */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveRestoreFlags">Enum </a>virDomainSaveRestoreFlags</h3><pre class="programlisting">enum <a href="#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a> {
    <a name="VIR_DOMAIN_SAVE_BYPASS_CACHE">VIR_DOMAIN_SAVE_BYPASS_CACHE</a> = 1 /* Avoid file system cache pollution */
    <a name="VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> = 2 /* Favor running over paused */
    <a name="VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> = 4 /* Favor paused over running */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetTimeFlags">Enum </a>virDomainSetTimeFlags</h3><pre class="programlisting">enum <a href="#virDomainSetTimeFlags">virDomainSetTimeFlags</a> {
    <a name="VIR_DOMAIN_TIME_SYNC">VIR_DOMAIN_TIME_SYNC</a> = 1 /* Re-sync domain time from domain's RTC */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetUserPasswordFlags">Enum </a>virDomainSetUserPasswordFlags</h3><pre class="programlisting">enum <a href="#virDomainSetUserPasswordFlags">virDomainSetUserPasswordFlags</a> {
    <a name="VIR_DOMAIN_PASSWORD_ENCRYPTED">VIR_DOMAIN_PASSWORD_ENCRYPTED</a> = 1 /* the password is already encrypted */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownFlagValues">Enum </a>virDomainShutdownFlagValues</h3><pre class="programlisting">enum <a href="#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a> {
    <a name="VIR_DOMAIN_SHUTDOWN_DEFAULT">VIR_DOMAIN_SHUTDOWN_DEFAULT</a> = 0 /* hypervisor choice */
    <a name="VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN">VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN</a> = 1 /* Send ACPI event */
    <a name="VIR_DOMAIN_SHUTDOWN_GUEST_AGENT">VIR_DOMAIN_SHUTDOWN_GUEST_AGENT</a> = 2 /* Use guest agent */
    <a name="VIR_DOMAIN_SHUTDOWN_INITCTL">VIR_DOMAIN_SHUTDOWN_INITCTL</a> = 4 /* Use initctl */
    <a name="VIR_DOMAIN_SHUTDOWN_SIGNAL">VIR_DOMAIN_SHUTDOWN_SIGNAL</a> = 8 /* Send a signal */
    <a name="VIR_DOMAIN_SHUTDOWN_PARAVIRT">VIR_DOMAIN_SHUTDOWN_PARAVIRT</a> = 16 /* Use paravirt guest control */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownReason">Enum </a>virDomainShutdownReason</h3><pre class="programlisting">enum <a href="#virDomainShutdownReason">virDomainShutdownReason</a> {
    <a name="VIR_DOMAIN_SHUTDOWN_UNKNOWN">VIR_DOMAIN_SHUTDOWN_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_SHUTDOWN_USER">VIR_DOMAIN_SHUTDOWN_USER</a> = 1 /* shutting down on user request */
    <a name="VIR_DOMAIN_SHUTDOWN_LAST">VIR_DOMAIN_SHUTDOWN_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutoffReason">Enum </a>virDomainShutoffReason</h3><pre class="programlisting">enum <a href="#virDomainShutoffReason">virDomainShutoffReason</a> {
    <a name="VIR_DOMAIN_SHUTOFF_UNKNOWN">VIR_DOMAIN_SHUTOFF_UNKNOWN</a> = 0 /* the reason is unknown */
    <a name="VIR_DOMAIN_SHUTOFF_SHUTDOWN">VIR_DOMAIN_SHUTOFF_SHUTDOWN</a> = 1 /* normal shutdown */
    <a name="VIR_DOMAIN_SHUTOFF_DESTROYED">VIR_DOMAIN_SHUTOFF_DESTROYED</a> = 2 /* forced poweroff */
    <a name="VIR_DOMAIN_SHUTOFF_CRASHED">VIR_DOMAIN_SHUTOFF_CRASHED</a> = 3 /* domain crashed */
    <a name="VIR_DOMAIN_SHUTOFF_MIGRATED">VIR_DOMAIN_SHUTOFF_MIGRATED</a> = 4 /* migrated to another host */
    <a name="VIR_DOMAIN_SHUTOFF_SAVED">VIR_DOMAIN_SHUTOFF_SAVED</a> = 5 /* saved to a file */
    <a name="VIR_DOMAIN_SHUTOFF_FAILED">VIR_DOMAIN_SHUTOFF_FAILED</a> = 6 /* domain failed to start */
    <a name="VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT">VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT</a> = 7 /* restored from a snapshot which was  taken while domain was shutoff */
    <a name="VIR_DOMAIN_SHUTOFF_DAEMON">VIR_DOMAIN_SHUTOFF_DAEMON</a> = 8 /* daemon decides to kill domain during reconnection processing */
    <a name="VIR_DOMAIN_SHUTOFF_LAST">VIR_DOMAIN_SHUTOFF_LAST</a> = 9
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainState">Enum </a>virDomainState</h3><pre class="programlisting">enum <a href="#virDomainState">virDomainState</a> {
    <a name="VIR_DOMAIN_NOSTATE">VIR_DOMAIN_NOSTATE</a> = 0 /* no state */
    <a name="VIR_DOMAIN_RUNNING">VIR_DOMAIN_RUNNING</a> = 1 /* the domain is running */
    <a name="VIR_DOMAIN_BLOCKED">VIR_DOMAIN_BLOCKED</a> = 2 /* the domain is blocked on resource */
    <a name="VIR_DOMAIN_PAUSED">VIR_DOMAIN_PAUSED</a> = 3 /* the domain is paused by user */
    <a name="VIR_DOMAIN_SHUTDOWN">VIR_DOMAIN_SHUTDOWN</a> = 4 /* the domain is being shut down */
    <a name="VIR_DOMAIN_SHUTOFF">VIR_DOMAIN_SHUTOFF</a> = 5 /* the domain is shut off */
    <a name="VIR_DOMAIN_CRASHED">VIR_DOMAIN_CRASHED</a> = 6 /* the domain is crashed */
    <a name="VIR_DOMAIN_PMSUSPENDED">VIR_DOMAIN_PMSUSPENDED</a> = 7 /* the domain is suspended by guest power management */
    <a name="VIR_DOMAIN_LAST">VIR_DOMAIN_LAST</a> = 8 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last state supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainStatsRecord">Structure </a>virDomainStatsRecord</h3><pre class="programlisting">struct _virDomainStatsRecord {
    <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	dom
    <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a>	params
    int	nparams
} virDomainStatsRecord;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainStatsRecordPtr">Typedef </a>virDomainStatsRecordPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainStatsRecord">virDomainStatsRecord</a> * virDomainStatsRecordPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainStatsTypes">Enum </a>virDomainStatsTypes</h3><pre class="programlisting">enum <a href="#virDomainStatsTypes">virDomainStatsTypes</a> {
    <a name="VIR_DOMAIN_STATS_STATE">VIR_DOMAIN_STATS_STATE</a> = 1 /* return domain state */
    <a name="VIR_DOMAIN_STATS_CPU_TOTAL">VIR_DOMAIN_STATS_CPU_TOTAL</a> = 2 /* return domain CPU info */
    <a name="VIR_DOMAIN_STATS_BALLOON">VIR_DOMAIN_STATS_BALLOON</a> = 4 /* return domain balloon info */
    <a name="VIR_DOMAIN_STATS_VCPU">VIR_DOMAIN_STATS_VCPU</a> = 8 /* return domain virtual CPU info */
    <a name="VIR_DOMAIN_STATS_INTERFACE">VIR_DOMAIN_STATS_INTERFACE</a> = 16 /* return domain interfaces info */
    <a name="VIR_DOMAIN_STATS_BLOCK">VIR_DOMAIN_STATS_BLOCK</a> = 32 /* return domain block info */
    <a name="VIR_DOMAIN_STATS_PERF">VIR_DOMAIN_STATS_PERF</a> = 64 /* return domain perf event info */
    <a name="VIR_DOMAIN_STATS_IOTHREAD">VIR_DOMAIN_STATS_IOTHREAD</a> = 128 /* return iothread poll info */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefineFlagsValues">Enum </a>virDomainUndefineFlagsValues</h3><pre class="programlisting">enum <a href="#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a> {
    <a name="VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a> = 1 /* Also remove any managed save */
    <a name="VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA">VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA</a> = 2 /* If last use of domain, then also remove any snapshot metadata */
    <a name="VIR_DOMAIN_UNDEFINE_NVRAM">VIR_DOMAIN_UNDEFINE_NVRAM</a> = 4 /* Also remove any nvram file */
    <a name="VIR_DOMAIN_UNDEFINE_KEEP_NVRAM">VIR_DOMAIN_UNDEFINE_KEEP_NVRAM</a> = 8 /* Keep nvram file */
    <a name="VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA">VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA</a> = 16 /* If last use of domain, then also remove any checkpoint metadata Future undefine control flags should come here. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainVcpuFlags">Enum </a>virDomainVcpuFlags</h3><pre class="programlisting">enum <a href="#virDomainVcpuFlags">virDomainVcpuFlags</a> {
    <a name="VIR_DOMAIN_VCPU_CONFIG">VIR_DOMAIN_VCPU_CONFIG</a> = VIR_DOMAIN_AFFECT_CONFIG
    <a name="VIR_DOMAIN_VCPU_CURRENT">VIR_DOMAIN_VCPU_CURRENT</a> = VIR_DOMAIN_AFFECT_CURRENT /* See virDomainModificationImpact for these flags. */
    <a name="VIR_DOMAIN_VCPU_LIVE">VIR_DOMAIN_VCPU_LIVE</a> = VIR_DOMAIN_AFFECT_LIVE
    <a name="VIR_DOMAIN_VCPU_MAXIMUM">VIR_DOMAIN_VCPU_MAXIMUM</a> = 4 /* Additionally, these flags may be bitwise-OR'd in. */
    <a name="VIR_DOMAIN_VCPU_GUEST">VIR_DOMAIN_VCPU_GUEST</a> = 8 /* Max rather than current count */
    <a name="VIR_DOMAIN_VCPU_HOTPLUGGABLE">VIR_DOMAIN_VCPU_HOTPLUGGABLE</a> = 16 /* Modify state of the cpu in the guest */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainXMLFlags">Enum </a>virDomainXMLFlags</h3><pre class="programlisting">enum <a href="#virDomainXMLFlags">virDomainXMLFlags</a> {
    <a name="VIR_DOMAIN_XML_SECURE">VIR_DOMAIN_XML_SECURE</a> = 1 /* dump security sensitive information too */
    <a name="VIR_DOMAIN_XML_INACTIVE">VIR_DOMAIN_XML_INACTIVE</a> = 2 /* dump inactive domain information */
    <a name="VIR_DOMAIN_XML_UPDATE_CPU">VIR_DOMAIN_XML_UPDATE_CPU</a> = 4 /* update guest CPU requirements according to host CPU */
    <a name="VIR_DOMAIN_XML_MIGRATABLE">VIR_DOMAIN_XML_MIGRATABLE</a> = 8 /* dump XML suitable for migration */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virKeycodeSet">Enum </a>virKeycodeSet</h3><pre class="programlisting">enum <a href="#virKeycodeSet">virKeycodeSet</a> {
    <a name="VIR_KEYCODE_SET_LINUX">VIR_KEYCODE_SET_LINUX</a> = 0
    <a name="VIR_KEYCODE_SET_XT">VIR_KEYCODE_SET_XT</a> = 1
    <a name="VIR_KEYCODE_SET_ATSET1">VIR_KEYCODE_SET_ATSET1</a> = 2
    <a name="VIR_KEYCODE_SET_ATSET2">VIR_KEYCODE_SET_ATSET2</a> = 3
    <a name="VIR_KEYCODE_SET_ATSET3">VIR_KEYCODE_SET_ATSET3</a> = 4
    <a name="VIR_KEYCODE_SET_OSX">VIR_KEYCODE_SET_OSX</a> = 5
    <a name="VIR_KEYCODE_SET_XT_KBD">VIR_KEYCODE_SET_XT_KBD</a> = 6
    <a name="VIR_KEYCODE_SET_USB">VIR_KEYCODE_SET_USB</a> = 7
    <a name="VIR_KEYCODE_SET_WIN32">VIR_KEYCODE_SET_WIN32</a> = 8
    <a name="VIR_KEYCODE_SET_QNUM">VIR_KEYCODE_SET_QNUM</a> = 9
    <a name="VIR_KEYCODE_SET_LAST">VIR_KEYCODE_SET_LAST</a> = 10 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last keycode set supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameter">Structure </a>virMemoryParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt-common.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virMemoryParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameterPtr">Typedef </a>virMemoryParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virMemoryParameter">virMemoryParameter</a> * virMemoryParameterPtr;
</pre><p>a <a href="libvirt-libvirt-domain.html#virMemoryParameterPtr">virMemoryParameterPtr</a> is a pointer to a <a href="libvirt-libvirt-domain.html#virMemoryParameter">virMemoryParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virMemoryParameterType">Enum </a>virMemoryParameterType</h3><pre class="programlisting">enum <a href="#virMemoryParameterType">virMemoryParameterType</a> {
    <a name="VIR_DOMAIN_MEMORY_PARAM_BOOLEAN">VIR_DOMAIN_MEMORY_PARAM_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_MEMORY_PARAM_DOUBLE">VIR_DOMAIN_MEMORY_PARAM_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_MEMORY_PARAM_INT">VIR_DOMAIN_MEMORY_PARAM_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_MEMORY_PARAM_LLONG">VIR_DOMAIN_MEMORY_PARAM_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_MEMORY_PARAM_UINT">VIR_DOMAIN_MEMORY_PARAM_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_MEMORY_PARAM_ULLONG">VIR_DOMAIN_MEMORY_PARAM_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameter">Structure </a>virSchedParameter</h3><pre class="programlisting">struct _virTypedParameter {
    char field[VIR_TYPED_PARAM_FIELD_LENGTH]	field	: parameter name
    int	type	: parameter type, <a href="libvirt-libvirt-common.html#virTypedParameterType">virTypedParameterType</a>
    union	value	: parameter value
} virSchedParameter;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameterPtr">Typedef </a>virSchedParameterPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virSchedParameter">virSchedParameter</a> * virSchedParameterPtr;
</pre><p>a <a href="libvirt-libvirt-domain.html#virSchedParameterPtr">virSchedParameterPtr</a> is a pointer to a <a href="libvirt-libvirt-domain.html#virSchedParameter">virSchedParameter</a> structure. Provided for backwards compatibility; <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> is the preferred alias since 0.9.2.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virSchedParameterType">Enum </a>virSchedParameterType</h3><pre class="programlisting">enum <a href="#virSchedParameterType">virSchedParameterType</a> {
    <a name="VIR_DOMAIN_SCHED_FIELD_BOOLEAN">VIR_DOMAIN_SCHED_FIELD_BOOLEAN</a> = VIR_TYPED_PARAM_BOOLEAN
    <a name="VIR_DOMAIN_SCHED_FIELD_DOUBLE">VIR_DOMAIN_SCHED_FIELD_DOUBLE</a> = VIR_TYPED_PARAM_DOUBLE
    <a name="VIR_DOMAIN_SCHED_FIELD_INT">VIR_DOMAIN_SCHED_FIELD_INT</a> = VIR_TYPED_PARAM_INT
    <a name="VIR_DOMAIN_SCHED_FIELD_LLONG">VIR_DOMAIN_SCHED_FIELD_LLONG</a> = VIR_TYPED_PARAM_LLONG
    <a name="VIR_DOMAIN_SCHED_FIELD_UINT">VIR_DOMAIN_SCHED_FIELD_UINT</a> = VIR_TYPED_PARAM_UINT
    <a name="VIR_DOMAIN_SCHED_FIELD_ULLONG">VIR_DOMAIN_SCHED_FIELD_ULLONG</a> = VIR_TYPED_PARAM_ULLONG
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuInfo">Structure </a>virVcpuInfo</h3><pre class="programlisting">struct _virVcpuInfo {
    unsigned int	number	: virtual CPU number
    int	state	: value from <a href="libvirt-libvirt-domain.html#virVcpuState">virVcpuState</a>
    unsigned long long	cpuTime	: CPU time used, in nanoseconds
    int	cpu	: real CPU number, or -1 if offline
} virVcpuInfo;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuInfoPtr">Typedef </a>virVcpuInfoPtr</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virVcpuInfo">virVcpuInfo</a> * virVcpuInfoPtr;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virVcpuState">Enum </a>virVcpuState</h3><pre class="programlisting">enum <a href="#virVcpuState">virVcpuState</a> {
    <a name="VIR_VCPU_OFFLINE">VIR_VCPU_OFFLINE</a> = 0 /* the virtual CPU is offline */
    <a name="VIR_VCPU_RUNNING">VIR_VCPU_RUNNING</a> = 1 /* the virtual CPU is running */
    <a name="VIR_VCPU_BLOCKED">VIR_VCPU_BLOCKED</a> = 2 /* the virtual CPU is blocked on resource */
    <a name="VIR_VCPU_LAST">VIR_VCPU_LAST</a> = 3
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventAgentLifecycleCallback"/>Function type virConnectDomainEventAgentLifecycleCallback</h3><pre class="programlisting">void	virConnectDomainEventAgentLifecycleCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int state, <br/>							 int reason, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when libvirt detects a change in the state of a guest
agent.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>state</tt></i>:</span></td><td>new state of the guest agent, one of <a href="libvirt-libvirt-domain.html#virConnectDomainEventAgentLifecycleState">virConnectDomainEventAgentLifecycleState</a></td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason for state change; one of <a href="libvirt-libvirt-domain.html#virConnectDomainEventAgentLifecycleReason">virConnectDomainEventAgentLifecycleReason</a></td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBalloonChangeCallback"/>Function type virConnectDomainEventBalloonChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventBalloonChangeCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 unsigned long long actual, <br/>							 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>actual</tt></i>:</span></td><td>the new balloon level measured in kibibytes(blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBlockJobCallback"/>Function type virConnectDomainEventBlockJobCallback</h3><pre class="programlisting">void	virConnectDomainEventBlockJobCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * disk, <br/>						 int type, <br/>						 int status, <br/>						 void * opaque)<br/>
</pre><p>The string returned for @disk can be used in any of the libvirt API
that operate on a particular disk of the domain, and depends on what
event type was registered with virConnectDomainEventRegisterAny().
If the callback was registered using the older type of
VIR_DOMAIN_EVENT_ID_BLOCK_JOB, then @disk contains the absolute file
name of the host resource for the active layer of the disk; however,
this name is unstable (pivoting via block copy or active block commit
will change which file is active, giving a different name for the two
events associated with the same job) and cannot be relied on if the
active layer is associated with a network resource. If the callback
was registered using the newer type of VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2,
then @disk will contain the device target shorthand (the &lt;target
dev='...'/&gt; sub-element, such as "vda").</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>name associated with the affected disk (filename or target device, depending on how the callback was registered)</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of block job (virDomainBlockJobType)</td></tr><tr><td><span class="term"><i><tt>status</tt></i>:</span></td><td>status of the operation (virConnectDomainEventBlockJobStatus)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventBlockThresholdCallback"/>Function type virConnectDomainEventBlockThresholdCallback</h3><pre class="programlisting">void	virConnectDomainEventBlockThresholdCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * dev, <br/>							 const char * path, <br/>							 unsigned long long threshold, <br/>							 unsigned long long excess, <br/>							 void * opaque)<br/>
</pre><p>The callback occurs when the hypervisor detects that the given storage
element was written beyond the point specified by @threshold. The excess
data size written beyond @threshold is reported by @excess (if supported
by the hypervisor, 0 otherwise). The event is useful for thin-provisioned
storage.

The threshold size can be set via the <a href="libvirt-libvirt-domain.html#virDomainSetBlockThreshold">virDomainSetBlockThreshold</a> API.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>name associated with the affected disk or storage backing chain element</td></tr><tr><td><span class="term"><i><tt>path</tt></i>:</span></td><td>for local storage, the path of the backing chain element</td></tr><tr><td><span class="term"><i><tt>threshold</tt></i>:</span></td><td>threshold offset in bytes</td></tr><tr><td><span class="term"><i><tt>excess</tt></i>:</span></td><td>number of bytes written beyond the threshold</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventCallback"/>Function type virConnectDomainEventCallback</h3><pre class="programlisting">int	virConnectDomainEventCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 int event, <br/>					 int detail, <br/>					 void * opaque)<br/>
</pre><p>A callback function to be registered, and called when a domain event occurs</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td><a href="libvirt-libvirt-host.html#virConnect">virConnect</a> connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>The domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>The specific <a href="libvirt-libvirt-domain.html#virDomainEventType">virDomainEventType</a> which occurred</td></tr><tr><td><span class="term"><i><tt>detail</tt></i>:</span></td><td>event specific detail information</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque user data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 (the return value is currently ignored)</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeviceAddedCallback"/>Function type virConnectDomainEventDeviceAddedCallback</h3><pre class="programlisting">void	virConnectDomainEventDeviceAddedCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when a device is added to the domain.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_ADDED with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeviceRemovalFailedCallback"/>Function type virConnectDomainEventDeviceRemovalFailedCallback</h3><pre class="programlisting">void	virConnectDomainEventDeviceRemovalFailedCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when it's certain that removal of a device failed.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED with
virConnectDomainEventRegisterAny().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeviceRemovedCallback"/>Function type virConnectDomainEventDeviceRemovedCallback</h3><pre class="programlisting">void	virConnectDomainEventDeviceRemovedCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * devAlias, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when a device is removed from the domain.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDiskChangeCallback"/>Function type virConnectDomainEventDiskChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventDiskChangeCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * oldSrcPath, <br/>						 const char * newSrcPath, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when disk gets changed. However,
not all @reason will cause both @oldSrcPath and @newSrcPath
to be non-NULL. Please see virConnectDomainEventDiskChangeReason
for more details.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_DISK_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>oldSrcPath</tt></i>:</span></td><td>old source path</td></tr><tr><td><span class="term"><i><tt>newSrcPath</tt></i>:</span></td><td>new source path</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias name</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why this callback was called; any of <a href="libvirt-libvirt-domain.html#virConnectDomainEventDiskChangeReason">virConnectDomainEventDiskChangeReason</a></td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventGenericCallback"/>Function type virConnectDomainEventGenericCallback</h3><pre class="programlisting">void	virConnectDomainEventGenericCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 void * opaque)<br/>
</pre><p>A generic domain event callback handler, for use with
virConnectDomainEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use VIR_DOMAIN_EVENT_CALLBACK()
when registering an appropriate handler.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection pointer</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>the domain pointer</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventGraphicsCallback"/>Function type virConnectDomainEventGraphicsCallback</h3><pre class="programlisting">void	virConnectDomainEventGraphicsCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int phase, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * local, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsAddress">virDomainEventGraphicsAddress</a> * remote, <br/>						 const char * authScheme, <br/>						 const <a href="libvirt-libvirt-domain.html#virDomainEventGraphicsSubject">virDomainEventGraphicsSubject</a> * subject, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>phase</tt></i>:</span></td><td>the phase of the connection</td></tr><tr><td><span class="term"><i><tt>local</tt></i>:</span></td><td>the local server address</td></tr><tr><td><span class="term"><i><tt>remote</tt></i>:</span></td><td>the remote client address</td></tr><tr><td><span class="term"><i><tt>authScheme</tt></i>:</span></td><td>the authentication scheme activated</td></tr><tr><td><span class="term"><i><tt>subject</tt></i>:</span></td><td>the authenticated subject (user)</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventIOErrorCallback"/>Function type virConnectDomainEventIOErrorCallback</h3><pre class="programlisting">void	virConnectDomainEventIOErrorCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * srcPath, <br/>						 const char * devAlias, <br/>						 int action, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventIOErrorReasonCallback"/>Function type virConnectDomainEventIOErrorReasonCallback</h3><pre class="programlisting">void	virConnectDomainEventIOErrorReasonCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 const char * srcPath, <br/>							 const char * devAlias, <br/>							 int action, <br/>							 const char * reason, <br/>							 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON with virConnectDomainEventRegisterAny()

If the I/O error is known to be caused by an ENOSPC condition in
the host (where resizing the disk to be larger will allow the guest
to be resumed as if nothing happened), @reason will be "enospc".
Otherwise, @reason will be "", although future strings may be added
if determination of other error types becomes possible.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>srcPath</tt></i>:</span></td><td>The host file on which the IO error occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>The guest device alias associated with the path</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to the IO error</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>the cause of the IO error</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventJobCompletedCallback"/>Function type virConnectDomainEventJobCompletedCallback</h3><pre class="programlisting">void	virConnectDomainEventJobCompletedCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>							 int nparams, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when a job (such as migration) running on the domain
is completed. The params array will contain statistics of the just completed
job as <a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> would return. The callback must not free @params
(the array will be freed once the callback finishes).

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_JOB_COMPLETED with
virConnectDomainEventRegisterAny().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>job statistics stored as an array of <a href="libvirt-libvirt-common.html#virTypedParameter">virTypedParameter</a></td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>size of the params array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specific data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventMetadataChangeCallback"/>Function type virConnectDomainEventMetadataChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventMetadataChangeCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int type, <br/>							 const char * nsuri, <br/>							 void * opaque)<br/>
</pre><p>This callback is triggered when the domain XML metadata is changed

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_METADATA_CHANGE with virConnectDomainEventRegisterAny().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>a value from virDomainMetadataTypea</td></tr><tr><td><span class="term"><i><tt>nsuri</tt></i>:</span></td><td>XML namespace URI</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventMigrationIterationCallback"/>Function type virConnectDomainEventMigrationIterationCallback</h3><pre class="programlisting">void	virConnectDomainEventMigrationIterationCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int iteration, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs during live migration when a new iteration over
domain's memory starts. The @iteration value is increased by one every
time a new iteration is started to transfer memory pages dirtied since
the last iteration.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION with
virConnectDomainEventRegisterAny().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>iteration</tt></i>:</span></td><td>current iteration over domain's memory</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specific data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMSuspendCallback"/>Function type virConnectDomainEventPMSuspendCallback</h3><pre class="programlisting">void	virConnectDomainEventPMSuspendCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the guest is suspended.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMSuspendDiskCallback"/>Function type virConnectDomainEventPMSuspendDiskCallback</h3><pre class="programlisting">void	virConnectDomainEventPMSuspendDiskCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>							 int reason, <br/>							 void * opaque)<br/>
</pre><p>This callback occurs when the guest is suspended to disk.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventPMWakeupCallback"/>Function type virConnectDomainEventPMWakeupCallback</h3><pre class="programlisting">void	virConnectDomainEventPMWakeupCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the guest is woken up.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_PMWAKEUP with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>reason why the callback was called, unused currently, always passes 0</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRTCChangeCallback"/>Function type virConnectDomainEventRTCChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventRTCChangeCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 long long utcoffset, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>utcoffset</tt></i>:</span></td><td>the new RTC offset from UTC, measured in seconds</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventTrayChangeCallback"/>Function type virConnectDomainEventTrayChangeCallback</h3><pre class="programlisting">void	virConnectDomainEventTrayChangeCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 const char * devAlias, <br/>						 int reason, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when the tray of a removable device is moved.

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_TRAY_CHANGE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>devAlias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>why the tray status was changed?</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventTunableCallback"/>Function type virConnectDomainEventTunableCallback</h3><pre class="programlisting">void	virConnectDomainEventTunableCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 void * opaque)<br/>
</pre><p>This callback occurs when tunable values are updated. The params must not
be freed in the callback handler as it's done internally after the callback
handler is executed.

Currently supported name spaces:
 "cputune.*"
 "blkdeviotune.*"

The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_TUNABLE with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>changed tunable values stored as array of <a href="libvirt-libvirt-common.html#virTypedParameter">virTypedParameter</a></td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventWatchdogCallback"/>Function type virConnectDomainEventWatchdogCallback</h3><pre class="programlisting">void	virConnectDomainEventWatchdogCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int action, <br/>						 void * opaque)<br/>
</pre><p>The callback signature to use when registering for an event of type
VIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain on which the event occurred</td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>action that is to be taken due to watchdog firing</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeregister"/>virConnectDomainEventDeregister ()</h3><pre class="programlisting">int	virConnectDomainEventDeregister	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb)<br/>
</pre><p>Removes a callback previously registered with the
virConnectDomainEventRegister() function.

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventDeregisterAny() which has a more flexible
API contract</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure. Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventDeregisterAny"/>virConnectDomainEventDeregisterAny ()</h3><pre class="programlisting">int	virConnectDomainEventDeregisterAny	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID)<br/>
</pre><p>Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectDomainEventRegisterAny() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>callbackID</tt></i>:</span></td><td>the callback identifier</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure. Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRegister"/>virConnectDomainEventRegister ()</h3><pre class="programlisting">int	virConnectDomainEventRegister	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virConnectDomainEventCallback">virConnectDomainEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Adds a callback to receive notifications of domain lifecycle events
occurring on a connection. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

Use of this method is no longer recommended. Instead applications
should try virConnectDomainEventRegisterAny() which has a more flexible
API contract.

The <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef.
The reference can be released once the object is no longer required
by calling virDomainFree.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure. Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainEventRegisterAny"/>virConnectDomainEventRegisterAny ()</h3><pre class="programlisting">int	virConnectDomainEventRegisterAny	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt-domain.html#virConnectDomainEventGenericCallback">virConnectDomainEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Adds a callback to receive notifications of arbitrary domain events
occurring on a domain. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @dom is NULL, then events will be monitored for any domain. If @dom
is non-NULL, then only the specific domain will be monitored.

Most types of event have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer
to match the signature of this method.

The <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the domain object after the callback returns,
it shall take a reference to it, by calling virDomainRef().
The reference can be released once the object is no longer required
by calling virDomainFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectDomainEventDeregisterAny() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>eventID</tt></i>:</span></td><td>the event type to receive</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling domain events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a callback identifier on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainXMLFromNative"/>virConnectDomainXMLFromNative ()</h3><pre class="programlisting">char *	virConnectDomainXMLFromNative	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * nativeConfig, <br/>					 unsigned int flags)<br/>
</pre><p>Reads native configuration data describing a domain, and
generates libvirt domain XML. The format of the native
data is hypervisor dependent.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format importing from</td></tr><tr><td><span class="term"><i><tt>nativeConfig</tt></i>:</span></td><td>the configuration data to import</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectDomainXMLToNative"/>virConnectDomainXMLToNative ()</h3><pre class="programlisting">char *	virConnectDomainXMLToNative	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * nativeFormat, <br/>					 const char * domainXml, <br/>					 unsigned int flags)<br/>
</pre><p>Reads a domain XML configuration document, and generates
a native configuration file describing the domain.
The format of the native data is hypervisor dependent.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>a connection object</td></tr><tr><td><span class="term"><i><tt>nativeFormat</tt></i>:</span></td><td>configuration format exporting to</td></tr><tr><td><span class="term"><i><tt>domainXml</tt></i>:</span></td><td>the domain configuration to export</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetAllDomainStats"/>virConnectGetAllDomainStats ()</h3><pre class="programlisting">int	virConnectGetAllDomainStats	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int stats, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> ** retStats, <br/>					 unsigned int flags)<br/>
</pre><p>Query statistics for all domains on a given connection.

Report statistics of various parameters for a running VM according to @stats
field. The statistics are returned as an array of structures for each queried
domain. The structure contains an array of typed parameters containing the
individual statistics. The typed parameter name for each statistic field
consists of a dot-separated string containing name of the requested group
followed by a group specific description of the statistic value.

The statistic groups are enabled using the @stats parameter which is a
binary-OR of enum virDomainStatsTypes. The following groups are available
(although not necessarily implemented for each hypervisor):

VIR_DOMAIN_STATS_STATE:
 Return domain state and reason for entering that state. The typed
 parameter keys are in this format:

 "state.state" - state of the VM, returned as int from <a href="libvirt-libvirt-domain.html#virDomainState">virDomainState</a> enum
 "state.reason" - reason for entering given state, returned as int from
 virDomain*Reason enum corresponding to given state.

VIR_DOMAIN_STATS_CPU_TOTAL:
 Return CPU statistics and usage information. The typed parameter keys
 are in this format:

 "cpu.time" - total cpu time spent for this domain in nanoseconds
 as unsigned long long.
 "cpu.user" - user cpu time spent in nanoseconds as unsigned long long.
 "cpu.system" - system cpu time spent in nanoseconds as unsigned long
 long.
 "cpu.cache.monitor.count" - the number of cache monitors for this domain
 "cpu.cache.monitor.&lt;num&gt;.name" - the name of cache monitor &lt;num&gt;
 "cpu.cache.monitor.&lt;num&gt;.vcpus" - vcpu list of cache monitor &lt;num&gt;
 "cpu.cache.monitor.&lt;num&gt;.bank.count" - the number of cache banks in
 cache monitor &lt;num&gt;
 "cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.id" - host allocated cache id for
 bank &lt;index&gt; in cache
 monitor &lt;num&gt;
 "cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.bytes" - the number of bytes of
 last level cache that the
 domain is using on cache
 bank &lt;index&gt;

VIR_DOMAIN_STATS_BALLOON:
 Return memory balloon device information.
 The typed parameter keys are in this format:

 "balloon.current" - the memory in kiB currently used
 as unsigned long long.
 "balloon.maximum" - the maximum memory in kiB allowed
 as unsigned long long.

VIR_DOMAIN_STATS_VCPU:
 Return virtual CPU statistics.
 Due to VCPU hotplug, the vcpu.&lt;num&gt;.* array could be sparse.
 The actual size of the array corresponds to "vcpu.current".
 The array size will never exceed "vcpu.maximum".
 The typed parameter keys are in this format:

 "vcpu.current" - current number of online virtual CPUs as unsigned int.
 "vcpu.maximum" - maximum number of online virtual CPUs as unsigned int.
 "vcpu.&lt;num&gt;.state" - state of the virtual CPU &lt;num&gt;, as int
 from <a href="libvirt-libvirt-domain.html#virVcpuState">virVcpuState</a> enum.
 "vcpu.&lt;num&gt;.time" - virtual cpu time spent by virtual CPU &lt;num&gt;
 as unsigned long long.

VIR_DOMAIN_STATS_INTERFACE:
 Return network interface statistics (from domain point of view).
 The typed parameter keys are in this format:

 "net.count" - number of network interfaces on this domain
 as unsigned int.
 "net.&lt;num&gt;.name" - name of the interface &lt;num&gt; as string.
 "net.&lt;num&gt;.rx.bytes" - bytes received as unsigned long long.
 "net.&lt;num&gt;.rx.pkts" - packets received as unsigned long long.
 "net.&lt;num&gt;.rx.errs" - receive errors as unsigned long long.
 "net.&lt;num&gt;.rx.drop" - receive packets dropped as unsigned long long.
 "net.&lt;num&gt;.tx.bytes" - bytes transmitted as unsigned long long.
 "net.&lt;num&gt;.tx.pkts" - packets transmitted as unsigned long long.
 "net.&lt;num&gt;.tx.errs" - transmission errors as unsigned long long.
 "net.&lt;num&gt;.tx.drop" - transmit packets dropped as unsigned long long.

VIR_DOMAIN_STATS_BLOCK:
 Return block devices statistics. By default,
 this information is limited to the active layer of each &lt;disk&gt; of the
 domain (where block.count is equal to the number of disks), but adding
 <a href="libvirt-libvirt-domain.html#VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING">VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING</a> to @flags will expand the
 array to cover backing chains (block.count corresponds to the number
 of host resources used together to provide the guest disks).
 The typed parameter keys are in this format:

 "block.count" - number of block devices in the subsequent list,
 as unsigned int.
 "block.&lt;num&gt;.name" - name of the block device &lt;num&gt; as string.
 matches the target name (vda/sda/hda) of the
 block device. If the backing chain is listed,
 this name is the same for all host resources tied
 to the same guest device.
 "block.&lt;num&gt;.backingIndex" - unsigned int giving the &lt;backingStore&gt;
 index, only used when backing images
 are listed.
 "block.&lt;num&gt;.path" - string describing the source of block device &lt;num&gt;,
 if it is a file or block device (omitted for network
 sources and drives with no media inserted).
 "block.&lt;num&gt;.rd.reqs" - number of read requests as unsigned long long.
 "block.&lt;num&gt;.rd.bytes" - number of read bytes as unsigned long long.
 "block.&lt;num&gt;.rd.times" - total time (ns) spent on reads as
 unsigned long long.
 "block.&lt;num&gt;.wr.reqs" - number of write requests as unsigned long long.
 "block.&lt;num&gt;.wr.bytes" - number of written bytes as unsigned long long.
 "block.&lt;num&gt;.wr.times" - total time (ns) spent on writes as
 unsigned long long.
 "block.&lt;num&gt;.fl.reqs" - total flush requests as unsigned long long.
 "block.&lt;num&gt;.fl.times" - total time (ns) spent on cache flushing as
 unsigned long long.
 "block.&lt;num&gt;.errors" - Xen only: the 'oo_req' value as
 unsigned long long.
 "block.&lt;num&gt;.allocation" - offset of the highest written sector
 as unsigned long long.
 "block.&lt;num&gt;.capacity" - logical size in bytes of the block device
 backing image as unsigned long long.
 "block.&lt;num&gt;.physical" - physical size in bytes of the container of the
 backing image as unsigned long long.
 "block.&lt;num&gt;.threshold" - current threshold for delivering the
 VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD
 event in bytes. See virDomainSetBlockThreshold.

VIR_DOMAIN_STATS_PERF:
 Return perf event statistics.
 The typed parameter keys are in this format:

 "perf.cmt" - the usage of l3 cache (bytes) by applications running on
 the platform as unsigned long long. It is produced by cmt
 perf event.
 "perf.mbmt" - the total system bandwidth (bytes/s) from one level of
 cache to another as unsigned long long. It is produced
 by mbmt perf event.
 "perf.mbml" - the amount of data (bytes/s) sent through the memory
 controller on the socket as unsigned long long. It is
 produced by mbml perf event.
 "perf.cache_misses" - the count of cache misses as unsigned long long.
 It is produced by cache_misses perf event.
 "perf.cache_references" - the count of cache hits as unsigned long long.
 It is produced by cache_references perf event.
 "perf.instructions" - The count of instructions as unsigned long long.
 It is produced by instructions perf event.
 "perf.cpu_cycles" - The count of cpu cycles (total/elapsed) as an
 unsigned long long. It is produced by cpu_cycles
 perf event.
 "perf.branch_instructions" - The count of branch instructions as
 unsigned long long. It is produced by
 branch_instructions perf event.
 "perf.branch_misses" - The count of branch misses as unsigned long
 long. It is produced by branch_misses perf event.
 "perf.bus_cycles" - The count of bus cycles as unsigned long
 long. It is produced by bus_cycles perf event.
 "perf.stalled_cycles_frontend" - The count of stalled cpu cycles in the
 frontend of the instruction processor
 pipeline as unsigned long long. It is
 produced by stalled_cycles_frontend
 perf event.
 "perf.stalled_cycles_backend" - The count of stalled cpu cycles in the
 backend of the instruction processor
 pipeline as unsigned long long. It is
 produced by stalled_cycles_backend
 perf event.
 "perf.ref_cpu_cycles" - The count of total cpu cycles not affected by
 CPU frequency scaling by applications running
 as unsigned long long. It is produced by the
 ref_cpu_cycles perf event.
 "perf.cpu_clock" - The count of cpu clock time as unsigned long long.
 It is produced by the cpu_clock perf event.
 "perf.task_clock" - The count of task clock time as unsigned long long.
 It is produced by the task_clock perf event.
 "perf.page_faults" - The count of page faults as unsigned long long.
 It is produced by the page_faults perf event
 "perf.context_switches" - The count of context switches as unsigned long
 long. It is produced by the context_switches
 perf event.
 "perf.cpu_migrations" - The count of cpu migrations, from one logical
 processor to another, as unsigned long
 long. It is produced by the cpu_migrations
 perf event.
 "perf.page_faults_min" - The count of minor page faults as unsigned
 long long. It is produced by the
 page_faults_min perf event.
 "perf.page_faults_maj" - The count of major page faults as unsigned
 long long. It is produced by the
 page_faults_maj perf event.
 "perf.alignment_faults" - The count of alignment faults as unsigned
 long long. It is produced by the
 alignment_faults perf event
 "perf.emulation_faults" - The count of emulation faults as unsigned
 long long. It is produced by the
 emulation_faults perf event

VIR_DOMAIN_STATS_IOTHREAD:
 Return IOThread statistics if available. IOThread polling is a
 timing mechanism that allows the hypervisor to generate a longer
 period of time in which the guest will perform operations on the
 CPU being used by the IOThread. The higher the value for poll-max-ns
 the longer the guest will keep the CPU. This may affect other host
 threads using the CPU. The poll-grow and poll-shrink values allow
 the hypervisor to generate a mechanism to add or remove polling time
 within the confines of 0 and poll-max-ns. For QEMU, the poll-grow is
 multiplied by the polling interval, while poll-shrink is used as a
 divisor. When not provided, QEMU may double the polling time until
 poll-max-ns is reached. When poll-shrink is 0 (zero) QEMU may reset
 the polling interval to 0 until it finds its "sweet spot". Setting
 poll-grow too large may cause frequent fluctuation of the time; however,
 this can be tempered by a high poll-shrink to reduce the polling
 interval. For example, a poll-grow of 3 will triple the polling time
 which could quickly exceed poll-max-ns; however, a poll-shrink of
 10 would cut that polling time more gradually.

 The typed parameter keys are in this format:

 "iothread.cnt" - maximum number of IOThreads in the subsequent list
 as unsigned int. Each IOThread in the list will
 will use it's iothread_id value as the &lt;id&gt;. There
 may be fewer &lt;id&gt; entries than the iothread.cnt
 value if the polling values are not supported.
 "iothread.&lt;id&gt;.poll-max-ns" - maximum polling time in ns as an unsigned
 long long. A 0 (zero) means polling is
 disabled.
 "iothread.&lt;id&gt;.poll-grow" - polling time factor as an unsigned int.
 A 0 (zero) indicates to allow the underlying
 hypervisor to choose how to grow the
 polling time.
 "iothread.&lt;id&gt;.poll-shrink" - polling time divisor as an unsigned int.
 A 0 (zero) indicates to allow the underlying
 hypervisor to choose how to shrink the
 polling time.

Note that entire stats groups or individual stat fields may be missing from
the output in case they are not supported by the given hypervisor, are not
applicable for the current state of the guest domain, or their retrieval
was not successful.

Using 0 for @stats returns all stats groups supported by the given
hypervisor.

Specifying <a href="libvirt-libvirt-domain.html#VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS">VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS</a> as @flags makes
the function return error in case some of the stat types in @stats were
not recognized by the daemon. However, even with this flag, a hypervisor
may omit individual fields within a known group if the information is not
available; as an extreme example, a supported group may produce zero
fields for offline domains if the statistics are meaningful only for a
running domain.

Passing <a href="libvirt-libvirt-domain.html#VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT">VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT</a> in
@flags means when libvirt is unable to fetch stats for any of
the domains (for whatever reason) only a subset of statistics
is returned for the domain. That subset being statistics that
don't involve querying the underlying hypervisor.

Similarly to virConnectListAllDomains, @flags can contain various flags to
filter the list of domains to provide stats for.

VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE selects online domains while
VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE selects offline ones.

VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT and
VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT allow to filter the list
according to their persistence.

To filter the list of VMs by domain state @flags can contain
VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING,
VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED,
VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF and/or
VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER for all other states.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>stats to return, binary-OR of <a href="libvirt-libvirt-domain.html#virDomainStatsTypes">virDomainStatsTypes</a></td></tr><tr><td><span class="term"><i><tt>retStats</tt></i>:</span></td><td>Pointer that will be filled with the array of returned stats</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; binary-OR of <a href="libvirt-libvirt-domain.html#virConnectGetAllDomainStatsFlags">virConnectGetAllDomainStatsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectGetDomainCapabilities"/>virConnectGetDomainCapabilities ()</h3><pre class="programlisting">char *	virConnectGetDomainCapabilities	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * emulatorbin, <br/>					 const char * arch, <br/>					 const char * machine, <br/>					 const char * virttype, <br/>					 unsigned int flags)<br/>
</pre><p>Prior creating a domain (for instance via virDomainCreateXML
or virDomainDefineXML) it may be suitable to know what the
underlying emulator and/or libvirt is capable of. For
instance, if host, libvirt and qemu is capable of VFIO
passthrough and so on.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>emulatorbin</tt></i>:</span></td><td>path to emulator</td></tr><tr><td><span class="term"><i><tt>arch</tt></i>:</span></td><td>domain architecture</td></tr><tr><td><span class="term"><i><tt>machine</tt></i>:</span></td><td>machine type</td></tr><tr><td><span class="term"><i><tt>virttype</tt></i>:</span></td><td>virtualization type</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error or an XML string defining the capabilities.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllDomains"/>virConnectListAllDomains ()</h3><pre class="programlisting">int	virConnectListAllDomains	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> ** domains, <br/>					 unsigned int flags)<br/>
</pre><p>Collect a possibly-filtered list of all domains, and return an allocated
array of information for each. This API solves the race inherent in
virConnectListDomains() and virConnectListDefinedDomains().

Normally, all domains are returned; however, @flags can be used to
filter the results for a smaller list of targeted domains. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a domain, and where all bits
within a group describe all possible domains. Some hypervisors might
reject explicit bits from a group where the hypervisor cannot make a
distinction (for example, not all hypervisors can tell whether domains
have snapshots). For a group supported by a given hypervisor, the
behavior when no bits of a group are set is identical to the behavior
when all bits in that group are set. When setting bits from more than
one group, it is possible to select an impossible combination (such
as an inactive transient domain), in that case a hypervisor may return
either 0 or an error.

The first group of @flags is <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_ACTIVE">VIR_CONNECT_LIST_DOMAINS_ACTIVE</a> (online
domains) and <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_INACTIVE">VIR_CONNECT_LIST_DOMAINS_INACTIVE</a> (offline domains).

The next group of @flags is <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_PERSISTENT">VIR_CONNECT_LIST_DOMAINS_PERSISTENT</a> (defined
domains) and <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_TRANSIENT">VIR_CONNECT_LIST_DOMAINS_TRANSIENT</a> (running but not defined).

The next group of @flags covers various domain states:
VIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,
VIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states
(such as crashed, this catch-all covers the possibility of adding new
states).

The remaining groups cover boolean attributes commonly asked about
domains; they include <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE">VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE</a> and
VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether
a managed save image exists; <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_AUTOSTART">VIR_CONNECT_LIST_DOMAINS_AUTOSTART</a> and
VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;
VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and
VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether
a domain has snapshots; <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT">VIR_CONNECT_LIST_DOMAINS_HAS_CHECKPOINT</a> and
VIR_CONNECT_LIST_DOMAINS_NO_CHECKPOINT, for filtering based on whether
a domain has checkpoints.

Example of usage:

 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> *domains;
 size_t i;
 int ret;
 unsigned int flags = <a href="libvirt-libvirt-domain.html#VIR_CONNECT_LIST_DOMAINS_RUNNING">VIR_CONNECT_LIST_DOMAINS_RUNNING</a> |
 VIR_CONNECT_LIST_DOMAINS_PERSISTENT;
 ret = virConnectListAllDomains(conn, &amp;domains, flags);
 if (ret &lt; 0)
 error();
 for (i = 0; i &lt; ret; i++) {
 do_something_with_domain(domains[i]);
 //here or in a separate loop if needed
 virDomainFree(domains[i]);
 }
 free(domains);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>domains</tt></i>:</span></td><td>Pointer to a variable to store the array containing domain objects or NULL if the list is not required (just returns number of guests).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virConnectListAllDomainsFlags">virConnectListAllDomainsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domains found or -1 and sets domains to NULL in case of error. On success, the array stored into @domains is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainFree() on each array element, then calling free() on @domains.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDefinedDomains"/>virConnectListDefinedDomains ()</h3><pre class="programlisting">int	virConnectListDefinedDomains	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>list the defined but inactive domains, stores the pointers to the names
in @names

For active domains, see virConnectListDomains(). For more control over
the results, see virConnectListAllDomains().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>pointer to an array to store the names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a domain can be defined between a call to virConnectNumOfDefinedDomains() and this call; you are only guaranteed that all currently defined domains were listed if the return is less than @maxids. The client must call free() on each returned name.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListDomains"/>virConnectListDomains ()</h3><pre class="programlisting">int	virConnectListDomains		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int * ids, <br/>					 int maxids)<br/>
</pre><p>Collect the list of active domains, and store their IDs in array @ids

For inactive domains, see virConnectListDefinedDomains(). For more
control over the results, see virConnectListAllDomains().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>ids</tt></i>:</span></td><td>array to collect the list of IDs of active domains</td></tr><tr><td><span class="term"><i><tt>maxids</tt></i>:</span></td><td>size of @ids</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domains found or -1 in case of error. Note that this command is inherently racy; a domain can be started between a call to virConnectNumOfDomains() and this call; you are only guaranteed that all currently active domains were listed if the return is less than @maxids.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDefinedDomains"/>virConnectNumOfDefinedDomains ()</h3><pre class="programlisting">int	virConnectNumOfDefinedDomains	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of defined but inactive domains.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNumOfDomains"/>virConnectNumOfDomains ()</h3><pre class="programlisting">int	virConnectNumOfDomains		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn)<br/>
</pre><p>Provides the number of active domains.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of domain found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAbortJob"/>virDomainAbortJob ()</h3><pre class="programlisting">int	virDomainAbortJob		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Requests that the current background job be aborted at the
soonest opportunity. In case the job is a migration in a post-copy mode,
virDomainAbortJob will report an error (see virDomainMigrateStartPostCopy
for more details).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAddIOThread"/>virDomainAddIOThread ()</h3><pre class="programlisting">int	virDomainAddIOThread		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically add an IOThread to the domain. It is left up to the
underlying virtual hypervisor to determine the valid range for an
@iothread_id and determining whether the @iothread_id already exists.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function requires privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>iothread_id</tt></i>:</span></td><td>the specific IOThread ID value to add</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAttachDevice"/>virDomainAttachDevice ()</h3><pre class="programlisting">int	virDomainAttachDevice		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml)<br/>
</pre><p>Create a virtual device attachment to backend. This function,
having hotplug semantics, is only allowed on an active domain.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainAttachDeviceFlags"/>virDomainAttachDeviceFlags ()</h3><pre class="programlisting">int	virDomainAttachDeviceFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Attach a virtual device to a domain, using the flags parameter
to control how the device is attached. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is made based on current domain
state. <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
allocated to the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be allocated to the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

For compatibility, this method can also be used to change the media
in an existing CDROM/Floppy device, however, applications are
recommended to use the virDomainUpdateDeviceFlag method instead.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCommit"/>virDomainBlockCommit ()</h3><pre class="programlisting">int	virDomainBlockCommit		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 const char * top, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Commit changes that were made to temporary top-level files within a disk
image backing file chain into a lower-level base file. In other words,
take all the difference between @base and @top, and update @base to contain
that difference; after the commit, any portion of the chain that previously
depended on @top will now depend on @base, and all files after @base up
to and including @top will now be invalidated. A typical use of this
command is to reduce the length of a backing file chain after taking an
external disk snapshot. To move data in the opposite direction, see
virDomainBlockPull().

This command starts a long-running commit block job, whose status may
be tracked by virDomainBlockJobInfo() with a job type of
VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with
virDomainBlockJobAbort(). When finished, an asynchronous event is
raised to indicate the final status, and the job no longer exists. If
the job is aborted, it is up to the hypervisor whether starting a new
job will resume from the same point, or start over.

As a special case, if @top is the active image (or NULL), and @flags
includes VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, the block job will have a type
of VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT, and operates in two phases.
In the first phase, the contents are being committed into @base, and the
job can only be canceled. The job transitions to the second phase when
the block job event with state <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_JOB_READY">VIR_DOMAIN_BLOCK_JOB_READY</a> is
emitted for the given device. This information is also visible in the
live XML as 'ready="yes"' attribute of the corresponding &lt;mirror&gt; element.
Once in the second phase, the user must choose whether to cancel the job
(keeping @top as the active image, but now containing only the changes
since the time the job ended) or to pivot the job (adjusting to @base as
the active image, and invalidating @top).

Be aware that this command may invalidate files even if it is aborted;
the user is cautioned against relying on the contents of invalidated
intermediate files such as @top (when @top is not the active image)
without manually rebasing those files to use a backing file of a
read-only copy of @base prior to the point where the commit operation
was started (and such a rebase cannot be safely done until the commit
has successfully completed). However, the domain itself will not have
any issues; the active layer remains valid throughout the entire commit
operation.

Some hypervisors may support a shortcut where if @flags contains
VIR_DOMAIN_BLOCK_COMMIT_DELETE, then this command will unlink all files
that were invalidated, after the commit successfully completes.

If @flags contains VIR_DOMAIN_BLOCK_COMMIT_RELATIVE, the name recorded
into the overlay of the @top image (if there is such image) as the
path to the new backing file will be kept relative to other images.
The operation will fail if libvirt can't infer the name.

By default, if @base is NULL, the commit target will be the bottom of
the backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,
then the immediate backing file of @top will be used instead. If @top
is NULL, the active image at the top of the chain will be used. Some
hypervisors place restrictions on how much can be committed, and might
fail if @base is not the immediate backing file of @top, or if @top is
the active layer in use by a running domain but @flags did not include
VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, or if @top is not the top-most file;
restrictions may differ for online vs. offline domains.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @base and @top parameters can be either paths to files within the
backing chain, or the device target shorthand (the &lt;target dev='...'/&gt;
sub-element, such as "vda") followed by an index to the backing chain
enclosed in square brackets. Backing chain indexes can be found by
inspecting //disk//backingStore/@index in the domain XML. Thus, for
example, "vda[3]" refers to the backing store with index equal to "3"
in the chain of disk "vda".

The maximum bandwidth that will be used to do the commit can be
specified with the @bandwidth parameter. If set to 0, there is no
limit. If @flags includes VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed. The actual speed can be determined with
virDomainGetBlockJobInfo().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>base</tt></i>:</span></td><td>path to backing file to merge into, or device shorthand, or NULL for default</td></tr><tr><td><span class="term"><i><tt>top</tt></i>:</span></td><td>path to file within backing chain that contains data to be merged, or device shorthand, or NULL to merge all possible data</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify bandwidth limit; flags determine the unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockCommitFlags">virDomainBlockCommitFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockCopy"/>virDomainBlockCopy ()</h3><pre class="programlisting">int	virDomainBlockCopy		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * destxml, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Copy the guest-visible contents of a disk image to a new file described
by @destxml. The destination XML has a top-level element of &lt;disk&gt;, and
resembles what is used when hot-plugging a disk via virDomainAttachDevice(),
except that only sub-elements related to describing the new host resource
are necessary (sub-elements related to the guest view, such as &lt;target&gt;,
are ignored). It is strongly recommended to include a &lt;driver type='...'/&gt;
format designation for the destination, to avoid the potential of any
security problem that might be caused by probing a file for its format.

This command starts a long-running copy. By default, the copy will pull
the entire source chain into the destination file, but if @flags also
contains VIR_DOMAIN_BLOCK_COPY_SHALLOW, then only the top of the source
chain will be copied (the source and destination have a common backing
file). The format of the destination file is controlled by the &lt;driver&gt;
sub-element of the XML. The destination will be created unless the
VIR_DOMAIN_BLOCK_COPY_REUSE_EXT flag is present stating that the file
was pre-created with the correct format and metadata and sufficient
size to hold the copy. In case the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_COPY_SHALLOW">VIR_DOMAIN_BLOCK_COPY_SHALLOW</a> flag
is used the pre-created file has to exhibit the same guest visible contents
as the backing file of the original image. This allows a management app to
pre-create files with relative backing file names, rather than the default
of absolute backing file names.

A copy job has two parts; in the first phase, the source is copied into
the destination, and the job can only be canceled by reverting to the
source file; progress in this phase can be tracked via the
virDomainBlockJobInfo() command, with a job type of
VIR_DOMAIN_BLOCK_JOB_TYPE_COPY. The job transitions to the second
phase when the block job event with state <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_JOB_READY">VIR_DOMAIN_BLOCK_JOB_READY</a> is
emitted for the given device. This information is also visible in the
live XML as 'ready="yes"' attribute of the corresponding &lt;mirror&gt; element.
All further changes are saved to both source and destination. The user must
call virDomainBlockJobAbort() to end the mirroring while choosing
whether to revert to source or pivot to the destination. An event is
issued when the job ends, and depending on the hypervisor, an event may
also be issued when the job transitions from pulling to mirroring. If
the job is aborted, a new job will have to start over from the beginning
of the first phase.

Some hypervisors will restrict certain actions, such as virDomainSave()
or virDomainDetachDevice(), while a copy job is active; they may
also restrict a copy job to transient domains.

If @flags contains <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB">VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB</a> the job will not be
recoverable if the VM is turned off while job is active. This flag will
remove the restriction of copy jobs to transient domains. Note that this flag
is automatically implied if the VM is transient at the time it's started.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @params and @nparams arguments can be used to set hypervisor-specific
tuning parameters, such as maximum bandwidth or granularity. For a
parameter that the hypervisor understands, explicitly specifying 0
behaves the same as omitting the parameter, to use the hypervisor
default; however, omitting a parameter is less likely to fail.

This command is a superset of the older virDomainBlockRebase() when used
with the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_REBASE_COPY">VIR_DOMAIN_BLOCK_REBASE_COPY</a> flag, and offers better control
over the destination format, the ability to copy to a destination that
is not a local file, and the possibility of additional tuning parameters.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>destxml</tt></i>:</span></td><td>XML description of the copy destination</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>Pointer to block copy parameter objects, or NULL</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>Number of block copy parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockCopyFlags">virDomainBlockCopyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobAbort"/>virDomainBlockJobAbort ()</h3><pre class="programlisting">int	virDomainBlockJobAbort		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned int flags)<br/>
</pre><p>Cancel the active block job on the given disk.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then
by default, this function performs a synchronous operation and the caller
may assume that the operation has completed when 0 is returned. However,
BlockJob operations may take a long time to cancel, and during this time
further domain interactions may be unresponsive. To avoid this problem,
pass <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC">VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC</a> in the @flags argument to enable
asynchronous behavior, returning as soon as possible. When the job has
been canceled, a BlockJob event will be emitted, with status
VIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not
used); it is also possible to poll virDomainBlockJobInfo() to see if
the job cancellation is still pending. This type of job can be restarted
to pick up from where it left off.

If the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then
the default is to abort the mirroring and revert to the source disk;
likewise, if the current job is VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT,
the default is to abort without changing the active layer of @disk.
Adding @flags of <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT">VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT</a> causes this call to
fail with <a href="libvirt-virterror.html#VIR_ERR_BLOCK_COPY_ACTIVE">VIR_ERR_BLOCK_COPY_ACTIVE</a> if the copy or commit is not yet
ready; otherwise it will swap the disk over to the new active image
to end the mirroring or active commit. An event will be issued when the
job is ended, and it is possible to use VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC
to control whether this command waits for the completion of the job.
Restarting a copy or active commit job requires starting over from the
beginning of the first phase.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockJobAbortFlags">virDomainBlockJobAbortFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when successful.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockJobSetSpeed"/>virDomainBlockJobSetSpeed ()</h3><pre class="programlisting">int	virDomainBlockJobSetSpeed	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Set the maximimum allowable bandwidth that a block job may consume. If
bandwidth is 0, the limit will revert to the hypervisor default of
unlimited.

If @flags contains VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES, @bandwidth
is in bytes/second; otherwise, it is in MiB/second. Values larger than
2^52 bytes/sec may be rejected due to overflow considerations based on
the word size of both client and server, and values larger than 2^31
bytes/sec may cause overflow problems if later queried by
virDomainGetBlockJobInfo() without scaling. Hypervisors may further
restrict the range of valid bandwidth values.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>specify bandwidth limit; flags determine the unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockJobSetSpeedFlags">virDomainBlockJobSetSpeedFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when successful.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockPeek"/>virDomainBlockPeek ()</h3><pre class="programlisting">int	virDomainBlockPeek		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long offset, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags)<br/>
</pre><p>This function allows you to read the contents of a domain's
disk device.

Typical uses for this are to determine if the domain has
written a Master Boot Record (indicating that the domain
has completed installation), or to try to work out the state
of the domain's filesystems.

(Note that in the local case you might try to open the
block device or file directly, but that won't work in the
remote case, nor if you don't have sufficient permission.
Hence the need for this call).

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

'offset' and 'size' represent an area which must lie entirely
within the device or file. 'size' may be 0 to test if the
call would succeed.

'buffer' is the return buffer and must be at least 'size' bytes.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>offset</tt></i>:</span></td><td>offset within block device</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size to read</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockPull"/>virDomainBlockPull ()</h3><pre class="programlisting">int	virDomainBlockPull		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Populate a disk image with data from its backing image. Once all data from
its backing image has been pulled, the disk no longer depends on a backing
image. This function pulls data for the entire device in the background.
Progress of the operation can be checked with virDomainGetBlockJobInfo() and
the operation can be aborted with virDomainBlockJobAbort(). When finished,
an asynchronous event is raised to indicate the final status. To move
data in the opposite direction, see virDomainBlockCommit().

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The maximum bandwidth that will be used to do the copy can be
specified with the @bandwidth parameter. If set to 0, there is no
limit. If @flags includes VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed. The actual speed can be determined with
virDomainGetBlockJobInfo().

This is shorthand for virDomainBlockRebase() with a NULL base.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify bandwidth limit; flags determine the unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockPullFlags">virDomainBlockPullFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockRebase"/>virDomainBlockRebase ()</h3><pre class="programlisting">int	virDomainBlockRebase		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 const char * base, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Populate a disk image with data from its backing image chain, and
setting the backing image to @base, or alternatively copy an entire
backing chain to a new file @base.

When @flags is 0, this starts a pull, where @base must be the absolute
path of one of the backing images further up the chain, or NULL to
convert the disk image so that it has no backing image. Once all
data from its backing image chain has been pulled, the disk no
longer depends on those intermediate backing images. This function
pulls data for the entire device in the background. Progress of
the operation can be checked with virDomainGetBlockJobInfo() with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be
aborted with virDomainBlockJobAbort(). When finished, an asynchronous
event is raised to indicate the final status, and the job no longer
exists. If the job is aborted, a new one can be started later to
resume from the same point.

If @flags contains VIR_DOMAIN_BLOCK_REBASE_RELATIVE, the name recorded
into the active disk as the location for @base will be kept relative.
The operation will fail if libvirt can't infer the name.

When @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,
where @base must be the name of a new file to copy the chain to. By
default, the copy will pull the entire source chain into the destination
file, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then
only the top of the source chain will be copied (the source and
destination have a common backing file). By default, @base will be
created with the same file format as the source, but this can be altered
by adding <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_REBASE_COPY_RAW">VIR_DOMAIN_BLOCK_REBASE_COPY_RAW</a> to force the copy to be raw
(does not make sense with the shallow flag unless the source is also raw),
or by using <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT">VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT</a> to reuse an existing file
which was pre-created with the correct format and metadata and sufficient
size to hold the copy. In case the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_REBASE_SHALLOW">VIR_DOMAIN_BLOCK_REBASE_SHALLOW</a> flag
is used the pre-created file has to exhibit the same guest visible contents
as the backing file of the original image. This allows a management app to
pre-create files with relative backing file names, rather than the default
of absolute backing file names; as a security precaution, you should
generally only use reuse_ext with the shallow flag and a non-raw
destination file. By default, the copy destination will be treated as
type='file', but using <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_BLOCK_REBASE_COPY_DEV">VIR_DOMAIN_BLOCK_REBASE_COPY_DEV</a> treats the
destination as type='block' (affecting how virDomainGetBlockInfo() will
report allocation after pivoting).

A copy job has two parts; in the first phase, the @bandwidth parameter
affects how fast the source is pulled into the destination, and the job
can only be canceled by reverting to the source file; progress in this
phase can be tracked via the virDomainBlockJobInfo() command, with a
job type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY. The job transitions to the
second phase when the job info states cur == end, and remains alive to
mirror all further changes to both source and destination. The user
must call virDomainBlockJobAbort() to end the mirroring while choosing
whether to revert to source or pivot to the destination. An event is
issued when the job ends, and depending on the hypervisor, an event may
also be issued when the job transitions from pulling to mirroring. If
the job is aborted, a new job will have to start over from the beginning
of the first phase.

Some hypervisors will restrict certain actions, such as virDomainSave()
or virDomainDetachDevice(), while a copy job is active; they may
also restrict a copy job to transient domains.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

The @base parameter can be either a path to a file within the backing
chain, or the device target shorthand (the &lt;target dev='...'/&gt;
sub-element, such as "vda") followed by an index to the backing chain
enclosed in square brackets. Backing chain indexes can be found by
inspecting //disk//backingStore/@index in the domain XML. Thus, for
example, "vda[3]" refers to the backing store with index equal to "3"
in the chain of disk "vda".

The maximum bandwidth that will be used to do the copy can be
specified with the @bandwidth parameter. If set to 0, there is no
limit. If @flags includes VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES,
@bandwidth is in bytes/second; otherwise, it is in MiB/second.
Values larger than 2^52 bytes/sec may be rejected due to overflow
considerations based on the word size of both client and server,
and values larger than 2^31 bytes/sec may cause overflow problems
if later queried by virDomainGetBlockJobInfo() without scaling.
Hypervisors may further restrict the range of valid bandwidth
values. Some hypervisors do not support this feature and will
return an error if bandwidth is not 0; in this case, it might still
be possible for a later call to virDomainBlockJobSetSpeed() to
succeed. The actual speed can be determined with
virDomainGetBlockJobInfo().

When @base is NULL and @flags is 0, this is identical to
virDomainBlockPull(). When @flags contains VIR_DOMAIN_BLOCK_REBASE_COPY,
this command is shorthand for virDomainBlockCopy() where the destination
XML encodes @base as a &lt;disk type='file'&gt;, @bandwidth is properly scaled
and passed as a typed parameter, the shallow and reuse external flags
are preserved, and remaining flags control whether the XML encodes a
destination format of raw instead of leaving the destination identical
to the source format or probed from the reused file.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>base</tt></i>:</span></td><td>path to backing file to keep, or device shorthand, or NULL for no backing file</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify bandwidth limit; flags determine the unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockRebaseFlags">virDomainBlockRebaseFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockResize"/>virDomainBlockResize ()</h3><pre class="programlisting">int	virDomainBlockResize		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 unsigned long long size, <br/>					 unsigned int flags)<br/>
</pre><p>Resize a block device of domain while the domain is running. If
@flags is 0, then @size is in kibibytes (blocks of 1024 bytes);
since 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,
@size is in bytes instead. @size is taken directly as the new
size. Depending on the file format, the hypervisor may round up
to the next alignment boundary.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

Note that this call may fail if the underlying virtualization hypervisor
does not support it; this call requires privileged access to the
hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block image, or shorthand</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>new size of the block image, see below for unit</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockResizeFlags">virDomainBlockResizeFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStats"/>virDomainBlockStats ()</h3><pre class="programlisting">int	virDomainBlockStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockStatsPtr">virDomainBlockStatsPtr</a> stats, <br/>					 size_t size)<br/>
</pre><p>This function returns block device (disk) stats for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "vda"), or (since 0.9.8)
an unambiguous source name of the block device (the &lt;source
file='...'/&gt; sub-element, such as "/path/to/image"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk. Some drivers might also
accept the empty string for the @disk parameter, and then yield
summary stats for the entire domain.

Domains may have more than one block device. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>block device stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainBlockStatsFlags"/>virDomainBlockStatsFlags ()</h3><pre class="programlisting">int	virDomainBlockStatsFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>This function is to get block stats parameters for block
devices attached to the domain.

The @disk parameter is either the device target shorthand (the
&lt;target dev='...'/&gt; sub-element, such as "vda"), or (since 0.9.8)
an unambiguous source name of the block device (the &lt;source
file='...'/&gt; sub-element, such as "/path/to/image"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk. Some drivers might also
accept the empty string for the @disk parameter, and then yield
summary stats for the entire domain.

Domains may have more than one block device. To get stats for
each you should make multiple calls to this function.

On input, @nparams gives the size of the @params array; on output,
@nparams gives how many slots were filled with parameter
information, which might be less but will not exceed the input
value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. (Note that block devices of different types
might support different parameters, so it might be necessary to compute
@nparams for each block device). The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for more details.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to block stats parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of block stats; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDump"/>virDomainCoreDump ()</h3><pre class="programlisting">int	virDomainCoreDump		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int flags)<br/>
</pre><p>This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host. Hypervisors may require the user to manually ensure
proper permissions on the file named by @to.

If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with
a crashed state after the dump completes. If @flags includes
VIR_DUMP_LIVE, then make the core dump while continuing to allow
the guest to run; otherwise, the guest is suspended during the dump.
VIR_DUMP_RESET flag forces reset of the guest after dump.
The above three flags are mutually exclusive.

Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt
will attempt to bypass the file system cache while creating the file,
or fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

For more control over the output format, see virDomainCoreDumpWithFormat().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the core file</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCoreDumpWithFormat"/>virDomainCoreDumpWithFormat ()</h3><pre class="programlisting">int	virDomainCoreDumpWithFormat	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 unsigned int dumpformat, <br/>					 unsigned int flags)<br/>
</pre><p>This method will dump the core of a domain on a given file for analysis.
Note that for remote Xen Daemon the file path will be interpreted in
the remote host. Hypervisors may require the user to manually ensure
proper permissions on the file named by @to.

@dumpformat controls which format the dump will have; use of
VIR_DOMAIN_CORE_DUMP_FORMAT_RAW mirrors what virDomainCoreDump() will
perform. Not all hypervisors are able to support all formats.

If @flags includes VIR_DUMP_CRASH, then leave the guest shut off with
a crashed state after the dump completes. If @flags includes
VIR_DUMP_LIVE, then make the core dump while continuing to allow
the guest to run; otherwise, the guest is suspended during the dump.
VIR_DUMP_RESET flag forces reset of the guest after dump.
The above three flags are mutually exclusive.

Additionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt
will attempt to bypass the file system cache while creating the file,
or fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the core file</td></tr><tr><td><span class="term"><i><tt>dumpformat</tt></i>:</span></td><td>format of domain memory's dump (one of <a href="libvirt-libvirt-domain.html#virDomainCoreDumpFormat">virDomainCoreDumpFormat</a> enum)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainCoreDumpFlags">virDomainCoreDumpFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreate"/>virDomainCreate ()</h3><pre class="programlisting">int	virDomainCreate			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools. The domain will be paused only
if restoring from managed state created from a paused domain. For more
control, see virDomainCreateWithFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateLinux"/>virDomainCreateLinux ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainCreateLinux	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags)<br/>
</pre><p>Deprecated after 0.4.6.
Renamed to virDomainCreateXML() providing identical functionality.
This existing name will be left indefinitely for API compatibility.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateWithFiles"/>virDomainCreateWithFiles ()</h3><pre class="programlisting">int	virDomainCreateWithFiles	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nfiles, <br/>					 int * files, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume(). In all other cases, the guest domain will
be running.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>nfiles</tt></i>:</span></td><td>number of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>files</tt></i>:</span></td><td>list of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateWithFlags"/>virDomainCreateWithFlags ()</h3><pre class="programlisting">int	virDomainCreateWithFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a defined domain. If the call succeeds the domain moves from the
defined to the running domains pools.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, or if the guest domain
has a managed save image that requested paused state (see
virDomainManagedSave()) the guest domain will be started, but its
CPUs will remain paused. The CPUs can later be manually started
using virDomainResume(). In all other cases, the guest domain will
be running.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_BYPASS_CACHE">VIR_DOMAIN_START_BYPASS_CACHE</a> flag is set, and there is a
managed save file for this domain (created by virDomainManagedSave()),
then libvirt will attempt to bypass the file system cache while restoring
the file, or fail if it cannot do so for the given system; this can allow
less pressure on file system cache, but also risks slowing loads from NFS.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_FORCE_BOOT">VIR_DOMAIN_START_FORCE_BOOT</a> flag is set, then any managed save
file for this domain is discarded, and the domain boots from scratch.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateXML"/>virDomainCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainCreateXML	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xmlDesc, <br/>					 unsigned int flags)<br/>
</pre><p>Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainCreateXMLWithFiles"/>virDomainCreateXMLWithFiles ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainCreateXMLWithFiles	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int nfiles, <br/>						 int * files, <br/>						 unsigned int flags)<br/>
</pre><p>Launch a new guest domain, based on an XML description similar
to the one returned by virDomainGetXMLDesc()
This function may require privileged access to the hypervisor.
The domain is not persistent, so its definition will disappear when it
is destroyed, or if the host is restarted (see virDomainDefineXML() to
define persistent domains).

@files provides an array of file descriptors which will be
made available to the 'init' process of the guest. The file
handles exposed to the guest will be renumbered to start
from 3 (ie immediately following stderr). This is only
supported for guests which use container based virtualization
technology.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_PAUSED">VIR_DOMAIN_START_PAUSED</a> flag is set, the guest domain
will be started, but its CPUs will remain paused. The CPUs
can later be manually started using virDomainResume.

If the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_START_AUTODESTROY">VIR_DOMAIN_START_AUTODESTROY</a> flag is set, the guest
domain will be automatically destroyed when the virConnectPtr
object is finally released. This will also happen if the
client application crashes / loses its connection to the
libvirtd daemon. Any domains marked for auto destroy will
block attempts at migration, save-to-file, or snapshots.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the domain</td></tr><tr><td><span class="term"><i><tt>nfiles</tt></i>:</span></td><td>number of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>files</tt></i>:</span></td><td>list of file descriptors passed</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainCreateFlags">virDomainCreateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDefineXML"/>virDomainDefineXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainDefineXML	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml)<br/>
</pre><p>Define a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overridden if it already exists.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the domain, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the domain otherwise</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDefineXMLFlags"/>virDomainDefineXMLFlags ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainDefineXMLFlags	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Defines a domain, but does not start it.
This definition is persistent, until explicitly undefined with
virDomainUndefine(). A previous definition for this domain would be
overridden if it already exists.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>the XML description for the domain, preferably in UTF-8</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise OR of the <a href="libvirt-libvirt-domain.html#virDomainDefineFlags">virDomainDefineFlags</a> constants</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error, a pointer to the domain otherwise</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDelIOThread"/>virDomainDelIOThread ()</h3><pre class="programlisting">int	virDomainDelIOThread		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically delete an IOThread from the domain. The @iothread_id to be
deleted must not have a resource associated with it and can be any of
the currently valid IOThread ID's.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or if reducing the number is arbitrarily limited.
This function requires privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>iothread_id</tt></i>:</span></td><td>the specific IOThread ID value to delete</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroy"/>virDomainDestroy ()</h3><pre class="programlisting">int	virDomainDestroy		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor. This
does not free the associated <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> object.
This function may require privileged access.

virDomainDestroy first requests that a guest terminate
(e.g. SIGTERM), then waits for it to comply. After a reasonable
timeout, if the guest still exists, <a href="libvirt-libvirt-domain.html#virDomainDestroy">virDomainDestroy</a> will
forcefully terminate the guest (e.g. SIGKILL) if necessary (which
may produce undesirable results, for example unflushed disk cache
in the guest). To avoid this possibility, it's recommended to
instead call virDomainDestroyFlags, sending the
VIR_DOMAIN_DESTROY_GRACEFUL flag.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDestroyFlags"/>virDomainDestroyFlags ()</h3><pre class="programlisting">int	virDomainDestroyFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Destroy the domain object. The running instance is shutdown if not down
already and all resources used by it are given back to the hypervisor.
This does not free the associated <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> object.
This function may require privileged access.

Calling this function with no @flags set (equal to zero) is
equivalent to calling virDomainDestroy, and after a reasonable
timeout will forcefully terminate the guest (e.g. SIGKILL) if
necessary (which may produce undesirable results, for example
unflushed disk cache in the guest). Including
VIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful
termination of the guest, and <a href="libvirt-libvirt-domain.html#virDomainDestroyFlags">virDomainDestroyFlags</a> will instead
return an error if the guest doesn't terminate by the end of the
timeout; at that time, the management application can decide if
calling again without <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_DESTROY_GRACEFUL">VIR_DOMAIN_DESTROY_GRACEFUL</a> is appropriate.

Another alternative which may produce cleaner results for the
guest's disks is to use virDomainShutdown() instead, but that
depends on guest support (some hypervisor/guest combinations may
ignore the shutdown request).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainDestroyFlagsValues">virDomainDestroyFlagsValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDetachDevice"/>virDomainDetachDevice ()</h3><pre class="programlisting">int	virDomainDetachDevice		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml)<br/>
</pre><p>This is an equivalent of virDomainDetachDeviceFlags() when called with
@flags parameter set to VIR_DOMAIN_AFFECT_LIVE.

See virDomainDetachDeviceFlags() for more details.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDetachDeviceAlias"/>virDomainDetachDeviceAlias ()</h3><pre class="programlisting">int	virDomainDetachDeviceAlias	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * alias, <br/>					 unsigned int flags)<br/>
</pre><p>Detach a virtual device from a domain, using the alias to
specify the device. The value of @flags should be either
VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values from
VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CURRENT, although
hypervisors vary in which flags are supported.

In contrast to virDomainDetachDeviceFlags() this API is
asynchronous - it returns immediately after sending the detach
request to the hypervisor. It's caller's responsibility to
wait for <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED">VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED</a> event to signal
actual device removal or for
VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED to signal rejected
device removal.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a domain object</td></tr><tr><td><span class="term"><i><tt>alias</tt></i>:</span></td><td>device alias</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainDetachDeviceFlags"/>virDomainDetachDeviceFlags ()</h3><pre class="programlisting">int	virDomainDetachDeviceFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Detach a virtual device from a domain, using the flags parameter
to control how the device is detached. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device allocation is removed based on current domain
state. <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
deallocated from the active domain instance only and is not from the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be deallocated from the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports removing the
persisted device allocation.

Some hypervisors may prevent this operation if there is a current
block job running operation on the device being detached; in that case,
use virDomainBlockJobAbort() to stop the block job first.

Beware that depending on the hypervisor and device type, detaching a device
from a running domain may be asynchronous. That is, calling
virDomainDetachDeviceFlags may just request device removal while the device
is actually removed later (in cooperation with a guest OS). Previously,
this fact was ignored and the device could have been removed from domain
configuration before it was actually removed by the hypervisor causing
various failures on subsequent operations. To check whether the device was
successfully removed, either recheck domain configuration using
virDomainGetXMLDesc() or add a handler for the VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED
event. In case the device is already gone when virDomainDetachDeviceFlags
returns, the event is delivered before this API call ends. To help existing
clients work better in most cases, this API will try to transform an
asynchronous device removal that finishes shortly after the request into
a synchronous removal. In other words, this API may wait a bit for the
removal to complete in case it was not synchronous.

Be aware that hotplug changes might not persist across a domain going
into S4 state (also known as hibernation) unless you also modify the
persistent domain definition.

The supplied XML description of the device should be as specific
as its definition in the domain XML. The set of attributes used
to match the device are internal to the drivers. Using a partial definition,
or attempting to detach a device that is not present in the domain XML,
but shares some specific attributes with one that is present,
may lead to unexpected results.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSFreeze"/>virDomainFSFreeze ()</h3><pre class="programlisting">int	virDomainFSFreeze		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char ** mountpoints, <br/>					 unsigned int nmountpoints, <br/>					 unsigned int flags)<br/>
</pre><p>Freeze specified filesystems within the guest (hence guest agent
may be required depending on hypervisor used). If @mountpoints is NULL and
@nmountpoints is 0, every mounted filesystem on the guest is frozen.
In some environments (e.g. QEMU guest with guest agent which doesn't
support mountpoints argument), @mountpoints may need to be NULL.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>mountpoints</tt></i>:</span></td><td>list of mount points to be frozen</td></tr><tr><td><span class="term"><i><tt>nmountpoints</tt></i>:</span></td><td>the number of mount points specified in @mountpoints</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of frozen filesystems on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSInfoFree"/>virDomainFSInfoFree ()</h3><pre class="programlisting">void	virDomainFSInfoFree		(<a href="libvirt-libvirt-domain.html#virDomainFSInfoPtr">virDomainFSInfoPtr</a> info)<br/>
</pre><p>Frees all the memory occupied by @info.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a FSInfo object</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSThaw"/>virDomainFSThaw ()</h3><pre class="programlisting">int	virDomainFSThaw			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char ** mountpoints, <br/>					 unsigned int nmountpoints, <br/>					 unsigned int flags)<br/>
</pre><p>Thaw specified filesystems within the guest. If @mountpoints is NULL and
@nmountpoints is 0, every mounted filesystem on the guest is thawed.
In some drivers (e.g. QEMU driver), @mountpoints may need to be NULL.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>mountpoints</tt></i>:</span></td><td>list of mount points to be thawed</td></tr><tr><td><span class="term"><i><tt>nmountpoints</tt></i>:</span></td><td>the number of mount points specified in @mountpoints</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of thawed filesystems on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFSTrim"/>virDomainFSTrim ()</h3><pre class="programlisting">int	virDomainFSTrim			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * mountPoint, <br/>					 unsigned long long minimum, <br/>					 unsigned int flags)<br/>
</pre><p>Calls FITRIM within the guest (hence guest agent may be
required depending on hypervisor used). Either call it on each
mounted filesystem (@mountPoint is NULL) or just on specified
@mountPoint. @minimum hints that free ranges smaller than this
may be ignored (this is a hint and the guest may not respect
it). By increasing this value, the fstrim operation will
complete more quickly for filesystems with badly fragmented
free space, although not all blocks will be discarded.
If @minimum is not zero, the command may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>mountPoint</tt></i>:</span></td><td>which mount point to trim</td></tr><tr><td><span class="term"><i><tt>minimum</tt></i>:</span></td><td>Minimum contiguous free range to discard in bytes</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags, not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainFree"/>virDomainFree ()</h3><pre class="programlisting">int	virDomainFree			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Free the domain object. The running instance is kept alive.
The data structure is freed and should not be used thereafter.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetAutostart"/>virDomainGetAutostart ()</h3><pre class="programlisting">int	virDomainGetAutostart		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * autostart)<br/>
</pre><p>Provides a boolean value indicating whether the domain
configured to be automatically started when the host
machine boots.

Please note that this might result in unexpected behaviour if
used for some session URIs. Since the session daemon is started
with --timeout it comes and goes and as it does so it
autostarts domains which might have been shut off recently.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>the value returned</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlkioParameters"/>virDomainGetBlkioParameters ()</h3><pre class="programlisting">int	virDomainGetBlkioParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all blkio parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to blkio parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of blkio parameters; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockInfo"/>virDomainGetBlockInfo ()</h3><pre class="programlisting">int	virDomainGetBlockInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockInfoPtr">virDomainBlockInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Extract information about a domain's block device.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

For QEMU domains, the allocation and physical virDomainBlockInfo
values returned will generally be the same, except when using a
non raw, block backing device, such as qcow2 for an active domain.
When the persistent domain is not active, QEMU will return the
default which is the same value for allocation and physical.

Active QEMU domains can return an allocation value which is more
representative of the currently used blocks by the device compared
to the physical size of the device. Applications can use/monitor
the allocation value with the understanding that if the domain
becomes inactive during an attempt to get the value, the default
values will be returned. Thus, the application should check
after the call for the domain being inactive if the values are
the same. Optionally, the application could be watching for a
shutdown event and then ignore any values received afterwards.
This can be an issue when a domain is being migrated and the
exact timing of the domain being made inactive and check of
the allocation value results the default being returned. For
a transient domain in the similar situation, this call will return
-1 and an error message indicating the "domain is not running".

The following is some pseudo code illustrating the call sequence:

 ...
 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom;
 <a href="libvirt-libvirt-domain.html#virDomainBlockInfo">virDomainBlockInfo</a> info;
 char *device;
 ...
 // Either get a list of all domains or a specific domain
 // via a virDomainLookupBy*() call.
 //
 // It's also required to fill in the device pointer, but that's
 // specific to the implementation. For the purposes of this example
 // a qcow2 backed device name string would need to be provided.
 ...
 // If the following call is made on a persistent domain with a
 // qcow2 block backed block device, then it's possible the returned
 // allocation equals the physical value. In that case, the domain
 // that may have been active prior to calling has become inactive,
 // such as is the case during a domain migration. Thus once we
 // get data returned, check for active domain when the values are
 // the same.
 if (virDomainGetBlockInfo(dom, device, &amp;info, 0) &lt; 0)
 goto failure;
 if (info.allocation == info.physical) {
 // If the domain is no longer active,
 // then the defaults are being returned.
 if (!virDomainIsActive())
 goto ignore_return;
 }
 // Do something with the allocation and physical values
 ...</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainBlockInfo">virDomainBlockInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockIoTune"/>virDomainGetBlockIoTune ()</h3><pre class="programlisting">int	virDomainGetBlockIoTune		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all block IO tunable parameters for a given device. On input,
@nparams gives the size of the @params array; on output, @nparams
gives how many slots were filled with parameter information, which
might be less but will not exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0
on input will cause @nparams on output to contain the number of
parameters supported by the hypervisor, either for the given @disk
(note that block devices of different types might support different
parameters), or if @disk is NULL, for all possible disks. The
caller should then allocate @params array,
i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again. See virDomainGetMemoryParameters() for more details.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the &lt;target
dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk. This parameter cannot be NULL
unless @nparams is 0 on input.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>Pointer to blkio parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>Pointer to number of blkio parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetBlockJobInfo"/>virDomainGetBlockJobInfo ()</h3><pre class="programlisting">int	virDomainGetBlockJobInfo	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainBlockJobInfoPtr">virDomainBlockJobInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Request block job information for the given disk. If an operation is active
@info will be updated with the current progress. The units used for the
bandwidth field of @info depends on @flags. If @flags includes
VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES, bandwidth is in bytes/second
(although this mode can risk failure due to overflow, depending on both
client and server word size); otherwise, the value is rounded up to MiB/s.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or (since 0.9.5) the device target shorthand
(the &lt;target dev='...'/&gt; sub-element, such as "vda"). Valid names
can be found by calling virDomainGetXMLDesc() and inspecting
elements within //domain/devices/disk.

As a corner case underlying hypervisor may report cur == 0 and
end == 0 when the block job hasn't been started yet. In this
case libvirt reports cur = 0 and end = 1. However, hypervisor
may return cur == 0 and end == 0 if the block job has finished
and was no-op. In this case libvirt reports cur = 1 and end = 1.
Since 2.3.0.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainBlockJobInfo">virDomainBlockJobInfo</a> structure</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainBlockJobInfoFlags">virDomainBlockJobInfoFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 when nothing found, 1 when info was found.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetCPUStats"/>virDomainGetCPUStats ()</h3><pre class="programlisting">int	virDomainGetCPUStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 int start_cpu, <br/>					 unsigned int ncpus, <br/>					 unsigned int flags)<br/>
</pre><p>Get statistics relating to CPU usage attributable to a single
domain (in contrast to the statistics returned by
virNodeGetCPUStats() for all processes on the host). @dom
must be running (an inactive domain has no attributable cpu
usage). On input, @params must contain at least @nparams * @ncpus
entries, allocated by the caller.

If @start_cpu is -1, then @ncpus must be 1, and the returned
results reflect the statistics attributable to the entire
domain (such as user and system time for the process as a
whole). Otherwise, @start_cpu represents which cpu to start
with, and @ncpus represents how many consecutive processors to
query, with statistics attributable per processor (such as
per-cpu usage). If @ncpus is larger than the number of cpus
available to query, then the trailing part of the array will
be unpopulated.

The remote driver imposes a limit of 128 @ncpus and 16 @nparams;
the number of parameters per cpu should not exceed 16, but if you
have a host with more than 128 CPUs, your program should split
the request into multiple calls.

As special cases, if @params is NULL and @nparams is 0 and
@ncpus is 1, and the return value will be how many
statistics are available for the given @start_cpu. This number
may be different for @start_cpu of -1 than for any non-negative
value, but will be the same for all non-negative @start_cpu.
Likewise, if @params is NULL and @nparams is 0 and @ncpus is 0,
the number of cpus available to query is returned. From the
host perspective, this would typically match the cpus member
of virNodeGetInfo(), but might be less due to host cpu hotplug.

For now, @flags is unused, and the statistics all relate to the
usage from the host perspective. It is possible that a future
version will support a flag that queries the cpu usage from the
guest's perspective, where the maximum cpu to query would be
related to virDomainGetVcpusFlags() rather than virNodeGetInfo().
An individual guest vcpu cannot be reliably mapped back to a
specific host cpu unless a single-processor vcpu pinning was used,
but when @start_cpu is -1, any difference in usage between a host
and guest perspective would serve as a measure of hypervisor overhead.

Typical use sequence is below.

getting total stats: set start_cpu as -1, ncpus 1

 virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0); // nparams
 params = calloc(nparams, sizeof(virTypedParameter))
 virDomainGetCPUStats(dom, params, nparams, -1, 1, 0); // total stats.

getting per-cpu stats:

 virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0); // ncpus
 virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0); // nparams
 params = calloc(ncpus * nparams, sizeof(virTypedParameter));
 virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0); // per-cpu stats</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>domain to query</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>array to populate on output</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of parameters per cpu</td></tr><tr><td><span class="term"><i><tt>start_cpu</tt></i>:</span></td><td>which cpu to start with, or -1 for summary</td></tr><tr><td><span class="term"><i><tt>ncpus</tt></i>:</span></td><td>how many cpus to query</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 on failure, or the number of statistics that were populated per cpu on success (this will be less than the total number of populated @params, unless @ncpus was 1; and may be less than @nparams). The populated parameters start at each stride of @nparams, which means the results may be discontiguous; any unpopulated parameters will be zeroed on success (this includes skipped elements if @nparams is too large, and tail elements if @ncpus is too large). The caller is responsible for freeing any returned string parameters.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetConnect"/>virDomainGetConnect ()</h3><pre class="programlisting"><a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a>	virDomainGetConnect	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Provides the connection pointer associated with a domain. The
reference counter on the connection is not increased by this
call.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to a domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetControlInfo"/>virDomainGetControlInfo ()</h3><pre class="programlisting">int	virDomainGetControlInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainControlInfoPtr">virDomainControlInfoPtr</a> info, <br/>					 unsigned int flags)<br/>
</pre><p>Extract details about current state of control interface to a domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainControlInfo">virDomainControlInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetDiskErrors"/>virDomainGetDiskErrors ()</h3><pre class="programlisting">int	virDomainGetDiskErrors		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainDiskErrorPtr">virDomainDiskErrorPtr</a> errors, <br/>					 unsigned int maxerrors, <br/>					 unsigned int flags)<br/>
</pre><p>The function populates @errors array with all disks that encountered an
I/O error. Disks with no error will not be returned in the @errors array.
Each disk is identified by its target (the dev attribute of target
subelement in domain XML), such as "vda", and accompanied with the error
that was seen on it. The caller is also responsible for calling free()
on each disk name returned.

In a special case when @errors is NULL and @maxerrors is 0, the function
returns preferred size of @errors that the caller should use to get all
disk errors.

Since calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size
of @errors array and getting the errors are two separate operations, new
disks may be hotplugged to the domain and new errors may be encountered
between the two calls. Thus, this function may not return all disk errors
because the supplied array is not large enough. Such errors may, however,
be detected by listening to domain events.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>errors</tt></i>:</span></td><td>array to populate on output</td></tr><tr><td><span class="term"><i><tt>maxerrors</tt></i>:</span></td><td>size of @errors array</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>number of disks with errors filled in the @errors array or -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetEmulatorPinInfo"/>virDomainGetEmulatorPinInfo ()</h3><pre class="programlisting">int	virDomainGetEmulatorPinInfo	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Query the CPU affinity setting of all emulator threads of domain, store
it in cpumap.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all emulator threads of this domain (in 8-bit bytes) (OUT) There is only one cpumap for all emulator threads. Must not be NULL.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 in case of success, 0 in case of no emulator threads are pined to pcpus, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetFSInfo"/>virDomainGetFSInfo ()</h3><pre class="programlisting">int	virDomainGetFSInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainFSInfoPtr">virDomainFSInfoPtr</a> ** info, <br/>					 unsigned int flags)<br/>
</pre><p>Get a list of mapping information for each mounted file systems within the
specified guest and the disks.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>a pointer to a variable to store an array of mount points information</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of returned mount points, or -1 in case of error. On success, the array of the information is stored into @info. The caller is responsible for calling virDomainFSInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetGuestVcpus"/>virDomainGetGuestVcpus ()</h3><pre class="programlisting">int	virDomainGetGuestVcpus		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 unsigned int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Queries the guest agent for state and information regarding vCPUs from
guest's perspective. The reported data depends on the guest agent
implementation.

Reported fields stored in @params:
'vcpus': string containing bitmap representing vCPU ids as reported by the
 guest
'online': string containing bitmap representing online vCPUs as reported
 by the guest agent.
'offlinable': string containing bitmap representing ids of vCPUs that can be
 offlined

This API requires the VM to run. The caller is responsible for calling
virTypedParamsFree to free memory returned in @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer that will be filled with an array of typed parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer filled with number of elements in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, callers shall pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetHostname"/>virDomainGetHostname ()</h3><pre class="programlisting">char *	virDomainGetHostname		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Get the hostname for that domain.

Dependent on hypervisor used, this may require a guest agent to be
available.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the hostname which must be freed by the caller, or NULL if there was an error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetID"/>virDomainGetID ()</h3><pre class="programlisting">unsigned int	virDomainGetID		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the hypervisor ID number for the domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the domain ID number or (unsigned int) -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetIOThreadInfo"/>virDomainGetIOThreadInfo ()</h3><pre class="programlisting">int	virDomainGetIOThreadInfo	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainIOThreadInfoPtr">virDomainIOThreadInfoPtr</a> ** info, <br/>					 unsigned int flags)<br/>
</pre><p>Fetch IOThreads of an active domain including the cpumap information to
determine on which CPU the IOThread has affinity to run.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to an array of <a href="libvirt-libvirt-domain.html#virDomainIOThreadInfo">virDomainIOThreadInfo</a> structures (OUT)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of IOThreads or -1 in case of error. On success, the array of information is stored into @info. The caller is responsible for calling virDomainIOThreadInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetInfo"/>virDomainGetInfo ()</h3><pre class="programlisting">int	virDomainGetInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInfoPtr">virDomainInfoPtr</a> info)<br/>
</pre><p>Extract information about a domain. Note that if the connection
used to get the domain is limited only a partial set of the information
can be extracted.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainInfo">virDomainInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetInterfaceParameters"/>virDomainGetInterfaceParameters ()</h3><pre class="programlisting">int	virDomainGetInterfaceParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all interface parameters. On input, @nparams gives the size of
the @params array; on output, @nparams gives how many slots were
filled with parameter information, which might be less but will not
exceed the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the
API again. See virDomainGetMemoryParameters() for an equivalent usage
example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>device</tt></i>:</span></td><td>the interface name or mac address</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to interface parameter objects (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of interface parameter; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetJobInfo"/>virDomainGetJobInfo ()</h3><pre class="programlisting">int	virDomainGetJobInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainJobInfoPtr">virDomainJobInfoPtr</a> info)<br/>
</pre><p>Extract information about progress of a background job on a domain.
Will return an error if the domain is not active.

This function returns a limited amount of information in comparison
to virDomainGetJobStats().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainJobInfo">virDomainJobInfo</a> structure allocated by the user</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetJobStats"/>virDomainGetJobStats ()</h3><pre class="programlisting">int	virDomainGetJobStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * type, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Extract information about progress of a background job on a domain.
Will return an error if the domain is not active. The function returns
a superset of progress information provided by virDomainGetJobInfo.
Possible fields returned in @params are defined by VIR_DOMAIN_JOB_*
macros and new fields will likely be introduced in the future so callers
may receive fields that they do not understand in case they talk to a
newer server.

When @flags contains VIR_DOMAIN_JOB_STATS_COMPLETED, the function will
return statistics about a recently completed job. Specifically, this
flag may be used to query statistics of a completed incoming pre-copy
migration (statistics for post-copy migration are only available on the
source host). Statistics of a completed job are automatically destroyed
once read or when libvirtd is restarted. Note that time information
returned for completed migrations may be completely irrelevant unless both
source and destination hosts have synchronized time (i.e., NTP daemon is
running on both of them). The statistics of a completed job can also be
obtained by listening to a <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_ID_JOB_COMPLETED">VIR_DOMAIN_EVENT_ID_JOB_COMPLETED</a> event (on the
source host in case of a migration job).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>where to store the job type (one of virDomainJobType)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>where to store job statistics</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of items in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainGetJobStatsFlags">virDomainGetJobStatsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetLaunchSecurityInfo"/>virDomainGetLaunchSecurityInfo ()</h3><pre class="programlisting">int	virDomainGetLaunchSecurityInfo	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get the launch security info. In case of the SEV guest, this will
return the launch measurement.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>where to store security info</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of items in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently used, set to 0.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMaxMemory"/>virDomainGetMaxMemory ()</h3><pre class="programlisting">unsigned long	virDomainGetMaxMemory	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Retrieve the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this get the amount of memory reserved
to Domain0 i.e. the domain where the application runs.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes), or 0 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMaxVcpus"/>virDomainGetMaxVcpus ()</h3><pre class="programlisting">int	virDomainGetMaxVcpus		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Provides the maximum number of virtual CPUs supported for
the guest VM. If the guest is inactive, this is basically
the same as virConnectGetMaxVcpus(). If the guest is running
this will reflect the maximum number of virtual CPUs the
guest was booted with. For more details, see virDomainGetVcpusFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the maximum of virtual CPU or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMemoryParameters"/>virDomainGetMemoryParameters ()</h3><pre class="programlisting">int	virDomainGetMemoryParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all memory parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

Here is a sample code snippet:

 if (virDomainGetMemoryParameters(dom, NULL, &amp;nparams, 0) == 0 &amp;&amp;
 nparams != 0) {
 if ((params = malloc(sizeof(*params) * nparams)) == NULL)
 goto error;
 memset(params, 0, sizeof(*params) * nparams);
 if (virDomainGetMemoryParameters(dom, params, &amp;nparams, 0))
 goto error;
 }

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of memory parameters; input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetMetadata"/>virDomainGetMetadata ()</h3><pre class="programlisting">char *	virDomainGetMetadata		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * uri, <br/>					 unsigned int flags)<br/>
</pre><p>Retrieves the appropriate domain element given by @type.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> is requested parameter @uri
must be set to the name of the namespace the requested elements
belong to, otherwise must be NULL.

If an element of the domain XML is not present, the resulting
error will be VIR_ERR_NO_DOMAIN_METADATA. This method forms
a shortcut for seeing information from virDomainSetMetadata()
without having to go through virDomainGetXMLDesc().

@flags controls whether the live domain or persistent
configuration will be queried.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of metadata, from <a href="libvirt-libvirt-domain.html#virDomainMetadataType">virDomainMetadataType</a></td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>XML namespace identifier</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the metadata string on success (caller must free), or NULL in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetName"/>virDomainGetName ()</h3><pre class="programlisting">const char *	virDomainGetName	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the public name for that domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetNumaParameters"/>virDomainGetNumaParameters ()</h3><pre class="programlisting">int	virDomainGetNumaParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all numa parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value.

As a special case, calling with @params as NULL and @nparams as 0 on
input will cause @nparams on output to contain the number of parameters
supported by the hypervisor. The caller should then allocate @params
array, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API
again.

See virDomainGetMemoryParameters() for an equivalent usage example.

This function may require privileged access to the hypervisor. This function
expects the caller to allocate the @params.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to numa parameter object (return value, allocated by the caller)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of numa parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetOSType"/>virDomainGetOSType ()</h3><pre class="programlisting">char *	virDomainGetOSType		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Get the type of domain operation system.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new string or NULL in case of error, the string must be freed by the caller.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetPerfEvents"/>virDomainGetPerfEvents ()</h3><pre class="programlisting">int	virDomainGetPerfEvents		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> * params, <br/>					 int * nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Get all Linux perf events setting. Possible fields returned in
@params are defined by VIR_PERF_EVENT_* macros and new fields
will likely be introduced in the future.

Linux perf events are performance analyzing tool in Linux.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>where to store perf events setting</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of items in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of failure, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerParameters"/>virDomainGetSchedulerParameters ()</h3><pre class="programlisting">int	virDomainGetSchedulerParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int * nparams)<br/>
</pre><p>Get all scheduler parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value. @nparams cannot be 0.

It is hypervisor specific whether this returns the live or
persistent state; for more control, use
virDomainGetSchedulerParametersFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameter objects (this value should generally be as large as the returned value nparams of virDomainGetSchedulerType()); input and output</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerParametersFlags"/>virDomainGetSchedulerParametersFlags ()</h3><pre class="programlisting">int	virDomainGetSchedulerParametersFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int * nparams, <br/>						 unsigned int flags)<br/>
</pre><p>Get all scheduler parameters. On input, @nparams gives the size of the
@params array; on output, @nparams gives how many slots were filled
with parameter information, which might be less but will not exceed
the input value. @nparams cannot be 0.

The value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,
VIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.

Here is a sample code snippet:

 char *ret = virDomainGetSchedulerType(dom, &amp;nparams);
 if (ret &amp;&amp; nparams != 0) {
 if ((params = malloc(sizeof(*params) * nparams)) == NULL)
 goto error;
 memset(params, 0, sizeof(*params) * nparams);
 if (virDomainGetSchedulerParametersFlags(dom, params, &amp;nparams, 0))
 goto error;
 }</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter object (return value)</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType()); input and output</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSchedulerType"/>virDomainGetSchedulerType ()</h3><pre class="programlisting">char *	virDomainGetSchedulerType	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * nparams)<br/>
</pre><p>Get the scheduler type and the number of scheduler parameters.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>pointer to number of scheduler parameters, can be NULL (return value)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>NULL in case of error. The caller must free the returned string.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSecurityLabel"/>virDomainGetSecurityLabel ()</h3><pre class="programlisting">int	virDomainGetSecurityLabel	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virSecurityLabelPtr">virSecurityLabelPtr</a> seclabel)<br/>
</pre><p>Extract security label of an active domain. The 'label' field
in the @seclabel argument will be initialized to the empty
string if the domain is not running under a security model.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seclabel</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-host.html#virSecurityLabel">virSecurityLabel</a> structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetSecurityLabelList"/>virDomainGetSecurityLabelList ()</h3><pre class="programlisting">int	virDomainGetSecurityLabelList	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virSecurityLabelPtr">virSecurityLabelPtr</a> * seclabels)<br/>
</pre><p>Extract the security labels of an active domain. The 'label' field
in the @seclabels argument will be initialized to the empty
string if the domain is not running under a security model.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seclabels</tt></i>:</span></td><td>will be auto-allocated and filled with domains' security labels. Caller must free memory on return.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>number of elements in @seclabels on success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetState"/>virDomainGetState ()</h3><pre class="programlisting">int	virDomainGetState		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int * state, <br/>					 int * reason, <br/>					 unsigned int flags)<br/>
</pre><p>Extract domain state. Each state can be accompanied with a reason (if known)
which led to the state.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>state</tt></i>:</span></td><td>returned state of the domain (one of virDomainState)</td></tr><tr><td><span class="term"><i><tt>reason</tt></i>:</span></td><td>returned reason which led to @state (one of virDomain*Reason corresponding to the current state); it is allowed to be NULL</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetTime"/>virDomainGetTime ()</h3><pre class="programlisting">int	virDomainGetTime		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 long long * seconds, <br/>					 unsigned int * nseconds, <br/>					 unsigned int flags)<br/>
</pre><p>Extract information about guest time and store it into
@seconds and @nseconds. The @seconds represents the number of
seconds since the UNIX Epoch of 1970-01-01 00:00:00 in UTC.

Please note that some hypervisors may require guest agent to
be configured and running in order to run this API.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seconds</tt></i>:</span></td><td>domain's time in seconds</td></tr><tr><td><span class="term"><i><tt>nseconds</tt></i>:</span></td><td>the nanosecond part of @seconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetUUID"/>virDomainGetUUID ()</h3><pre class="programlisting">int	virDomainGetUUID		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * uuid)<br/>
</pre><p>Get the UUID for a domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-host.html#VIR_UUID_BUFLEN">VIR_UUID_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetUUIDString"/>virDomainGetUUIDString ()</h3><pre class="programlisting">int	virDomainGetUUIDString		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 char * buf)<br/>
</pre><p>Get the UUID for a domain as string. For more information about
UUID see RFC4122.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-host.html#VIR_UUID_STRING_BUFLEN">VIR_UUID_STRING_BUFLEN</a> bytes array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpuPinInfo"/>virDomainGetVcpuPinInfo ()</h3><pre class="programlisting">int	virDomainGetVcpuPinInfo		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int ncpumaps, <br/>					 unsigned char * cpumaps, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Query the CPU affinity setting of all virtual CPUs of domain, store it
in cpumaps.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>ncpumaps</tt></i>:</span></td><td>the number of cpumap (listed first to match virDomainGetVcpus)</td></tr><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) It's assumed there is &lt;ncpumaps&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (ncpumaps * maplen) bytes (ie: calloc(ncpumaps, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API. Must not be NULL.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> Must not be <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> concurrently.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of virtual CPUs in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpus"/>virDomainGetVcpus ()</h3><pre class="programlisting">int	virDomainGetVcpus		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-domain.html#virVcpuInfoPtr">virVcpuInfoPtr</a> info, <br/>					 int maxinfo, <br/>					 unsigned char * cpumaps, <br/>					 int maplen)<br/>
</pre><p>Extract information about virtual CPUs of domain, store it in info array
and also in cpumaps if this pointer isn't NULL. This call may fail
on an inactive domain.

See also <a href="libvirt-libvirt-domain.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying just cpumaps, including on
an inactive domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to an array of <a href="libvirt-libvirt-domain.html#virVcpuInfo">virVcpuInfo</a> structures (OUT)</td></tr><tr><td><span class="term"><i><tt>maxinfo</tt></i>:</span></td><td>number of structures in info array</td></tr><tr><td><span class="term"><i><tt>cpumaps</tt></i>:</span></td><td>pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It's assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of info filled in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetVcpusFlags"/>virDomainGetVcpusFlags ()</h3><pre class="programlisting">int	virDomainGetVcpusFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Query the number of virtual CPUs used by the domain. Note that
this call may fail if the underlying virtualization hypervisor does
not support it. This function may require privileged access to the
hypervisor.

If @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a
running domain (which will fail if domain is not active); if
it includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML
description of the domain. It is an error to set both flags.
If neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),
then the configuration queried depends on whether the domain
is currently running.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum
virtual CPU limit is queried. Otherwise, this call queries the
current virtual CPU count.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors
is queried in the guest instead of the hypervisor. This flag is only usable
on live domains. Guest agent may be needed for this flag to be available.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of vCPUs in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainGetXMLDesc"/>virDomainGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainGetXMLDesc		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Provide an XML description of the domain. The description may be reused
later to relaunch the domain with virDomainCreateXML().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_XML_SECURE; this flag is rejected on read-only
connections. If @flags includes VIR_DOMAIN_XML_INACTIVE, then the
XML represents the configuration that will be used on the next boot
of a persistent domain; otherwise, the configuration represents the
currently running domain. If @flags contains
VIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML
describing CPU capabilities is modified to match actual
capabilities of the host.

If @flags contains VIR_DOMAIN_XML_MIGRATABLE, the XML is altered to
assist in migrations, since the source and destination may be
running different libvirt versions. This may include trimming
redundant or default information that might confuse an older
recipient, or exposing internal details that aid a newer recipient;
this flag is rejected on read-only connections, and the resulting
XML might not validate against the schema, so it is mainly for
internal use.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainXMLFlags">virDomainXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainHasManagedSaveImage"/>virDomainHasManagedSaveImage ()</h3><pre class="programlisting">int	virDomainHasManagedSaveImage	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Check if a domain has a managed save image as created by
virDomainManagedSave(). Note that any running domain should not have
such an image, as it should have been removed on restart.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if no image is present, 1 if an image is present, and -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIOThreadInfoFree"/>virDomainIOThreadInfoFree ()</h3><pre class="programlisting">void	virDomainIOThreadInfoFree	(<a href="libvirt-libvirt-domain.html#virDomainIOThreadInfoPtr">virDomainIOThreadInfoPtr</a> info)<br/>
</pre><p>Frees the memory used by @info.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>pointer to a <a href="libvirt-libvirt-domain.html#virDomainIOThreadInfo">virDomainIOThreadInfo</a> object</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInjectNMI"/>virDomainInjectNMI ()</h3><pre class="programlisting">int	virDomainInjectNMI		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Send NMI to the guest</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceAddresses"/>virDomainInterfaceAddresses ()</h3><pre class="programlisting">int	virDomainInterfaceAddresses	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> ** ifaces, <br/>					 unsigned int source, <br/>					 unsigned int flags)<br/>
</pre><p>Return a pointer to the allocated array of pointers to interfaces
present in given domain along with their IP and MAC addresses. Note that
single interface can have multiple or even 0 IP addresses.

This API dynamically allocates the <a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> struct based on
how many interfaces domain @dom has, usually there's 1:1 correlation. The
count of the interfaces is returned as the return value.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE, the DHCP lease
file associated with any virtual networks will be examined to obtain
the interface addresses. This only returns data for interfaces which
are connected to virtual networks managed by libvirt.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, a configured
guest agent is needed for successful return from this API. Moreover, if
guest agent is used then the interface name is the one seen by guest OS.
To match such interface with the one from @dom XML use MAC address or IP
range.

If @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP, the host
ARP table will be check to obtain the interface addresses. As
the arp cache refreshes in time, the returned ip address may
be unreachable. Depending on the route table config of the
guest, the returned mac address may be duplicated.

Note that for some @source values some pieces of returned @ifaces
might be unset (e.g. <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP">VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP</a> does not
set IP address prefix as ARP table does not have any notion of that).

@ifaces-&gt;name and @ifaces-&gt;hwaddr are never NULL.

The caller *must* free @ifaces when no longer needed. Usual use case
looks like this:

 <a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> *ifaces = NULL;
 int ifaces_count = 0;
 size_t i, j;
 <a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom = ... obtain a domain here ...;

 if ((ifaces_count = virDomainInterfaceAddresses(dom, &amp;ifaces,
 VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)) &lt; 0)
 goto cleanup;

 ... do something with returned values, for example:

 for (i = 0; i &lt; ifaces_count; i++) {
 printf("name: %s", ifaces[i]-&gt;name);
 if (ifaces[i]-&gt;hwaddr)
 printf(" hwaddr: %s", ifaces[i]-&gt;hwaddr);

 for (j = 0; j &lt; ifaces[i]-&gt;naddrs; j++) {
 <a href="libvirt-libvirt-domain.html#virDomainIPAddressPtr">virDomainIPAddressPtr</a> ip_addr = ifaces[i]-&gt;addrs + j;
 printf("[addr: %s prefix: %d type: %d]",
 ip_addr-&gt;addr, ip_addr-&gt;prefix, ip_addr-&gt;type);
 }
 printf("\n");
 }

 cleanup:
 if (ifaces &amp;&amp; ifaces_count &gt; 0)
 for (i = 0; i &lt; ifaces_count; i++)
 virDomainInterfaceFree(ifaces[i]);
 free(ifaces);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>domain object</td></tr><tr><td><span class="term"><i><tt>ifaces</tt></i>:</span></td><td>pointer to an array of pointers pointing to interface objects</td></tr><tr><td><span class="term"><i><tt>source</tt></i>:</span></td><td>one of the <a href="libvirt-libvirt-domain.html#virDomainInterfaceAddressesSource">virDomainInterfaceAddressesSource</a> constants</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass zero</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of interfaces on success, -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceFree"/>virDomainInterfaceFree ()</h3><pre class="programlisting">void	virDomainInterfaceFree		(<a href="libvirt-libvirt-domain.html#virDomainInterfacePtr">virDomainInterfacePtr</a> iface)<br/>
</pre><p>Free the interface object. The data structure is
freed and should not be used thereafter. If @iface
is NULL, then this method has no effect.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>iface</tt></i>:</span></td><td>an interface object</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainInterfaceStats"/>virDomainInterfaceStats ()</h3><pre class="programlisting">int	virDomainInterfaceStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainInterfaceStatsPtr">virDomainInterfaceStatsPtr</a> stats, <br/>					 size_t size)<br/>
</pre><p>This function returns network interface stats for interfaces
attached to the domain.

The @device parameter is the network interface either by name or MAC
address.

Domains may have more than one network interface. To get stats for
each you should make multiple calls to this function.

Individual fields within the stats structure may be returned
as -1, which indicates that the hypervisor does not support
that particular statistic.

The returned stats are from domain's point of view.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>device</tt></i>:</span></td><td>the interface name or MAC address</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>network interface stats (returned)</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of stats structure</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsActive"/>virDomainIsActive ()</h3><pre class="programlisting">int	virDomainIsActive		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain is currently running</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if running, 0 if inactive, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsPersistent"/>virDomainIsPersistent ()</h3><pre class="programlisting">int	virDomainIsPersistent		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain has a persistent configuration
which means it will still exist after shutting down</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if persistent, 0 if transient, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainIsUpdated"/>virDomainIsUpdated ()</h3><pre class="programlisting">int	virDomainIsUpdated		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom)<br/>
</pre><p>Determine if the domain has been updated.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if updated, 0 if not, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainListGetStats"/>virDomainListGetStats ()</h3><pre class="programlisting">int	virDomainListGetStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> * doms, <br/>					 unsigned int stats, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> ** retStats, <br/>					 unsigned int flags)<br/>
</pre><p>Query statistics for domains provided by @doms. Note that all domains in
@doms must share the same connection.

Report statistics of various parameters for a running VM according to @stats
field. The statistics are returned as an array of structures for each queried
domain. The structure contains an array of typed parameters containing the
individual statistics. The typed parameter name for each statistic field
consists of a dot-separated string containing name of the requested group
followed by a group specific description of the statistic value.

The statistic groups are enabled using the @stats parameter which is a
binary-OR of enum virDomainStatsTypes. The stats groups are documented
in virConnectGetAllDomainStats.

Using 0 for @stats returns all stats groups supported by the given
hypervisor.

Specifying <a href="libvirt-libvirt-domain.html#VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS">VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS</a> as @flags makes
the function return error in case some of the stat types in @stats were
not recognized by the daemon. However, even with this flag, a hypervisor
may omit individual fields within a known group if the information is not
available; as an extreme example, a supported group may produce zero
fields for offline domains if the statistics are meaningful only for a
running domain.

Passing <a href="libvirt-libvirt-domain.html#VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT">VIR_CONNECT_GET_ALL_DOMAINS_STATS_NOWAIT</a> in
@flags means when libvirt is unable to fetch stats for any of
the domains (for whatever reason) only a subset of statistics
is returned for the domain. That subset being statistics that
don't involve querying the underlying hypervisor.

Note that any of the domain list filtering flags in @flags may be rejected
by this function.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>doms</tt></i>:</span></td><td>NULL terminated array of domains</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>stats to return, binary-OR of <a href="libvirt-libvirt-domain.html#virDomainStatsTypes">virDomainStatsTypes</a></td></tr><tr><td><span class="term"><i><tt>retStats</tt></i>:</span></td><td>Pointer that will be filled with the array of returned stats</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; binary-OR of <a href="libvirt-libvirt-domain.html#virConnectGetAllDomainStatsFlags">virConnectGetAllDomainStatsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree. Note that the count of returned stats may be less than the domain count provided via @doms.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByID"/>virDomainLookupByID ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByID	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 int id)<br/>
</pre><p>Try to find a domain based on the hypervisor ID number
Note that this won't work for inactive domains which have an ID of -1,
in that case a lookup based on the Name or UUId need to be done instead.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>id</tt></i>:</span></td><td>the domain ID number</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByName"/>virDomainLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByName	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * name)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its name.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>name for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByUUID"/>virDomainLookupByUUID ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUID	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const unsigned char * uuid)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuid</tt></i>:</span></td><td>the raw UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainLookupByUUIDString"/>virDomainLookupByUUIDString ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainLookupByUUIDString	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * uuidstr)<br/>
</pre><p>Try to lookup a domain on the given hypervisor based on its UUID.

virDomainFree should be used to free the resources after the
domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>uuidstr</tt></i>:</span></td><td>the string UUID for the domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new domain object or NULL in case of failure. If the domain cannot be found, then <a href="libvirt-virterror.html#VIR_ERR_NO_DOMAIN">VIR_ERR_NO_DOMAIN</a> error is raised.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSave"/>virDomainManagedSave ()</h3><pre class="programlisting">int	virDomainManagedSave		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore.
The difference from virDomainSave() is that libvirt is keeping track of
the saved state itself, and will reuse it once the domain is being
restarted (automatically or via an explicit libvirt call).
As a result any running domain is sure to not have a managed saved image.
This also implies that managed save only works on persistent domains,
since the domain must still exist in order to use virDomainCreate() to
restart it.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the managed saved state will remember whether the domain
was running or paused, and start will resume to the same state.
Specifying <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default saved into the file. These two
flags are mutually exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSaveDefineXML"/>virDomainManagedSaveDefineXML ()</h3><pre class="programlisting">int	virDomainManagedSaveDefineXML	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This updates the definition of a domain stored in a saved state
file.

@dxml can be used to alter host-specific portions of the domain XML
that will be used on the next start of the domain. For example, it is
possible to alter the backing filename that is associated with a
disk device.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default saved into the file; omitting both
leaves the file's default unchanged. These two flags are mutually
exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSaveGetXMLDesc"/>virDomainManagedSaveGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainManagedSaveGetXMLDesc	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>This method will extract the XML description of the managed save
state file of a domain.

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_SAVE_IMAGE_XML_SECURE; this flag is rejected on read-only
connections.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainSaveImageXMLFlags">virDomainSaveImageXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainManagedSaveRemove"/>virDomainManagedSaveRemove ()</h3><pre class="programlisting">int	virDomainManagedSaveRemove	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Remove any managed save image for this domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, and -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryPeek"/>virDomainMemoryPeek ()</h3><pre class="programlisting">int	virDomainMemoryPeek		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned long long start, <br/>					 size_t size, <br/>					 void * buffer, <br/>					 unsigned int flags)<br/>
</pre><p>This function allows you to read the contents of a domain's
memory.

The memory which is read is controlled by the 'start', 'size'
and 'flags' parameters.

If 'flags' is <a href="libvirt-libvirt-domain.html#VIR_MEMORY_VIRTUAL">VIR_MEMORY_VIRTUAL</a> then the 'start' and 'size'
parameters are interpreted as virtual memory addresses for
whichever task happens to be running on the domain at the
moment. Although this sounds haphazard it is in fact what
you want in order to read Linux kernel state, because it
ensures that pointers in the kernel image can be interpreted
coherently.

'buffer' is the return buffer and must be at least 'size' bytes.
'size' may be 0 to test if the call would succeed.

NB. The remote driver imposes a 64K byte limit on 'size'.
For your program to be able to work reliably over a remote
connection you should split large requests to &lt;= 65536 bytes.
However, with 0.9.13 this RPC limit has been raised to 1M byte.
Starting with version 1.0.6 the RPC limit has been raised again.
Now large requests up to 16M byte are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>start</tt></i>:</span></td><td>start of memory to peek</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>size of memory to peek</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>return buffer (must be at least size bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMemoryFlags">virDomainMemoryFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMemoryStats"/>virDomainMemoryStats ()</h3><pre class="programlisting">int	virDomainMemoryStats		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 <a href="libvirt-libvirt-domain.html#virDomainMemoryStatPtr">virDomainMemoryStatPtr</a> stats, <br/>					 unsigned int nr_stats, <br/>					 unsigned int flags)<br/>
</pre><p>This function provides memory statistics for the domain.

Up to 'nr_stats' elements of 'stats' will be populated with memory statistics
from the domain. Only statistics supported by the domain, the driver, and
this version of libvirt will be returned.

Memory Statistics:

VIR_DOMAIN_MEMORY_STAT_SWAP_IN:
 The total amount of data read from swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_SWAP_OUT:
 The total amount of memory written out to swap space (in kb).
VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:
 The number of page faults that required disk IO to service.
VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:
 The number of page faults serviced without disk IO.
VIR_DOMAIN_MEMORY_STAT_UNUSED:
 The amount of memory which is not being used for any purpose (in kb).
VIR_DOMAIN_MEMORY_STAT_AVAILABLE:
 The total amount of memory available to the domain's OS (in kb).
VIR_DOMAIN_MEMORY_STAT_USABLE:
 How much the balloon can be inflated without pushing the guest system
 to swap, corresponds to 'Available' in /proc/meminfo
VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:
 Current balloon value (in kb).
VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE
 Timestamp of the last statistic
VIR_DOMAIN_MEMORY_STAT_DISK_CACHES
 Memory that can be reclaimed without additional I/O, typically disk
 caches (in kb).
VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC
 The amount of successful huge page allocations from inside the domain
VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL
 The amount of failed huge page allocations from inside the domain</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>nr_stats-sized array of stat structures (returned)</td></tr><tr><td><span class="term"><i><tt>nr_stats</tt></i>:</span></td><td>number of memory statistics requested</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>The number of stats provided or -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate"/>virDomainMigrate ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

This function is similar to virDomainMigrate3, but it only supports a fixed
set of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME, @uri
is VIR_MIGRATE_PARAM_URI, and @bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>(optional) dest hostname/URI as seen from the source host</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate2"/>virDomainMigrate2 ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate2	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 const char * uri, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by dconn (a connection to the destination host).

This function is similar to virDomainMigrate3, but it only supports a fixed
set of parameters: @dxml corresponds to VIR_MIGRATE_PARAM_DEST_XML, @dname
is VIR_MIGRATE_PARAM_DEST_NAME, @uri is VIR_MIGRATE_PARAM_URI, and
@bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for launching guest on target</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>(optional) dest hostname/URI as seen from the source host</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrate3"/>virDomainMigrate3 ()</h3><pre class="programlisting"><a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a>	virDomainMigrate3	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> dconn, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Migrate the domain object from its current host to the destination host
given by dconn (a connection to the destination host).

See VIR_MIGRATE_PARAM_* and <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a> for detailed description
of accepted migration parameters and flags.

See <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a> documentation for description of individual flags.

VIR_MIGRATE_TUNNELLED and <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> are not supported by this
API, use <a href="libvirt-libvirt-domain.html#virDomainMigrateToURI3">virDomainMigrateToURI3</a> instead.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.

virDomainFree should be used to free the resources after the
returned domain object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconn</tt></i>:</span></td><td>destination host (a connection object)</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>(optional) migration parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>(optional) number of migration parameters in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new domain object if the migration was successful, or NULL in case of error. Note that the new domain object exists in the scope of the destination connection (dconn).</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateGetCompressionCache"/>virDomainMigrateGetCompressionCache ()</h3><pre class="programlisting">int	virDomainMigrateGetCompressionCache	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long * cacheSize, <br/>						 unsigned int flags)<br/>
</pre><p>Gets current size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>cacheSize</tt></i>:</span></td><td>return value of current size of the cache (in bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateGetMaxDowntime"/>virDomainMigrateGetMaxDowntime ()</h3><pre class="programlisting">int	virDomainMigrateGetMaxDowntime	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long * downtime, <br/>					 unsigned int flags)<br/>
</pre><p>Gets current maximum tolerable time for which the domain may be paused
at the end of live migration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>downtime</tt></i>:</span></td><td>return value of the maximum tolerable downtime for live migration, in milliseconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateGetMaxSpeed"/>virDomainMigrateGetMaxSpeed ()</h3><pre class="programlisting">int	virDomainMigrateGetMaxSpeed	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long * bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>Get the current maximum bandwidth (in MiB/s) that will be used if the
domain is migrated. Not all hypervisors will support a bandwidth limit.
When <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY">VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY</a> is set in @flags, this API
gets the current maximum bandwidth for the post-copy phase of the
migration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>return value of current migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateMaxSpeedFlags">virDomainMigrateMaxSpeedFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetCompressionCache"/>virDomainMigrateSetCompressionCache ()</h3><pre class="programlisting">int	virDomainMigrateSetCompressionCache	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 unsigned long long cacheSize, <br/>						 unsigned int flags)<br/>
</pre><p>Sets size of the cache (in bytes) used for compressing repeatedly
transferred memory pages during live migration. It's supposed to be called
while the domain is being live-migrated as a reaction to migration progress
and increasing number of compression cache misses obtained from
virDomainGetJobStats.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>cacheSize</tt></i>:</span></td><td>size of the cache (in bytes) used for compression</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetMaxDowntime"/>virDomainMigrateSetMaxDowntime ()</h3><pre class="programlisting">int	virDomainMigrateSetMaxDowntime	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long long downtime, <br/>					 unsigned int flags)<br/>
</pre><p>Sets maximum tolerable time for which the domain is allowed to be paused
at the end of live migration. It's supposed to be called while the domain is
being live-migrated as a reaction to migration progress.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>downtime</tt></i>:</span></td><td>maximum tolerable downtime for live migration, in milliseconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateSetMaxSpeed"/>virDomainMigrateSetMaxSpeed ()</h3><pre class="programlisting">int	virDomainMigrateSetMaxSpeed	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long bandwidth, <br/>					 unsigned int flags)<br/>
</pre><p>The maximum bandwidth (in MiB/s) that will be used to do migration
can be specified with the bandwidth parameter. Not all hypervisors
will support a bandwidth cap. When VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY
is set in @flags, this API sets the maximum bandwidth for the post-copy
phase of the migration.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateMaxSpeedFlags">virDomainMigrateMaxSpeedFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateStartPostCopy"/>virDomainMigrateStartPostCopy ()</h3><pre class="programlisting">int	virDomainMigrateStartPostCopy	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Starts post-copy migration. This function has to be called while
migration (initiated with <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_POSTCOPY">VIR_MIGRATE_POSTCOPY</a> flag) is in progress.

Traditional pre-copy migration iteratively walks through guest memory
pages and migrates those that changed since the previous iteration. The
iterative phase stops when the number of dirty pages is low enough so that
the virtual CPUs can be paused, all dirty pages transferred to the
destination, where the virtual CPUs are unpaused, and all this can happen
within a predefined downtime period. It's clear that this process may never
converge if downtime is too short and/or the guest keeps changing a lot of
memory pages.

When migration is switched to post-copy mode, the virtual CPUs are paused
immediately, only a minimum set of pages is transferred, and the CPUs are
unpaused on destination. The source keeps sending all remaining memory pages
to the destination while the guest is already running there. Whenever the
guest tries to read a memory page which has not been migrated yet, the
hypervisor has to tell the source to transfer that page in a priority
channel. To minimize such page faults, it is a good idea to run at least one
iteration of pre-copy migration before switching to post-copy.

Post-copy migration is guaranteed to converge since each page is transferred
at most once no matter how fast it changes. On the other hand once the
guest is running on the destination host, the migration can no longer be
rolled back because none of the hosts has complete state. If this happens,
libvirt will leave the domain paused on both hosts with
VIR_DOMAIN_PAUSED_POSTCOPY_FAILED reason. It's up to the upper layer to
decide what to do in such case. Because of this, libvirt will refuse to
cancel post-copy migration via virDomainAbortJob.

The following domain life cycle events are emitted during post-copy
migration:
 <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY">VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY</a> (on the source) -- migration entered
 post-copy mode.
 <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_RESUMED_POSTCOPY">VIR_DOMAIN_EVENT_RESUMED_POSTCOPY</a> (on the destination) -- the guest is
 running on the destination host while some of its memory pages still
 remain on the source host; neither the source nor the destination host
 contain a complete guest state from this point until migration
 finishes.
 <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_RESUMED_MIGRATED">VIR_DOMAIN_EVENT_RESUMED_MIGRATED</a> (on the destination),
 <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_STOPPED_MIGRATED">VIR_DOMAIN_EVENT_STOPPED_MIGRATED</a> (on the source) -- migration finished
 successfully and the destination host holds a complete guest state.
 <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED">VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED</a> (on the destination) -- emitted
 when migration fails in post-copy mode and it's unclear whether any
 of the hosts has a complete guest state.

The progress of a post-copy migration can be monitored normally using
virDomainGetJobStats on the source host. Fetching statistics of a completed
post-copy migration can also be done on the source host (by calling
virDomainGetJobStats or listening to VIR_DOMAIN_EVENT_ID_JOB_COMPLETED
event, but (in contrast to pre-copy migration) the statistics are not
available on the destination host. Thus, VIR_DOMAIN_EVENT_ID_JOB_COMPLETED
event is the only way of getting statistics of a completed post-copy
migration of a transient domain (because the domain is removed after
migration and there's no domain to run <a href="libvirt-libvirt-domain.html#virDomainGetJobStats">virDomainGetJobStats</a> on).</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI"/>virDomainMigrateToURI ()</h3><pre class="programlisting">int	virDomainMigrateToURI		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * duri, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by duri.

This function is similar to virDomainMigrateToURI3, but it only supports a
fixed set of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME,
and @bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.

The operation of this API hinges on the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag IS set, the @duri parameter must be a
valid libvirt connection URI, by which the source libvirt driver can connect
to the destination libvirt. In other words, @duri corresponds to @dconnuri
of virDomainMigrateToURI3.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the @duri parameter takes a
hypervisor specific URI used to initiate the migration. In this case @duri
corresponds to <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a> of virDomainMigrateToURI3.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>duri</tt></i>:</span></td><td>mandatory URI for the destination host</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI2"/>virDomainMigrateToURI2 ()</h3><pre class="programlisting">int	virDomainMigrateToURI2		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 const char * miguri, <br/>					 const char * dxml, <br/>					 unsigned long flags, <br/>					 const char * dname, <br/>					 unsigned long bandwidth)<br/>
</pre><p>Migrate the domain object from its current host to the destination
host given by @dconnuri.

This function is similar to virDomainMigrateToURI3, but it only supports a
fixed set of parameters: @miguri corresponds to VIR_MIGRATE_PARAM_URI, @dxml
is VIR_MIGRATE_PARAM_DEST_XML, @dname is VIR_MIGRATE_PARAM_DEST_NAME, and
@bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.

The operation of this API hinges on the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag IS set, the @dconnuri parameter must be a
valid libvirt connection URI, by which the source libvirt driver can connect
to the destination libvirt. In other words, @dconnuri has the same semantics
as in virDomainMigrateToURI3.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, the @dconnuri must be NULL
and the @miguri parameter takes a hypervisor specific URI used to initiate
the migration. In this case @miguri corresponds to <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a> of
virDomainMigrateToURI3.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconnuri</tt></i>:</span></td><td>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td></tr><tr><td><span class="term"><i><tt>miguri</tt></i>:</span></td><td>(optional) URI for invoking the migration, not if @flags includs <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_TUNNELLED">VIR_MIGRATE_TUNNELLED</a></td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for launching guest on target</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>dname</tt></i>:</span></td><td>(optional) rename domain to this at destination</td></tr><tr><td><span class="term"><i><tt>bandwidth</tt></i>:</span></td><td>(optional) specify migration bandwidth limit in MiB/s</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainMigrateToURI3"/>virDomainMigrateToURI3 ()</h3><pre class="programlisting">int	virDomainMigrateToURI3		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dconnuri, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 unsigned int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Migrate the domain object from its current host to the destination host
given by URI.

See VIR_MIGRATE_PARAM_* and <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a> for detailed description
of accepted migration parameters and flags.

The operation of this API hinges on the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is set, the @dconnuri parameter must be a
valid libvirt connection URI, by which the source libvirt daemon can connect
to the destination libvirt.

If the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is NOT set, then @dconnuri must be NULL
and <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PARAM_URI">VIR_MIGRATE_PARAM_URI</a> migration parameter must be filled in with
hypervisor specific URI used to initiate the migration. The uri_transports
element of the hypervisor capabilities XML includes supported URI schemes.
This is called "direct" migration. Not all hypervisors support this mode of
migration, so if the <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a> flag is not set, then it may be
necessary to use the alternative <a href="libvirt-libvirt-domain.html#virDomainMigrate3">virDomainMigrate3</a> API providing an explicit
virConnectPtr for the destination host.

There are many limitations on migration imposed by the underlying
technology - for example it may not be possible to migrate between
different processors even with the same architecture, or between
different types of hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dconnuri</tt></i>:</span></td><td>(optional) URI for target libvirtd if @flags includes <a href="libvirt-libvirt-domain.html#VIR_MIGRATE_PEER2PEER">VIR_MIGRATE_PEER2PEER</a></td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>(optional) migration parameters</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>(optional) number of migration parameters in @params</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMigrateFlags">virDomainMigrateFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the migration succeeded, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenChannel"/>virDomainOpenChannel ()</h3><pre class="programlisting">int	virDomainOpenChannel		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * name, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags)<br/>
</pre><p>This opens the host interface associated with a channel device on a
guest, if the host interface is supported. If @name is given, it
can match either the device alias (e.g. "channel0"), or the virtio
target name (e.g. "org.qemu.guest_agent.0"). If @name is omitted,
then the first channel is opened. The channel is associated with
the passed in @st stream, which should have been opened in
non-blocking mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt detects
that the channel is already in use by another client; passing
VIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the
other client prior to opening this channel.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the channel name, or NULL</td></tr><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>a stream to associate with the channel</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainChannelFlags">virDomainChannelFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the channel was opened, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenConsole"/>virDomainOpenConsole ()</h3><pre class="programlisting">int	virDomainOpenConsole		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * dev_name, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 unsigned int flags)<br/>
</pre><p>This opens the backend associated with a console, serial or
parallel port device on a guest, if the backend is supported.
If the @dev_name is omitted, then the first console or serial
device is opened. The console is associated with the passed
in @st stream, which should have been opened in non-blocking
mode for bi-directional I/O.

By default, when @flags is 0, the open will fail if libvirt
detects that the console is already in use by another client;
passing <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_CONSOLE_FORCE">VIR_DOMAIN_CONSOLE_FORCE</a> will cause libvirt to forcefully
remove the other client prior to opening this console.

If flag <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_CONSOLE_SAFE">VIR_DOMAIN_CONSOLE_SAFE</a> the console is opened only in the
case where the hypervisor driver supports safe (mutually exclusive)
console handling.

Older servers did not support either flag, and also did not forbid
simultaneous clients on a console, with potentially confusing results.
When passing @flags of 0 in order to support a wider range of server
versions, it is up to the client to ensure mutual exclusion.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>dev_name</tt></i>:</span></td><td>the console, serial or parallel port device alias, or NULL</td></tr><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>a stream to associate with the console</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainConsoleFlags">virDomainConsoleFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the console was opened, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenGraphics"/>virDomainOpenGraphics ()</h3><pre class="programlisting">int	virDomainOpenGraphics		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 int fd, <br/>					 unsigned int flags)<br/>
</pre><p>This will attempt to connect the file descriptor @fd, to
the graphics backend of @dom. If @dom has multiple graphics
backends configured, then @idx will determine which one is
opened, starting from @idx 0.

To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH
constant for @flags.

The caller should use an anonymous socketpair to open
@fd before invocation.

This method can only be used when connected to a local
libvirt hypervisor, over a UNIX domain socket. Attempts
to use this method over a TCP connection will always fail</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>idx</tt></i>:</span></td><td>index of graphics config to open</td></tr><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>file descriptor to attach graphics to</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainOpenGraphicsFD"/>virDomainOpenGraphicsFD ()</h3><pre class="programlisting">int	virDomainOpenGraphicsFD		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int idx, <br/>					 unsigned int flags)<br/>
</pre><p>This will create a socket pair connected to the graphics backend of @dom.
One end of the socket will be returned on success, and the other end is
handed to the hypervisor.
If @dom has multiple graphics backends configured, then @idx will determine
which one is opened, starting from @idx 0.

To disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH
constant for @flags.

This method can only be used when connected to a local
libvirt hypervisor, over a UNIX domain socket. Attempts
to use this method over a TCP connection will always fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>idx</tt></i>:</span></td><td>index of graphics config to open</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainOpenGraphicsFlags">virDomainOpenGraphicsFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an fd on success, -1 on failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMSuspendForDuration"/>virDomainPMSuspendForDuration ()</h3><pre class="programlisting">int	virDomainPMSuspendForDuration	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int target, <br/>					 unsigned long long duration, <br/>					 unsigned int flags)<br/>
</pre><p>Attempt to have the guest enter the given @target power management
suspension level. If @duration is non-zero, also schedule the guest to
resume normal operation after that many seconds, if nothing else has
resumed it earlier. Some hypervisors require that @duration be 0, for
an indefinite suspension.

Dependent on hypervisor used, this may require a
guest agent to be available, e.g. QEMU.

Beware that at least for QEMU, the domain's process will be terminated
when <a href="libvirt-libvirt-host.html#VIR_NODE_SUSPEND_TARGET_DISK">VIR_NODE_SUSPEND_TARGET_DISK</a> is used and a new process will be
launched when libvirt is asked to wake up the domain. As a result of
this, any runtime changes, such as device hotplug or memory settings,
are lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG
flag.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>target</tt></i>:</span></td><td>a value from <a href="libvirt-libvirt-host.html#virNodeSuspendTarget">virNodeSuspendTarget</a></td></tr><tr><td><span class="term"><i><tt>duration</tt></i>:</span></td><td>duration in seconds to suspend, or 0 for indefinite</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPMWakeup"/>virDomainPMWakeup ()</h3><pre class="programlisting">int	virDomainPMWakeup		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 unsigned int flags)<br/>
</pre><p>Inject a wakeup into the guest that previously used
virDomainPMSuspendForDuration, rather than waiting for the
previously requested duration (if any) to elapse.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinEmulator"/>virDomainPinEmulator ()</h3><pre class="programlisting">int	virDomainPinEmulator		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to all emulator
threads. This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also <a href="libvirt-libvirt-domain.html#virDomainGetEmulatorPinInfo">virDomainGetEmulatorPinInfo</a> for querying this information.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinIOThread"/>virDomainPinIOThread ()</h3><pre class="programlisting">int	virDomainPinIOThread		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to an IOThread.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also <a href="libvirt-libvirt-domain.html#virDomainGetIOThreadInfo">virDomainGetIOThreadInfo</a> for querying this information.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>iothread_id</tt></i>:</span></td><td>the IOThread ID to set the CPU affinity</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinVcpu"/>virDomainPinVcpu ()</h3><pre class="programlisting">int	virDomainPinVcpu		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainPinVcpuFlags"/>virDomainPinVcpuFlags ()</h3><pre class="programlisting">int	virDomainPinVcpuFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int vcpu, <br/>					 unsigned char * cpumap, <br/>					 int maplen, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the real CPUs which can be allocated to a virtual CPU.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects a running domain
and may fail if domain is not alive.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified (that is,
@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies
persistent setup, while an active domain is hypervisor-dependent on whether
just live or both live and persistent state is changed.
Not all hypervisors can support all flag combinations.

See also <a href="libvirt-libvirt-domain.html#virDomainGetVcpuPinInfo">virDomainGetVcpuPinInfo</a> for querying this information.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>vcpu</tt></i>:</span></td><td>virtual CPU number</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.</td></tr><tr><td><span class="term"><i><tt>maplen</tt></i>:</span></td><td>number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainReboot"/>virDomainReboot ()</h3><pre class="programlisting">int	virDomainReboot			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Reboot a domain, the domain object is still usable thereafter, but
the domain OS is being stopped for a restart.
Note that the guest OS may ignore the request.
Additionally, the hypervisor may check and support the domain
'on_reboot' XML setting resulting in a domain that shuts down instead
of rebooting.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainRebootFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.

To use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML
must have &lt;channel&gt; configured.

Due to implementation limitations in some drivers (the qemu driver,
for instance) it is not advised to migrate or save a guest that is
rebooting as a result of this API. Migrating such a guest can lead
to a plain shutdown on the destination.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainRebootFlagValues">virDomainRebootFlagValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRef"/>virDomainRef ()</h3><pre class="programlisting">int	virDomainRef			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Increment the reference count on the domain. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt-domain.html#virDomainFree">virDomainFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a domain would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>the domain to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRename"/>virDomainRename ()</h3><pre class="programlisting">int	virDomainRename			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * new_name, <br/>					 unsigned int flags)<br/>
</pre><p>Rename a domain. New domain name is specified in the second
argument. Depending on each driver implementation it may be
required that domain is in a specific state.

There might be some attributes and/or elements in domain XML that if no
value provided at XML defining time, libvirt will derive their value from
the domain name. These are not updated by this API. Users are strongly
advised to change these after the rename was successful.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to the domain object</td></tr><tr><td><span class="term"><i><tt>new_name</tt></i>:</span></td><td>new domain name</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if successfully renamed, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainReset"/>virDomainReset ()</h3><pre class="programlisting">int	virDomainReset			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Reset a domain immediately without any guest OS shutdown.
Reset emulates the power reset button on a machine, where all
hardware sees the RST line set and reinitializes internal state.

Note that there is a risk of data loss caused by reset without any
guest OS shutdown.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRestore"/>virDomainRestore ()</h3><pre class="programlisting">int	virDomainRestore		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from)<br/>
</pre><p>This method will restore a domain saved to disk by virDomainSave().

See virDomainRestoreFlags() for more control.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>from</tt></i>:</span></td><td>path to the input file</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainRestoreFlags"/>virDomainRestoreFlags ()</h3><pre class="programlisting">int	virDomainRestoreFlags		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * from, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This method will restore a domain saved to disk by virDomainSave().

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image. For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while restoring the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing restores from NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default read from the file. These two
flags are mutually exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>from</tt></i>:</span></td><td>path to the input file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainResume"/>virDomainResume ()</h3><pre class="programlisting">int	virDomainResume			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Resume a suspended domain, the process is restarted from the state where
it was frozen by calling virDomainSuspend().
This function may require privileged access
Moreover, resume may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSave"/>virDomainSave ()</h3><pre class="programlisting">int	virDomainSave			(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

See virDomainSaveFlags() for more control. Also, a save file can
be inspected or modified slightly with virDomainSaveImageGetXMLDesc()
and virDomainSaveImageDefineXML().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the output file</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveFlags"/>virDomainSaveFlags ()</h3><pre class="programlisting">int	virDomainSaveFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * to, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This method will suspend a domain and save its memory contents to
a file on disk. After the call, if successful, the domain is not
listed as running anymore (this ends the life of a transient domain).
Use virDomainRestore() to restore a domain after saving.

If the hypervisor supports it, @dxml can be used to alter
host-specific portions of the domain XML that will be used when
restoring an image. For example, it is possible to alter the
backing filename that is associated with a disk device, in order to
prepare for file renaming done as part of backing up the disk
device while the domain is stopped.

If @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will
attempt to bypass the file system cache while creating the file, or
fail if it cannot do so for the given system; this can allow less
pressure on file system cache, but also risks slowing saves to NFS.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override what state gets saved into the file. These
two flags are mutually exclusive.

A save file can be inspected or modified slightly with
virDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().

Some hypervisors may prevent this operation if there is a current
block job running; in that case, use virDomainBlockJobAbort()
to stop the block job first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>to</tt></i>:</span></td><td>path for the output file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>(optional) XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveImageDefineXML"/>virDomainSaveImageDefineXML ()</h3><pre class="programlisting">int	virDomainSaveImageDefineXML	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 const char * dxml, <br/>					 unsigned int flags)<br/>
</pre><p>This updates the definition of a domain stored in a saved state
file. @file must be a file created previously by virDomainSave()
or virDomainSaveFlags().

@dxml can be used to alter host-specific portions of the domain XML
that will be used when restoring an image. For example, it is
possible to alter the backing filename that is associated with a
disk device, to match renaming done as part of backing up the disk
device while the domain is stopped.

Normally, the saved state file will remember whether the domain was
running or paused, and restore defaults to the same state.
Specifying <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_RUNNING">VIR_DOMAIN_SAVE_RUNNING</a> or <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SAVE_PAUSED">VIR_DOMAIN_SAVE_PAUSED</a> in
@flags will override the default saved into the file; omitting both
leaves the file's default unchanged. These two flags are mutually
exclusive.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>file</tt></i>:</span></td><td>path to saved state file</td></tr><tr><td><span class="term"><i><tt>dxml</tt></i>:</span></td><td>XML config for adjusting guest xml used on restore</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSaveRestoreFlags">virDomainSaveRestoreFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSaveImageGetXMLDesc"/>virDomainSaveImageGetXMLDesc ()</h3><pre class="programlisting">char *	virDomainSaveImageGetXMLDesc	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * file, <br/>					 unsigned int flags)<br/>
</pre><p>This method will extract the XML describing the domain at the time
a saved state file was created. @file must be a file created
previously by virDomainSave() or virDomainSaveFlags().

No security-sensitive data will be included unless @flags contains
VIR_DOMAIN_SAVE_IMAGE_XML_SECURE.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>file</tt></i>:</span></td><td>path to saved state file</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainSaveImageXMLFlags">virDomainSaveImageXMLFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainScreenshot"/>virDomainScreenshot ()</h3><pre class="programlisting">char *	virDomainScreenshot		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 unsigned int screen, <br/>					 unsigned int flags)<br/>
</pre><p>Take a screenshot of current domain console as a stream. The image format
is hypervisor specific. Moreover, some hypervisors supports multiple
displays per domain. These can be distinguished by @screen argument.

This call sets up a stream; subsequent use of stream API is necessary
to transfer actual data, determine how much data is successfully
transferred, and detect any errors.

The screen ID is the sequential number of screen. In case of multiple
graphics cards, heads are enumerated before devices, e.g. having
two graphics cards, both with four heads, screen ID 5 addresses
the second head on the second card.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream to use as output</td></tr><tr><td><span class="term"><i><tt>screen</tt></i>:</span></td><td>monitor ID to take screenshot from</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a string representing the mime-type of the image format, or NULL upon error. The caller must free() the returned value.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSendKey"/>virDomainSendKey ()</h3><pre class="programlisting">int	virDomainSendKey		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int codeset, <br/>					 unsigned int holdtime, <br/>					 unsigned int * keycodes, <br/>					 int nkeycodes, <br/>					 unsigned int flags)<br/>
</pre><p>Send key(s) to the guest.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>codeset</tt></i>:</span></td><td>the code set of keycodes, from <a href="libvirt-libvirt-domain.html#virKeycodeSet">virKeycodeSet</a></td></tr><tr><td><span class="term"><i><tt>holdtime</tt></i>:</span></td><td>the duration (in milliseconds) that the keys will be held</td></tr><tr><td><span class="term"><i><tt>keycodes</tt></i>:</span></td><td>array of keycodes</td></tr><tr><td><span class="term"><i><tt>nkeycodes</tt></i>:</span></td><td>number of keycodes, up to <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_SEND_KEY_MAX_KEYS">VIR_DOMAIN_SEND_KEY_MAX_KEYS</a></td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSendProcessSignal"/>virDomainSendProcessSignal ()</h3><pre class="programlisting">int	virDomainSendProcessSignal	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 long long pid_value, <br/>					 unsigned int signum, <br/>					 unsigned int flags)<br/>
</pre><p>Send a signal to the designated process in the guest

The signal numbers must be taken from the virDomainProcessSignal
enum. These will be translated to the corresponding signal
number for the guest OS, by the guest agent delivering the
signal. If there is no mapping from <a href="libvirt-libvirt-domain.html#virDomainProcessSignal">virDomainProcessSignal</a> to
the native OS signals, this API will report an error.

If @pid_value is an integer greater than zero, it is
treated as a process ID. If @pid_value is an integer
less than zero, it is treated as a process group ID.
All the @pid_value numbers are from the container/guest
namespace. The value zero is not valid.

Not all hypervisors will support sending signals to
arbitrary processes or process groups. If this API is
implemented the minimum requirement is to be able to
use @pid_value == 1 (i.e. kill init). No other value is
required to be supported.

If the @signum is <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_PROCESS_SIGNAL_NOP">VIR_DOMAIN_PROCESS_SIGNAL_NOP</a> then this
API will simply report whether the process is running in
the container/guest.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>pid_value</tt></i>:</span></td><td>a positive integer process ID, or negative integer process group ID</td></tr><tr><td><span class="term"><i><tt>signum</tt></i>:</span></td><td>a signal from the <a href="libvirt-libvirt-domain.html#virDomainProcessSignal">virDomainProcessSignal</a> enum</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetAutostart"/>virDomainSetAutostart ()</h3><pre class="programlisting">int	virDomainSetAutostart		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int autostart)<br/>
</pre><p>Configure the domain to be automatically started
when the host machine boots.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>autostart</tt></i>:</span></td><td>whether the domain should be automatically started 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetBlkioParameters"/>virDomainSetBlkioParameters ()</h3><pre class="programlisting">int	virDomainSetBlkioParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the blkio tunables.
This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to blkio parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of blkio parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetBlockIoTune"/>virDomainSetBlockIoTune ()</h3><pre class="programlisting">int	virDomainSetBlockIoTune		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * disk, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the per-device block IO tunables.

The @disk parameter is either an unambiguous source name of the
block device (the &lt;source file='...'/&gt; sub-element, such as
"/path/to/image"), or the device target shorthand (the &lt;target
dev='...'/&gt; sub-element, such as "xvda"). Valid names can be found
by calling virDomainGetXMLDesc() and inspecting elements
within //domain/devices/disk.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>disk</tt></i>:</span></td><td>path to the block device, or device shorthand</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>Pointer to blkio parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>Number of blkio parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetBlockThreshold"/>virDomainSetBlockThreshold ()</h3><pre class="programlisting">int	virDomainSetBlockThreshold	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * dev, <br/>					 unsigned long long threshold, <br/>					 unsigned int flags)<br/>
</pre><p>Set the threshold level for delivering the
VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD if the device or backing chain element
described by @dev is written beyond the set threshold level. The threshold
level is unset once the event fires. The event might not be delivered at all
if libvirtd was not running at the moment when the threshold was reached.

Hypervisors report the last written sector of an image in the bulk stats API
(virConnectGetAllDomainStats/virDomainListGetStats) as
"block.&lt;num&gt;.allocation" in the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_STATS_BLOCK">VIR_DOMAIN_STATS_BLOCK</a> group. The current
threshold value is reported as "block.&lt;num&gt;.threshold".

This event allows to use thin-provisioned storage which needs management
tools to grow it without the need for polling of the data.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>string specifying the block device or backing chain element</td></tr><tr><td><span class="term"><i><tt>threshold</tt></i>:</span></td><td>threshold in bytes when to fire the event</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, callers should pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the operation has started, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetGuestVcpus"/>virDomainSetGuestVcpus ()</h3><pre class="programlisting">int	virDomainSetGuestVcpus		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * cpumap, <br/>					 int state, <br/>					 unsigned int flags)<br/>
</pre><p>Sets state of individual vcpus described by @cpumap via guest agent. Other
vcpus are not modified.

This API requires the VM to run. Various hypervisors or guest agent
implementation may limit to operate on just 1 vCPU per call.

@cpumap is a list of vCPU numbers. Its syntax is a comma separated list and
a special markup using '-' and '^' (ex. '0-4', '0-3,^2'). The '-' denotes
the range and the '^' denotes exclusive. The expression is sequentially
evaluated, so "0-15,^8" is identical to "9-14,0-7,15" but not identical to
"^8,0-15".

Note that OSes (notably Linux) may require vCPU 0 to stay online to support
low-level features a S3 sleep.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>cpumap</tt></i>:</span></td><td>text representation of a bitmap of vcpus to set</td></tr><tr><td><span class="term"><i><tt>state</tt></i>:</span></td><td>0 to disable/1 to enable cpus described by @cpumap</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>currently unused, callers shall pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetIOThreadParams"/>virDomainSetIOThreadParams ()</h3><pre class="programlisting">int	virDomainSetIOThreadParams	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int iothread_id, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically set IOThread parameters to the domain. It is left up to
the underlying virtual hypervisor to determine the valid range for an
@iothread_id, determining whether the @iothread_id already exists, and
determining the validity of the provided param values.

See VIR_DOMAIN_IOTHREAD_* for detailed description of accepted IOThread
parameters.

Since the purpose of this API is to dynamically modify the IOThread
@flags should only include the <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CURRENT">VIR_DOMAIN_AFFECT_CURRENT</a> and/or
VIR_DOMAIN_AFFECT_LIVE virDomainMemoryModFlags. Setting other flags
may cause errors from the hypervisor.

Note that this call can fail if the underlying virtualization hypervisor
does not support it or does not support setting the provided values.

This function requires privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>iothread_id</tt></i>:</span></td><td>the specific IOThread ID value to add</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to IOThread parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of IOThread parameters</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a> and <a href="libvirt-libvirt-common.html#virTypedParameterFlags">virTypedParameterFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetInterfaceParameters"/>virDomainSetInterfaceParameters ()</h3><pre class="programlisting">int	virDomainSetInterfaceParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * device, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change a subset or all parameters of interface; currently this
includes bandwidth parameters. The value of @flags should be
either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values
VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although
hypervisors vary in which flags are supported.

This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>device</tt></i>:</span></td><td>the interface name or mac address</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to interface parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of interface parameter (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetLifecycleAction"/>virDomainSetLifecycleAction ()</h3><pre class="programlisting">int	virDomainSetLifecycleAction	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int type, <br/>					 unsigned int action, <br/>					 unsigned int flags)<br/>
</pre><p>Changes the actions of lifecycle events for domain represented as
&lt;on_$type&gt;$action&lt;/on_$type&gt; in the domain XML.

QEMU driver has a limitation that if all lifecycle events are set
to destroy when the domain is started, it's not possible to change
any action for running domain.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>the lifecycle type from <a href="libvirt-libvirt-domain.html#virDomainLifecycle">virDomainLifecycle</a></td></tr><tr><td><span class="term"><i><tt>action</tt></i>:</span></td><td>the action type from <a href="libvirt-libvirt-domain.html#virDomainLifecycleAction">virDomainLifecycleAction</a></td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMaxMemory"/>virDomainSetMaxMemory ()</h3><pre class="programlisting">int	virDomainSetMaxMemory		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory)<br/>
</pre><p>Dynamically change the maximum amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command is hypervisor-specific for whether active, persistent,
or both configurations are changed; for more control, use
virDomainSetMemoryFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemory"/>virDomainSetMemory ()</h3><pre class="programlisting">int	virDomainSetMemory		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory)<br/>
</pre><p>Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

This command is hypervisor-specific for whether active, persistent,
or both configurations are changed; for more control, use
virDomainSetMemoryFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryFlags"/>virDomainSetMemoryFlags ()</h3><pre class="programlisting">int	virDomainSetMemoryFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned long memory, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the target amount of physical memory allocated to a
domain. If domain is NULL, then this change the amount of memory reserved
to Domain0 i.e. the domain where the application runs.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects
a running domain and will fail if domain is not active.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_MEM_MAXIMUM">VIR_DOMAIN_MEM_MAXIMUM</a> is set, the change affects domain's maximum memory
size rather than current memory size.
Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>memory</tt></i>:</span></td><td>the memory size in kibibytes (blocks of 1024 bytes)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryParameters"/>virDomainSetMemoryParameters ()</h3><pre class="programlisting">int	virDomainSetMemoryParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the memory tunables.
This function may require privileged access to the hypervisor.

Possible values for all *_limit memory tunables are in range from 0 to
VIR_DOMAIN_MEMORY_PARAM_UNLIMITED.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to memory parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of memory parameter (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMemoryStatsPeriod"/>virDomainSetMemoryStatsPeriod ()</h3><pre class="programlisting">int	virDomainSetMemoryStatsPeriod	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int period, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the domain memory balloon driver statistics collection
period. Use 0 to disable and a positive value to enable.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> or VIR_DOMAIN_AFFECT_CONFIG.
Both flags may be set. If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> is set, the change affects
a running domain and will fail if domain is not active.
If <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_CONFIG">VIR_DOMAIN_AFFECT_CONFIG</a> is set, the change affects persistent state,
and will fail for transient domains. If neither flag is specified
(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain
modifies persistent setup, while an active domain is hypervisor-dependent
on whether just live or both live and persistent state is changed.

Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object or NULL</td></tr><tr><td><span class="term"><i><tt>period</tt></i>:</span></td><td>the period in seconds for stats collection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainMemoryModFlags">virDomainMemoryModFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetMetadata"/>virDomainSetMetadata ()</h3><pre class="programlisting">int	virDomainSetMetadata		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 int type, <br/>					 const char * metadata, <br/>					 const char * key, <br/>					 const char * uri, <br/>					 unsigned int flags)<br/>
</pre><p>Sets the appropriate domain element given by @type to the
value of @metadata. A @type of VIR_DOMAIN_METADATA_DESCRIPTION
is free-form text; <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_METADATA_TITLE">VIR_DOMAIN_METADATA_TITLE</a> is free-form, but no
newlines are permitted, and should be short (although the length is
not enforced). For these two options @key and @uri are irrelevant and
must be set to NULL.

For type <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_METADATA_ELEMENT">VIR_DOMAIN_METADATA_ELEMENT</a> @metadata must be well-formed
XML belonging to namespace defined by @uri with local name @key.

Passing NULL for @metadata says to remove that element from the
domain XML (passing the empty string leaves the element present).

The resulting metadata will be present in virDomainGetXMLDesc(),
as well as quick access through virDomainGetMetadata().

@flags controls whether the live domain, persistent configuration,
or both will be modified.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>type of metadata, from <a href="libvirt-libvirt-domain.html#virDomainMetadataType">virDomainMetadataType</a></td></tr><tr><td><span class="term"><i><tt>metadata</tt></i>:</span></td><td>new metadata text</td></tr><tr><td><span class="term"><i><tt>key</tt></i>:</span></td><td>XML namespace key, or NULL</td></tr><tr><td><span class="term"><i><tt>uri</tt></i>:</span></td><td>XML namespace URI, or NULL</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetNumaParameters"/>virDomainSetNumaParameters ()</h3><pre class="programlisting">int	virDomainSetNumaParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Change all or a subset of the numa tunables.
This function may require privileged access to the hypervisor.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to numa parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of numa parameters (this value can be the same or less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetPerfEvents"/>virDomainSetPerfEvents ()</h3><pre class="programlisting">int	virDomainSetPerfEvents		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams, <br/>					 unsigned int flags)<br/>
</pre><p>Enable or disable the particular list of Linux perf events you
care about. The @params argument should contain any subset of
VIR_PERF_EVENT_ macros.

Linux perf events are performance analyzing tool in Linux.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to perf events parameter object</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of perf event parameters (this value can be the same less than the number of parameters supported)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetSchedulerParameters"/>virDomainSetSchedulerParameters ()</h3><pre class="programlisting">int	virDomainSetSchedulerParameters	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>					 int nparams)<br/>
</pre><p>Change all or a subset or the scheduler parameters. It is
hypervisor-specific whether this sets live, persistent, or both
settings; for more control, use
virDomainSetSchedulerParametersFlags.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetSchedulerParametersFlags"/>virDomainSetSchedulerParametersFlags ()</h3><pre class="programlisting">int	virDomainSetSchedulerParametersFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>						 <a href="libvirt-libvirt-common.html#virTypedParameterPtr">virTypedParameterPtr</a> params, <br/>						 int nparams, <br/>						 unsigned int flags)<br/>
</pre><p>Change a subset or all scheduler parameters. The value of @flags
should be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of
values from <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> and
VIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which
flags are supported.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>params</tt></i>:</span></td><td>pointer to scheduler parameter objects</td></tr><tr><td><span class="term"><i><tt>nparams</tt></i>:</span></td><td>number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case of error, 0 in case of success.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetTime"/>virDomainSetTime ()</h3><pre class="programlisting">int	virDomainSetTime		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 long long seconds, <br/>					 unsigned int nseconds, <br/>					 unsigned int flags)<br/>
</pre><p>When a domain is suspended or restored from a file the
domain's OS has no idea that there was a big gap in the time.
Depending on how long the gap was, NTP might not be able to
resynchronize the guest.

This API tries to set guest time to the given value. The time
to set (@seconds and @nseconds) should be in seconds relative
to the Epoch of 1970-01-01 00:00:00 in UTC.

Please note that some hypervisors may require guest agent to
be configured and running in order to be able to run this API.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>seconds</tt></i>:</span></td><td>time to set</td></tr><tr><td><span class="term"><i><tt>nseconds</tt></i>:</span></td><td>the nanosecond part of @seconds</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSetTimeFlags">virDomainSetTimeFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetUserPassword"/>virDomainSetUserPassword ()</h3><pre class="programlisting">int	virDomainSetUserPassword	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> dom, <br/>					 const char * user, <br/>					 const char * password, <br/>					 unsigned int flags)<br/>
</pre><p>Sets the @user password to the value specified by @password.
If @flags contain VIR_DOMAIN_PASSWORD_ENCRYPTED, the password
is assumed to be encrypted by the method required by the guest OS.

Please note that some hypervisors may require guest agent to
be configured and running in order to be able to run this API.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dom</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>user</tt></i>:</span></td><td>the username that will get a new password</td></tr><tr><td><span class="term"><i><tt>password</tt></i>:</span></td><td>the password to set</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainSetUserPasswordFlags">virDomainSetUserPasswordFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetVcpu"/>virDomainSetVcpu ()</h3><pre class="programlisting">int	virDomainSetVcpu		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * vcpumap, <br/>					 int state, <br/>					 unsigned int flags)<br/>
</pre><p>Enables/disables individual vcpus described by @vcpumap in the hypervisor.

Various hypervisor implementations may limit to operate on just 1
hotpluggable entity (which may contain multiple vCPUs on certain platforms).

Note that OSes and hypervisors may require vCPU 0 to stay online.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>vcpumap</tt></i>:</span></td><td>text representation of a bitmap of vcpus to set</td></tr><tr><td><span class="term"><i><tt>state</tt></i>:</span></td><td>0 to disable/1 to enable cpus described by @vcpumap</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainModificationImpact">virDomainModificationImpact</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetVcpus"/>virDomainSetVcpus ()</h3><pre class="programlisting">int	virDomainSetVcpus		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus)<br/>
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function may require privileged access to the hypervisor.

Note that if this call is executed before the guest has finished booting,
the guest may fail to process the change.

This command only changes the runtime configuration of the domain,
so can only be called on an active domain. It is hypervisor-dependent
whether it also affects persistent configuration; for more control,
use virDomainSetVcpusFlags().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSetVcpusFlags"/>virDomainSetVcpusFlags ()</h3><pre class="programlisting">int	virDomainSetVcpusFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int nvcpus, <br/>					 unsigned int flags)<br/>
</pre><p>Dynamically change the number of virtual CPUs used by the domain.
Note that this call may fail if the underlying virtualization hypervisor
does not support it or if growing the number is arbitrarily limited.
This function may require privileged access to the hypervisor.

@flags may include <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> to affect a running
domain (which may fail if domain is not active), or
VIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML
description of the domain. Both flags may be set.
If neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),
then an inactive domain modifies persistent setup, while an active domain
is hypervisor-dependent on whether just live or both live and persistent
state is changed.

Note that if this call is executed before the guest has finished booting,
the guest may fail to process the change.

If @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then
VIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual
CPU limit is altered; generally, this value must be less than or
equal to virConnectGetMaxVcpus(). Otherwise, this call affects the
current virtual CPU limit, which must be less than or equal to the
maximum limit. Note that hypervisors may not allow changing the maximum
vcpu count if processor topology is specified.

If @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is
modified inside the guest instead of the hypervisor. This flag can only
be used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.
The usage of this flag may require a guest agent configured.

Not all hypervisors can support all flag combinations.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object, or NULL for Domain0</td></tr><tr><td><span class="term"><i><tt>nvcpus</tt></i>:</span></td><td>the new number of virtual CPUs for this domain, must be at least 1</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainVcpuFlags">virDomainVcpuFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdown"/>virDomainShutdown ()</h3><pre class="programlisting">int	virDomainShutdown		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Shutdown a domain, the domain object is still usable thereafter, but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guests disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainShutdownFlags"/>virDomainShutdownFlags ()</h3><pre class="programlisting">int	virDomainShutdownFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Shutdown a domain, the domain object is still usable thereafter but
the domain OS is being stopped. Note that the guest OS may ignore the
request. Additionally, the hypervisor may check and support the domain
'on_poweroff' XML setting resulting in a domain that reboots instead of
shutting down. For guests that react to a shutdown request, the differences
from virDomainDestroy() are that the guest's disk storage will be in a
stable state rather than having the (virtual) power cord pulled, and
this command returns as soon as the shutdown request is issued rather
than blocking until the guest is no longer running.

If the domain is transient and has any snapshot metadata (see
virDomainSnapshotNum()), then that metadata will automatically
be deleted when the domain quits.

If @flags is set to zero, then the hypervisor will choose the
method of shutdown it considers best. To have greater control
pass one or more of the virDomainShutdownFlagValues. The order
in which the hypervisor tries each shutdown method is undefined,
and a hypervisor is not required to support all methods.

To use guest agent (VIR_DOMAIN_SHUTDOWN_GUEST_AGENT) the domain XML
must have &lt;channel&gt; configured.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainShutdownFlagValues">virDomainShutdownFlagValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainStatsRecordListFree"/>virDomainStatsRecordListFree ()</h3><pre class="programlisting">void	virDomainStatsRecordListFree	(<a href="libvirt-libvirt-domain.html#virDomainStatsRecordPtr">virDomainStatsRecordPtr</a> * stats)<br/>
</pre><p>Convenience function to free a list of domain stats returned by
virDomainListGetStats and virConnectGetAllDomainStats.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stats</tt></i>:</span></td><td>NULL terminated array of virDomainStatsRecords to free</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainSuspend"/>virDomainSuspend ()</h3><pre class="programlisting">int	virDomainSuspend		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Suspends an active domain, the process is frozen without further access
to CPU resources and I/O but the memory used by the domain at the
hypervisor level will stay allocated. Use virDomainResume() to reactivate
the domain.
This function may require privileged access.
Moreover, suspend may not be supported if domain is in some
special state like VIR_DOMAIN_PMSUSPENDED.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>a domain object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefine"/>virDomainUndefine ()</h3><pre class="programlisting">int	virDomainUndefine		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain)<br/>
</pre><p>Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see
virDomainHasManagedSaveImage()), or if it is inactive and has any
snapshot metadata (see virDomainSnapshotNum()) or checkpoint
metadata (see virDomainListAllCheckpoints()), then the undefine
will fail. See virDomainUndefineFlags() for more control.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUndefineFlags"/>virDomainUndefineFlags ()</h3><pre class="programlisting">int	virDomainUndefineFlags		(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 unsigned int flags)<br/>
</pre><p>Undefine a domain. If the domain is running, it's converted to
transient domain, without stopping it. If the domain is inactive,
the domain configuration is removed.

If the domain has a managed save image (see virDomainHasManagedSaveImage()),
then including <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_UNDEFINE_MANAGED_SAVE">VIR_DOMAIN_UNDEFINE_MANAGED_SAVE</a> in @flags will also remove
that file, and omitting the flag will cause the undefine process to fail.

If the domain is inactive and has any snapshot metadata (see
virDomainSnapshotNum()), then including
VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove
that metadata. Omitting the flag will cause the undefine of an
inactive domain with snapshots to fail. Active domains will retain
snapshot metadata until the (now-transient) domain halts,
regardless of whether this flag is present. On hypervisors that
support snapshots, but where snapshots do not use libvirt metadata,
this flag has no effect.

If the domain is inactive and has any checkpoint metadata (see
virDomainListAllCheckpoints()), then including
VIR_DOMAIN_UNDEFINE_CHECKPOINTS_METADATA in @flags will also remove
that metadata. Omitting the flag will cause the undefine of an
inactive domain with checkpoints to fail. Active domains will
retain checkpoint metadata until the (now-transient) domain halts,
regardless of whether this flag is present. On hypervisors that
support checkpoints, but where checkpoints do not use libvirt
metadata, this flag has no effect.

If the domain has any nvram specified, the undefine process will fail
unless <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_UNDEFINE_KEEP_NVRAM">VIR_DOMAIN_UNDEFINE_KEEP_NVRAM</a> is specified, or if
VIR_DOMAIN_UNDEFINE_NVRAM is specified to remove the nvram file.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to a defined domain</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of supported <a href="libvirt-libvirt-domain.html#virDomainUndefineFlagsValues">virDomainUndefineFlagsValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virDomainUpdateDeviceFlags"/>virDomainUpdateDeviceFlags ()</h3><pre class="programlisting">int	virDomainUpdateDeviceFlags	(<a href="libvirt-libvirt-domain.html#virDomainPtr">virDomainPtr</a> domain, <br/>					 const char * xml, <br/>					 unsigned int flags)<br/>
</pre><p>Change a virtual device on a domain, using the flags parameter
to control how the device is changed. VIR_DOMAIN_AFFECT_CURRENT
specifies that the device change is made based on current domain
state. <a href="libvirt-libvirt-domain.html#VIR_DOMAIN_AFFECT_LIVE">VIR_DOMAIN_AFFECT_LIVE</a> specifies that the device shall be
changed on the active domain instance only and is not added to the
persisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG
specifies that the device shall be changed on the persisted domain
configuration only. Note that the target hypervisor must return an
error if unable to satisfy flags. E.g. the hypervisor driver will
return failure if LIVE is specified but it only supports modifying the
persisted device allocation.

This method is used for actions such changing CDROM/Floppy device
media, altering the graphics configuration such as password,
reconfiguring the NIC device backend connectivity, etc.

The supplied XML description of the device should contain all
the information that is found in the corresponding domain XML.
Leaving out any piece of information may be treated as a
request for its removal, which may be denied. For instance,
when users want to change CDROM media only for live XML, they
must provide live disk XML as found in the corresponding live
domain XML with only the disk path changed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>domain</tt></i>:</span></td><td>pointer to domain object</td></tr><tr><td><span class="term"><i><tt>xml</tt></i>:</span></td><td>pointer to XML description of one device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-domain.html#virDomainDeviceModifyFlags">virDomainDeviceModifyFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
      </div>
    </div>
  </body>
</html>
