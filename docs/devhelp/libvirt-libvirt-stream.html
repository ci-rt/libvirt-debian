<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>libvirt-stream: APIs for management of streams</title>
    <meta name="generator" content="Libvirt devhelp stylesheet"/>
    <link rel="start" href="index.html" title="libvirt Reference Manual"/>
    <link rel="up" href="general.html" title="API"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <link rel="chapter" href="general.html" title="API"/>
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
    <table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
      <tr valign="middle">
        <td>
          <a accesskey="p" href="libvirt-libvirt-storage.html">
            <img src="left.png" width="24" height="24" border="0" alt="Prev"/>
          </a>
        </td>
        <td>
          <a accesskey="u" href="general.html">
            <img src="up.png" width="24" height="24" border="0" alt="Up"/>
          </a>
        </td>
        <td>
          <a accesskey="h" href="index.html">
            <img src="home.png" width="24" height="24" border="0" alt="Home"/>
          </a>
        </td>
        <td>
          <a accesskey="n" href="libvirt-virterror.html">
            <img src="right.png" width="24" height="24" border="0" alt="Next"/>
          </a>
        </td>
        <th width="100%" align="center">libvirt Reference Manual</th>
      </tr>
    </table>
    <h2>
      <span class="refentrytitle">libvirt-stream</span>
    </h2>
    <p>libvirt-stream - APIs for management of streams</p>
    <p>Provides APIs for the management of streams  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </p>
    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>
      <pre class="synopsis">typedef enum <a href="#virStreamEventType">virStreamEventType</a>;
typedef enum <a href="#virStreamFlags">virStreamFlags</a>;
typedef enum <a href="#virStreamRecvFlagsValues">virStreamRecvFlagsValues</a>;
int	<a href="#virStreamAbort">virStreamAbort</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamEventAddCallback">virStreamEventAddCallback</a>	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> ff);
typedef void <a href="#virStreamEventCallback">virStreamEventCallback</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 void * opaque);
int	<a href="#virStreamEventRemoveCallback">virStreamEventRemoveCallback</a>	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamEventUpdateCallback">virStreamEventUpdateCallback</a>	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events);
int	<a href="#virStreamFinish">virStreamFinish</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamFree">virStreamFree</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream);
<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a>	<a href="#virStreamNew">virStreamNew</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags);
int	<a href="#virStreamRecv">virStreamRecv</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes);
int	<a href="#virStreamRecvAll">virStreamRecvAll</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 void * opaque);
int	<a href="#virStreamRecvFlags">virStreamRecvFlags</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 unsigned int flags);
int	<a href="#virStreamRecvHole">virStreamRecvHole</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 long long * length, <br/>					 unsigned int flags);
int	<a href="#virStreamRef">virStreamRef</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream);
int	<a href="#virStreamSend">virStreamSend</a>			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 const char * data, <br/>					 size_t nbytes);
int	<a href="#virStreamSendAll">virStreamSendAll</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 void * opaque);
int	<a href="#virStreamSendHole">virStreamSendHole</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 long long length, <br/>					 unsigned int flags);
typedef int <a href="#virStreamSinkFunc">virStreamSinkFunc</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 const char * data, <br/>					 size_t nbytes, <br/>					 void * opaque);
typedef int <a href="#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 long long length, <br/>					 void * opaque);
typedef int <a href="#virStreamSourceFunc">virStreamSourceFunc</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 void * opaque);
typedef int <a href="#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 int * inData, <br/>					 long long * length, <br/>					 void * opaque);
typedef int <a href="#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 long long length, <br/>					 void * opaque);
int	<a href="#virStreamSparseRecvAll">virStreamSparseRecvAll</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a> holeHandler, <br/>					 void * opaque);
int	<a href="#virStreamSparseSendAll">virStreamSparseSendAll</a>		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a> holeHandler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a> skipHandler, <br/>					 void * opaque);
</pre>
    </div>
    <div class="refsect1" lang="en">
      <h2>Description</h2>
    </div>
    <div class="refsect1" lang="en">
      <h2>Details</h2>
      <div class="refsect2" lang="en">
        <div class="refsect2" lang="en"><h3><a name="virStreamEventType">Enum </a>virStreamEventType</h3><pre class="programlisting">enum <a href="#virStreamEventType">virStreamEventType</a> {
    <a name="VIR_STREAM_EVENT_READABLE">VIR_STREAM_EVENT_READABLE</a> = 1
    <a name="VIR_STREAM_EVENT_WRITABLE">VIR_STREAM_EVENT_WRITABLE</a> = 2
    <a name="VIR_STREAM_EVENT_ERROR">VIR_STREAM_EVENT_ERROR</a> = 4
    <a name="VIR_STREAM_EVENT_HANGUP">VIR_STREAM_EVENT_HANGUP</a> = 8
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFlags">Enum </a>virStreamFlags</h3><pre class="programlisting">enum <a href="#virStreamFlags">virStreamFlags</a> {
    <a name="VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecvFlagsValues">Enum </a>virStreamRecvFlagsValues</h3><pre class="programlisting">enum <a href="#virStreamRecvFlagsValues">virStreamRecvFlagsValues</a> {
    <a name="VIR_STREAM_RECV_STOP_AT_HOLE">VIR_STREAM_RECV_STOP_AT_HOLE</a> = 1
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventCallback"/>Function type virStreamEventCallback</h3><pre class="programlisting">void	virStreamEventCallback		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 void * opaque)<br/>
</pre><p>Callback for receiving stream events. The callback will
be invoked once for each event which is pending.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>stream on which the event occurred</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>bitset of events from <a href="libvirt-libvirt-event.html#virEventHandleType">virEventHandleType</a> constants</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>user data registered with handle</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSinkFunc"/>Function type virStreamSinkFunc</h3><pre class="programlisting">int	virStreamSinkFunc		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 const char * data, <br/>					 size_t nbytes, <br/>					 void * opaque)<br/>
</pre><p>The <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> callback is used together with the
virStreamRecvAll or <a href="libvirt-libvirt-stream.html#virStreamSparseRecvAll">virStreamSparseRecvAll</a> functions for
libvirt to provide the data that has been received.

The callback will be invoked multiple times,
providing data in small chunks. The application
should consume up 'nbytes' from the 'data' array
of data and then return the number actual number
of bytes consumed. The callback will continue to be
invoked until it indicates the end of the stream
has been reached. A return value of -1 at any time
will abort the receive operation

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes consumed or -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSinkHoleFunc"/>Function type virStreamSinkHoleFunc</h3><pre class="programlisting">int	virStreamSinkHoleFunc		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 long long length, <br/>					 void * opaque)<br/>
</pre><p>This callback is used together with the virStreamSparseRecvAll
function for libvirt to provide the size of a hole that
occurred in the stream.

The callback may be invoked multiple times as holes are found
during processing a stream. The application should create the
hole in the stream target and then return. A return value of
-1 at any time will abort the receive operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>stream hole size</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSourceFunc"/>Function type virStreamSourceFunc</h3><pre class="programlisting">int	virStreamSourceFunc		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 void * opaque)<br/>
</pre><p>The <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> callback is used together with
the <a href="libvirt-libvirt-stream.html#virStreamSendAll">virStreamSendAll</a> and <a href="libvirt-libvirt-stream.html#virStreamSparseSendAll">virStreamSparseSendAll</a> functions
for libvirt to obtain the data that is to be sent.

The callback will be invoked multiple times,
fetching data in small chunks. The application
should fill the 'data' array with up to 'nbytes'
of data and then return the number actual number
of bytes. The callback will continue to be
invoked until it indicates the end of the source
has been reached by returning 0. A return value
of -1 at any time will abort the send operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>preallocated array to be filled with data</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of the data array</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes filled, 0 upon end of file, or -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSourceHoleFunc"/>Function type virStreamSourceHoleFunc</h3><pre class="programlisting">int	virStreamSourceHoleFunc		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 int * inData, <br/>					 long long * length, <br/>					 void * opaque)<br/>
</pre><p>The <a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a> callback is used together with the
virStreamSparseSendAll function for libvirt to obtain the
length of section stream is currently in.

Moreover, upon successful return, @length should be updated
with how many bytes are left until the current section ends
(either data section or hole section). Also the stream is
currently in data section, @inData should be set to a non-zero
value and vice versa.

NB: there's an implicit hole at the end of each file. If
that's the case, @inData and @length should be both set to 0.

This function should not adjust the current position within
the file.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>inData</tt></i>:</span></td><td>are we in data section</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>how long is the section we are currently in</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSourceSkipFunc"/>Function type virStreamSourceSkipFunc</h3><pre class="programlisting">int	virStreamSourceSkipFunc		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st, <br/>					 long long length, <br/>					 void * opaque)<br/>
</pre><p>This callback is used together with the virStreamSparseSendAll
to skip holes in the underlying file as reported by
virStreamSourceHoleFunc.

The callback may be invoked multiple times as holes are found
during processing a stream. The application should skip
processing the hole in the stream source and then return.
A return value of -1 at any time will abort the send operation.

Please note that for more accurate error reporting the
callback should set appropriate errno on failure.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>st</tt></i>:</span></td><td>the stream object</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>stream hole size</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>optional application provided data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamAbort"/>virStreamAbort ()</h3><pre class="programlisting">int	virStreamAbort			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Request that the in progress data transfer be cancelled
abnormally before the end of the stream has been reached.
For output streams this can be used to inform the driver
that the stream is being terminated early. For input
streams this can be used to inform the driver that it
should stop sending data.

If the stream is non-blocking, any callback must be removed
beforehand.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventAddCallback"/>virStreamEventAddCallback ()</h3><pre class="programlisting">int	virStreamEventAddCallback	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamEventCallback">virStreamEventCallback</a> cb, <br/>					 void * opaque, <br/>					 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> ff)<br/>
</pre><p>Register a callback to be notified when a stream
becomes writable, or readable. This is most commonly
used in conjunction with non-blocking data streams
to integrate into an event loop</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to invoke when an event occurs</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>ff</tt></i>:</span></td><td>callback to free @opaque data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventRemoveCallback"/>virStreamEventRemoveCallback ()</h3><pre class="programlisting">int	virStreamEventRemoveCallback	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Remove an event callback from the stream</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamEventUpdateCallback"/>virStreamEventUpdateCallback ()</h3><pre class="programlisting">int	virStreamEventUpdateCallback	(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 int events)<br/>
</pre><p>Changes the set of events to monitor for a stream. This allows
for event notification to be changed without having to
unregister &amp; register the callback completely. This method
is guaranteed to succeed if a callback is already registered</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>events</tt></i>:</span></td><td>set of events to monitor</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 if no callback is registered</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFinish"/>virStreamFinish ()</h3><pre class="programlisting">int	virStreamFinish			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Indicate that there is no further data to be transmitted
on the stream. For output streams this should be called once
all data has been written. For input streams this should be
called once <a href="libvirt-libvirt-stream.html#virStreamRecv">virStreamRecv</a> returns end-of-file.

This method is a synchronization point for all asynchronous
errors, so if this returns a success code the application can
be sure that all data has been successfully processed.

If the stream is non-blocking, any callback must be removed
beforehand.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamFree"/>virStreamFree ()</h3><pre class="programlisting">int	virStreamFree			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Decrement the reference count on a stream, releasing
the stream object if the reference count has hit zero.

There must not be an active data transfer in progress
when releasing the stream. If a stream needs to be
disposed of prior to end of stream being reached, then
the <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a> function should be called first.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 upon success, or -1 on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamNew"/>virStreamNew ()</h3><pre class="programlisting"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a>	virStreamNew		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 unsigned int flags)<br/>
</pre><p>Creates a new stream object which can be used to perform
streamed I/O with other public API function.

When no longer needed, a stream object must be released
with virStreamFree. If a data stream has been used,
then the application must call <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a> or
virStreamAbort before free'ing to, in order to notify
the driver of termination.

If a non-blocking data stream is required passed
VIR_STREAM_NONBLOCK for flags, otherwise pass 0.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-stream.html#virStreamFlags">virStreamFlags</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new stream, or NULL upon error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecv"/>virStreamRecv ()</h3><pre class="programlisting">int	virStreamRecv			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes)<br/>
</pre><p>Reads a series of bytes from the stream. This method may
block the calling application for an arbitrary amount
of time.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file download
API looks like

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY, 0600);

 virConnectDownloadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = virStreamRecv(st, buf, 1024);
 if (got &lt; 0) {
 virStreamAbort(st);
 break;
 }
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = write(fd, buf + offset, got - offset);
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
 done:
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to read into from stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes read, which may be less than requested. Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecvAll"/>virStreamRecvAll ()</h3><pre class="programlisting">int	virStreamRecvAll		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 void * opaque)<br/>
</pre><p>Receive the entire data stream, sending the data to the
requested data sink. This is simply a convenient alternative
to virStreamRecv, for apps that do blocking-I/O.

An example using this with a hypothetical file download
API looks like

 int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return write(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY);

 virConnectUploadFile(conn, st);
 if (virStreamRecvAll(st, mysink, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>sink callback for writing data to application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecvFlags"/>virStreamRecvFlags ()</h3><pre class="programlisting">int	virStreamRecvFlags		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 char * data, <br/>					 size_t nbytes, <br/>					 unsigned int flags)<br/>
</pre><p>Reads a series of bytes from the stream. This method may
block the calling application for an arbitrary amount
of time.

This is just like <a href="libvirt-libvirt-stream.html#virStreamRecv">virStreamRecv</a> except this one has extra
@flags. Calling this function with no @flags set (equal to
zero) is equivalent to calling virStreamRecv(stream, data, nbytes).

If flag <a href="libvirt-libvirt-stream.html#VIR_STREAM_RECV_STOP_AT_HOLE">VIR_STREAM_RECV_STOP_AT_HOLE</a> is set, this function
will stop reading from stream if it has reached a hole. In
that case, -3 is returned and virStreamRecvHole() should be
called to get the hole size. An example using this flag might
look like this:

 while (1) {
 char buf[4096];

 int ret = virStreamRecvFlags(st, buf, len, VIR_STREAM_STOP_AT_HOLE);
 if (ret &lt; 0) {
 if (ret == -3) {
 long long len;
 ret = virStreamRecvHole(st, &amp;len, 0);
 if (ret &lt; 0) {
 ...error..
 } else {
 ...seek len bytes in target...
 }
 } else {
 return -1;
 }
 } else {
 ...write buf to target...
 }
 }</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to read into from stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of <a href="libvirt-libvirt-stream.html#virStreamRecvFlagsValues">virStreamRecvFlagsValues</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking. Returns -3 if there is a hole in stream and caller requested to stop at a hole.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRecvHole"/>virStreamRecvHole ()</h3><pre class="programlisting">int	virStreamRecvHole		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 long long * length, <br/>					 unsigned int flags)<br/>
</pre><p>This API is used to determine the @length in bytes of the
empty space to be created in a @stream's target file when
uploading or downloading sparsely populated files. This is the
counterpart to virStreamSendHole().</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>number of bytes to skip</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on error or when there's currently no hole in the stream</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamRef"/>virStreamRef ()</h3><pre class="programlisting">int	virStreamRef			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream)<br/>
</pre><p>Increment the reference count on the stream. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> to release the reference count, once
the caller no longer needs the reference to this object.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSend"/>virStreamSend ()</h3><pre class="programlisting">int	virStreamSend			(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 const char * data, <br/>					 size_t nbytes)<br/>
</pre><p>Write a series of bytes to the stream. This method may
block the calling application for an arbitrary amount
of time. Once an application has finished sending data
it should call <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a> to wait for successful
confirmation from the driver, or detect any error.

This method may not be used if a stream source has been
registered.

Errors are not guaranteed to be reported synchronously
with the call, but may instead be delayed until a
subsequent call.

An example using this with a hypothetical file upload
API looks like

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY);

 virConnectUploadFile(conn, "demo.iso", st);

 while (1) {
 char buf[1024];
 int got = read(fd, buf, 1024);
 if (got &lt; 0) {
 virStreamAbort(st);
 break;
 }
 if (got == 0) {
 virStreamFinish(st);
 break;
 }
 int offset = 0;
 while (offset &lt; got) {
 int sent = virStreamSend(st, buf+offset, got-offset);
 if (sent &lt; 0) {
 virStreamAbort(st);
 goto done;
 }
 offset += sent;
 }
 }
 if (virStreamFinish(st) &lt; 0)
 ... report an error ....
 done:
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>buffer to write to stream</td></tr><tr><td><span class="term"><i><tt>nbytes</tt></i>:</span></td><td>size of @data buffer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of bytes written, which may be less than requested. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree. Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSendAll"/>virStreamSendAll ()</h3><pre class="programlisting">int	virStreamSendAll		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 void * opaque)<br/>
</pre><p>Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/O.

An example using this with a hypothetical file upload
API looks like

 int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return read(*fd, buf, nbytes);
 }

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY);

 virConnectUploadFile(conn, st);
 if (virStreamSendAll(st, mysource, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>source callback for reading data from application</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree().</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSendHole"/>virStreamSendHole ()</h3><pre class="programlisting">int	virStreamSendHole		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 long long length, <br/>					 unsigned int flags)<br/>
</pre><p>Rather than transmitting empty file space, this API directs
the @stream target to create @length bytes of empty space.
This API would be used when uploading or downloading sparsely
populated files to avoid the needless copy of empty file
space.

An example using this with a hypothetical file upload API
looks like:

 <a href="libvirt-libvirt-host.html#virStream">virStream</a> st;

 while (1) {
 char buf[4096];
 size_t len;
 if (..in hole...) {
 ..get hole size...
 virStreamSendHole(st, len, 0);
 } else {
 ...read len bytes...
 virStreamSend(st, buf, len);
 }
 }</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>length</tt></i>:</span></td><td>number of bytes to skip</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSparseRecvAll"/>virStreamSparseRecvAll ()</h3><pre class="programlisting">int	virStreamSparseRecvAll		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> handler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a> holeHandler, <br/>					 void * opaque)<br/>
</pre><p>Receive the entire data stream, sending the data to the
requested data sink @handler and calling the skip @holeHandler
to generate holes for sparse stream targets. This is simply a
convenient alternative to virStreamRecvFlags, for apps that do
blocking-I/O.

An example using this with a hypothetical file download
API looks like:

 int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return write(*fd, buf, nbytes);
 }

 int myskip(virStreamPtr st, long long offset, void *opaque) {
 int *fd = opaque;

 return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
 }

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_WRONLY);

 virConnectDownloadSparseFile(conn, st);
 if (virStreamSparseRecvAll(st, mysink, myskip, &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);

Note that @opaque data is shared between both @handler and
@holeHandler callbacks.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>sink callback for writing data to application</td></tr><tr><td><span class="term"><i><tt>holeHandler</tt></i>:</span></td><td>stream hole callback for skipping holes</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree(st). Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree().</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virStreamSparseSendAll"/>virStreamSparseSendAll ()</h3><pre class="programlisting">int	virStreamSparseSendAll		(<a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> stream, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> handler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a> holeHandler, <br/>					 <a href="libvirt-libvirt-stream.html#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a> skipHandler, <br/>					 void * opaque)<br/>
</pre><p>Send the entire data stream, reading the data from the
requested data source. This is simply a convenient alternative
to virStreamSend, for apps that do blocking-I/O.

An example using this with a hypothetical file upload
API looks like

 int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
 int *fd = opaque;

 return read(*fd, buf, nbytes);
 }

 int myskip(virStreamPtr st, long long offset, void *opaque) {
 int *fd = opaque;

 return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
 }

 int myindata(virStreamPtr st, int *inData,
 long long *offset, void *opaque) {
 int *fd = opaque;

 if (@fd in hole) {
 *inData = 0;
 *offset = holeSize;
 } else {
 *inData = 1;
 *offset = dataSize;
 }

 return 0;
 }

 <a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a> st = virStreamNew(conn, 0);
 int fd = open("demo.iso", O_RDONLY);

 virConnectUploadSparseFile(conn, st);
 if (virStreamSparseSendAll(st,
 mysource,
 myindata,
 myskip,
 &amp;fd) &lt; 0) {
 ...report an error ...
 goto done;
 }
 if (virStreamFinish(st) &lt; 0)
 ...report an error...
 virStreamFree(st);
 close(fd);

Note that @opaque data are shared between @handler, @holeHandler and @skipHandler.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>stream</tt></i>:</span></td><td>pointer to the stream object</td></tr><tr><td><span class="term"><i><tt>handler</tt></i>:</span></td><td>source callback for reading data from application</td></tr><tr><td><span class="term"><i><tt>holeHandler</tt></i>:</span></td><td>source callback for determining holes</td></tr><tr><td><span class="term"><i><tt>skipHandler</tt></i>:</span></td><td>skip holes as reported by @holeHandler</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application defined data</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree. Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree().</td></tr></tbody></table></div></div>
        <hr/>
      </div>
    </div>
  </body>
</html>
