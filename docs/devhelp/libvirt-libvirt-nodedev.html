<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>libvirt-nodedev: APIs for management of nodedevs</title>
    <meta name="generator" content="Libvirt devhelp stylesheet"/>
    <link rel="start" href="index.html" title="libvirt Reference Manual"/>
    <link rel="up" href="general.html" title="API"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <link rel="chapter" href="general.html" title="API"/>
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
    <table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
      <tr valign="middle">
        <td>
          <a accesskey="p" href="libvirt-libvirt-network.html">
            <img src="left.png" width="24" height="24" border="0" alt="Prev"/>
          </a>
        </td>
        <td>
          <a accesskey="u" href="general.html">
            <img src="up.png" width="24" height="24" border="0" alt="Up"/>
          </a>
        </td>
        <td>
          <a accesskey="h" href="index.html">
            <img src="home.png" width="24" height="24" border="0" alt="Home"/>
          </a>
        </td>
        <td>
          <a accesskey="n" href="libvirt-libvirt-nwfilter.html">
            <img src="right.png" width="24" height="24" border="0" alt="Next"/>
          </a>
        </td>
        <th width="100%" align="center">libvirt Reference Manual</th>
      </tr>
    </table>
    <h2>
      <span class="refentrytitle">libvirt-nodedev</span>
    </h2>
    <p>libvirt-nodedev - APIs for management of nodedevs</p>
    <p>Provides APIs for the management of nodedevs  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;. </p>
    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>
      <pre class="synopsis">#define <a href="#VIR_NODE_DEVICE_EVENT_CALLBACK">VIR_NODE_DEVICE_EVENT_CALLBACK</a>;
typedef enum <a href="#virConnectListAllNodeDeviceFlags">virConnectListAllNodeDeviceFlags</a>;
typedef struct _virNodeDevice <a href="#virNodeDevice">virNodeDevice</a>;
typedef enum <a href="#virNodeDeviceEventID">virNodeDeviceEventID</a>;
typedef enum <a href="#virNodeDeviceEventLifecycleType">virNodeDeviceEventLifecycleType</a>;
typedef <a href="libvirt-libvirt-nodedev.html#virNodeDevice">virNodeDevice</a> * <a href="#virNodeDevicePtr">virNodeDevicePtr</a>;
int	<a href="#virConnectListAllNodeDevices">virConnectListAllNodeDevices</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> ** devices, <br/>					 unsigned int flags);
int	<a href="#virConnectNodeDeviceEventDeregisterAny">virConnectNodeDeviceEventDeregisterAny</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID);
typedef void <a href="#virConnectNodeDeviceEventGenericCallback">virConnectNodeDeviceEventGenericCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>							 void * opaque);
typedef void <a href="#virConnectNodeDeviceEventLifecycleCallback">virConnectNodeDeviceEventLifecycleCallback</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>							 int event, <br/>							 int detail, <br/>							 void * opaque);
int	<a href="#virConnectNodeDeviceEventRegisterAny">virConnectNodeDeviceEventRegisterAny</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt-nodedev.html#virConnectNodeDeviceEventGenericCallback">virConnectNodeDeviceEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb);
<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceCreateXML">virNodeDeviceCreateXML</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags);
int	<a href="#virNodeDeviceDestroy">virNodeDeviceDestroy</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceDetachFlags">virNodeDeviceDetachFlags</a>	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 const char * driverName, <br/>					 unsigned int flags);
int	<a href="#virNodeDeviceDettach">virNodeDeviceDettach</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceFree">virNodeDeviceFree</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
const char *	<a href="#virNodeDeviceGetName">virNodeDeviceGetName</a>	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
const char *	<a href="#virNodeDeviceGetParent">virNodeDeviceGetParent</a>	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
char *	<a href="#virNodeDeviceGetXMLDesc">virNodeDeviceGetXMLDesc</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 unsigned int flags);
int	<a href="#virNodeDeviceListCaps">virNodeDeviceListCaps</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 char ** const names, <br/>					 int maxnames);
<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceLookupByName">virNodeDeviceLookupByName</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name);
<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	<a href="#virNodeDeviceLookupSCSIHostByWWN">virNodeDeviceLookupSCSIHostByWWN</a>	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * wwnn, <br/>							 const char * wwpn, <br/>							 unsigned int flags);
int	<a href="#virNodeDeviceNumOfCaps">virNodeDeviceNumOfCaps</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceReAttach">virNodeDeviceReAttach</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceRef">virNodeDeviceRef</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeDeviceReset">virNodeDeviceReset</a>		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev);
int	<a href="#virNodeListDevices">virNodeListDevices</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 char ** const names, <br/>					 int maxnames, <br/>					 unsigned int flags);
int	<a href="#virNodeNumOfDevices">virNodeNumOfDevices</a>		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 unsigned int flags);
</pre>
    </div>
    <div class="refsect1" lang="en">
      <h2>Description</h2>
    </div>
    <div class="refsect1" lang="en">
      <h2>Details</h2>
      <div class="refsect2" lang="en">
        <div class="refsect2" lang="en"><h3><a name="VIR_NODE_DEVICE_EVENT_CALLBACK">Macro </a>VIR_NODE_DEVICE_EVENT_CALLBACK</h3><pre class="programlisting">#define <a href="#VIR_NODE_DEVICE_EVENT_CALLBACK">VIR_NODE_DEVICE_EVENT_CALLBACK</a>;
</pre><p>Used to cast the event specific callback into the generic one for use for virConnectNodeDeviceEventRegisterAny()</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNodeDeviceFlags">Enum </a>virConnectListAllNodeDeviceFlags</h3><pre class="programlisting">enum <a href="#virConnectListAllNodeDeviceFlags">virConnectListAllNodeDeviceFlags</a> {
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM</a> = 1 /* System capability */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV</a> = 2 /* PCI device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV</a> = 4 /* USB device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE</a> = 8 /* USB interface */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET</a> = 16 /* Network device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST</a> = 32 /* SCSI Host Bus Adapter */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET</a> = 64 /* SCSI Target */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI</a> = 128 /* SCSI device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE">VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE</a> = 256 /* Storage device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST">VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST</a> = 512 /* FC Host Bus Adapter */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS">VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS</a> = 1024 /* Capable of vport */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC">VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC</a> = 2048 /* Capable of scsi_generic */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM">VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM</a> = 4096 /* DRM device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES">VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES</a> = 8192 /* Capable of mediated devices */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV</a> = 16384 /* Mediated device */
    <a name="VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV</a> = 32768 /* CCW device */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDevice">Structure </a>virNodeDevice</h3><pre class="programlisting">struct _virNodeDevice {
The content of this structure is not made public by the API.
} virNodeDevice;
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceEventID">Enum </a>virNodeDeviceEventID</h3><pre class="programlisting">enum <a href="#virNodeDeviceEventID">virNodeDeviceEventID</a> {
    <a name="VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE">VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE</a> = 0 /* virConnectNodeDeviceEventLifecycleCallback */
    <a name="VIR_NODE_DEVICE_EVENT_ID_UPDATE">VIR_NODE_DEVICE_EVENT_ID_UPDATE</a> = 1 /* virConnectNodeDeviceEventGenericCallback */
    <a name="VIR_NODE_DEVICE_EVENT_ID_LAST">VIR_NODE_DEVICE_EVENT_ID_LAST</a> = 2 /* NB: this enum value will increase over time as new events are  added to the libvirt API. It reflects the last event ID supported  by this version of the libvirt API. */
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceEventLifecycleType">Enum </a>virNodeDeviceEventLifecycleType</h3><pre class="programlisting">enum <a href="#virNodeDeviceEventLifecycleType">virNodeDeviceEventLifecycleType</a> {
    <a name="VIR_NODE_DEVICE_EVENT_CREATED">VIR_NODE_DEVICE_EVENT_CREATED</a> = 0
    <a name="VIR_NODE_DEVICE_EVENT_DELETED">VIR_NODE_DEVICE_EVENT_DELETED</a> = 1
    <a name="VIR_NODE_DEVICE_EVENT_LAST">VIR_NODE_DEVICE_EVENT_LAST</a> = 2
};
</pre><p/>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDevicePtr">Typedef </a>virNodeDevicePtr</h3><pre class="programlisting"><a href="libvirt-libvirt-nodedev.html#virNodeDevice">virNodeDevice</a> * virNodeDevicePtr;
</pre><p>A <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> is a pointer to a <a href="libvirt-libvirt-nodedev.html#virNodeDevice">virNodeDevice</a> structure. Get one via virNodeDeviceLookupByName, or virNodeDeviceCreate. Be sure to call <a href="libvirt-libvirt-nodedev.html#virNodeDeviceFree">virNodeDeviceFree</a> when done using a <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> obtained from any of the above functions to avoid leaking memory.</p>
</div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNodeDeviceEventGenericCallback"/>Function type virConnectNodeDeviceEventGenericCallback</h3><pre class="programlisting">void	virConnectNodeDeviceEventGenericCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>							 void * opaque)<br/>
</pre><p>A generic node device event callback handler, for use with
virConnectNodeDeviceEventRegisterAny(). Specific events usually
have a customization with extra parameters, often with @opaque being
passed in a different parameter position; use
VIR_NODE_DEVICE_EVENT_CALLBACK() when registering an appropriate handler.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>the connection pointer</td></tr><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the node device pointer</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNodeDeviceEventLifecycleCallback"/>Function type virConnectNodeDeviceEventLifecycleCallback</h3><pre class="programlisting">void	virConnectNodeDeviceEventLifecycleCallback	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>							 int event, <br/>							 int detail, <br/>							 void * opaque)<br/>
</pre><p>This callback is called when a node device lifecycle action is performed,
like added or removed.

The callback signature to use when registering for an event of type
VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE with
virConnectNodeDeviceEventRegisterAny()</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>connection object</td></tr><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>node device on which the event occurred</td></tr><tr><td><span class="term"><i><tt>event</tt></i>:</span></td><td>The specific virNodeDeviceEventLifeCycleType which occurred</td></tr><tr><td><span class="term"><i><tt>detail</tt></i>:</span></td><td>contains some details on the reason of the event.</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>application specified data</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectListAllNodeDevices"/>virConnectListAllNodeDevices ()</h3><pre class="programlisting">int	virConnectListAllNodeDevices	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> ** devices, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of node devices, and allocate an array to store those
objects.

Normally, all node devices are returned; however, @flags can be used to
filter the results for a smaller list of targeted node devices. The valid
flags are divided into groups, where each group contains bits that
describe mutually exclusive attributes of a node device, and where all bits
within a group describe all possible node devices.

Only one group of the @flags is provided to filter the node devices by
capability type, flags include:
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES
 VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV
 <a href="libvirt-libvirt-nodedev.html#VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV">VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV</a></p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>Pointer to the hypervisor connection.</td></tr><tr><td><span class="term"><i><tt>devices</tt></i>:</span></td><td>Pointer to a variable to store the array containing the node device objects or NULL if the list is not required (just returns number of node devices).</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>bitwise-OR of virConnectListAllNodeDeviceFlags.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices found or -1 and sets @devices to NULL in case of error. On success, the array stored into @devices is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virNodeDeviceFree() on each array element, then calling free() on @devices.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNodeDeviceEventDeregisterAny"/>virConnectNodeDeviceEventDeregisterAny ()</h3><pre class="programlisting">int	virConnectNodeDeviceEventDeregisterAny	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 int callbackID)<br/>
</pre><p>Removes an event callback. The callbackID parameter should be the
value obtained from a previous virConnectNodeDeviceEventRegisterAny() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>callbackID</tt></i>:</span></td><td>the callback identifier</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virConnectNodeDeviceEventRegisterAny"/>virConnectNodeDeviceEventRegisterAny ()</h3><pre class="programlisting">int	virConnectNodeDeviceEventRegisterAny	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>						 int eventID, <br/>						 <a href="libvirt-libvirt-nodedev.html#virConnectNodeDeviceEventGenericCallback">virConnectNodeDeviceEventGenericCallback</a> cb, <br/>						 void * opaque, <br/>						 <a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a> freecb)<br/>
</pre><p>Adds a callback to receive notifications of arbitrary node device events
occurring on a node device. This function requires that an event loop
has been previously registered with virEventRegisterImpl() or
virEventRegisterDefaultImpl().

If @dev is NULL, then events will be monitored for any node device.
If @dev is non-NULL, then only the specific node device will be monitored.

Most types of events have a callback providing a custom set of parameters
for the event. When registering an event, it is thus necessary to use
the VIR_NODE_DEVICE_EVENT_CALLBACK() macro to cast the
supplied function pointer to match the signature of this method.

The <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> object handle passed into the callback upon delivery
of an event is only valid for the duration of execution of the callback.
If the callback wishes to keep the node device object after the callback
returns, it shall take a reference to it, by calling virNodeDeviceRef().
The reference can be released once the object is no longer required
by calling virNodeDeviceFree().

The return value from this method is a positive integer identifier
for the callback. To unregister a callback, this callback ID should
be passed to the virConnectNodeDeviceEventDeregisterAny() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the connection</td></tr><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>eventID</tt></i>:</span></td><td>the event type to receive</td></tr><tr><td><span class="term"><i><tt>cb</tt></i>:</span></td><td>callback to the function handling node device events</td></tr><tr><td><span class="term"><i><tt>opaque</tt></i>:</span></td><td>opaque data to pass on to the callback</td></tr><tr><td><span class="term"><i><tt>freecb</tt></i>:</span></td><td>optional function to deallocate opaque when not used anymore</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a callback identifier on success, -1 on failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceCreateXML"/>virNodeDeviceCreateXML ()</h3><pre class="programlisting"><a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceCreateXML	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>						 const char * xmlDesc, <br/>						 unsigned int flags)<br/>
</pre><p>Create a new device on the VM host machine, for example, virtual
HBAs created using vport_create.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>xmlDesc</tt></i>:</span></td><td>string containing an XML description of the device to be created</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a node device object if successful, NULL in case of failure</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDestroy"/>virNodeDeviceDestroy ()</h3><pre class="programlisting">int	virNodeDeviceDestroy		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Destroy the device object. The virtual device (only works for vHBA
currently) is removed from the host operating system. This function
may require privileged access.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>a device object</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDetachFlags"/>virNodeDeviceDetachFlags ()</h3><pre class="programlisting">int	virNodeDeviceDetachFlags	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 const char * driverName, <br/>					 unsigned int flags)<br/>
</pre><p>Detach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such as
unbinding any device drivers from the device, binding the device to
a dummy device driver and resetting the device. Different backend
drivers expect the device to be bound to different dummy
devices. For example, QEMU's "kvm" backend driver (the default)
expects the device to be bound to "pci-stub", but its "vfio"
backend driver expects the device to be bound to "vfio-pci".

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReAttach() method.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>driverName</tt></i>:</span></td><td>name of backend driver that will be used for later device assignment to a domain. NULL means "use the hypervisor default driver"</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceDettach"/>virNodeDeviceDettach ()</h3><pre class="programlisting">int	virNodeDeviceDettach		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Dettach the node device from the node itself so that it may be
assigned to a guest domain.

Depending on the hypervisor, this may involve operations such
as unbinding any device drivers from the device, binding the
device to a dummy device driver and resetting the device.

If the device is currently in use by the node, this method may
fail.

Once the device is not assigned to any guest, it may be re-attached
to the node using the virNodeDeviceReattach() method.

If the caller needs control over which backend driver will be used
during PCI device assignment (to use something other than the
default, for example VFIO), the newer virNodeDeviceDetachFlags()
API should be used instead.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceFree"/>virNodeDeviceFree ()</h3><pre class="programlisting">int	virNodeDeviceFree		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Drops a reference to the node device, freeing it if
this was the last reference.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the 0 for success, -1 for error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetName"/>virNodeDeviceGetName ()</h3><pre class="programlisting">const char *	virNodeDeviceGetName	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Just return the device name</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the device name or NULL in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetParent"/>virNodeDeviceGetParent ()</h3><pre class="programlisting">const char *	virNodeDeviceGetParent	(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Accessor for the parent of the device</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the name of the device's parent, or NULL if an error occurred or when the device has no parent.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceGetXMLDesc"/>virNodeDeviceGetXMLDesc ()</h3><pre class="programlisting">char *	virNodeDeviceGetXMLDesc		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 unsigned int flags)<br/>
</pre><p>Fetch an XML document describing all aspects of
the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the XML document, or NULL on error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceListCaps"/>virNodeDeviceListCaps ()</h3><pre class="programlisting">int	virNodeDeviceListCaps		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev, <br/>					 char ** const names, <br/>					 int maxnames)<br/>
</pre><p>Lists the names of the capabilities supported by the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of capability names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capability names listed in @names or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceLookupByName"/>virNodeDeviceLookupByName ()</h3><pre class="programlisting"><a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceLookupByName	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * name)<br/>
</pre><p>Lookup a node device by its name.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>unique device name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceLookupSCSIHostByWWN"/>virNodeDeviceLookupSCSIHostByWWN ()</h3><pre class="programlisting"><a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a>	virNodeDeviceLookupSCSIHostByWWN	(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>							 const char * wwnn, <br/>							 const char * wwpn, <br/>							 unsigned int flags)<br/>
</pre><p>Lookup SCSI Host which is capable with 'fc_host' by its WWNN and WWPN.

virNodeDeviceFree should be used to free the resources after the
node device object is no longer needed.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>wwnn</tt></i>:</span></td><td>WWNN of the SCSI Host.</td></tr><tr><td><span class="term"><i><tt>wwpn</tt></i>:</span></td><td>WWPN of the SCSI Host.</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a <a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> if found, NULL otherwise.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceNumOfCaps"/>virNodeDeviceNumOfCaps ()</h3><pre class="programlisting">int	virNodeDeviceNumOfCaps		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Accessor for the number of capabilities supported by the device.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of capabilities supported by the device or -1 in case of error.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceReAttach"/>virNodeDeviceReAttach ()</h3><pre class="programlisting">int	virNodeDeviceReAttach		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Re-attach a previously detached node device to the node so that it
may be used by the node again.

Depending on the hypervisor, this may involve operations such
as resetting the device, unbinding it from a dummy device driver
and binding it to its appropriate driver.

If the device is currently in use by a guest, this method may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceRef"/>virNodeDeviceRef ()</h3><pre class="programlisting">int	virNodeDeviceRef		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Increment the reference count on the dev. For each
additional call to this method, there shall be a corresponding
call to <a href="libvirt-libvirt-nodedev.html#virNodeDeviceFree">virNodeDeviceFree</a> to release the reference count, once
the caller no longer needs the reference to this object.

This method is typically useful for applications where multiple
threads are using a connection, and it is required that the
connection remain open until all threads have finished using
it. ie, each new thread using a dev would increment
the reference count.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>the dev to hold a reference on</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeDeviceReset"/>virNodeDeviceReset ()</h3><pre class="programlisting">int	virNodeDeviceReset		(<a href="libvirt-libvirt-nodedev.html#virNodeDevicePtr">virNodeDevicePtr</a> dev)<br/>
</pre><p>Reset a previously detached node device to the node before or
after assigning it to a guest.

The exact reset semantics depends on the hypervisor and device
type but, for example, KVM will attempt to reset PCI devices with
a Function Level Reset, Secondary Bus Reset or a Power Management
D-State reset.

If the reset will affect other devices which are currently in use,
this function may fail.</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>dev</tt></i>:</span></td><td>pointer to the node device</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, -1 in case of failure.</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeListDevices"/>virNodeListDevices ()</h3><pre class="programlisting">int	virNodeListDevices		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 char ** const names, <br/>					 int maxnames, <br/>					 unsigned int flags)<br/>
</pre><p>Collect the list of node devices, and store their names in @names

For more control over the results, see virConnectListAllNodeDevices().

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>names</tt></i>:</span></td><td>array to collect the list of node device names</td></tr><tr><td><span class="term"><i><tt>maxnames</tt></i>:</span></td><td>size of @names</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices found or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
        <div class="refsect2" lang="en"><h3><a name="virNodeNumOfDevices"/>virNodeNumOfDevices ()</h3><pre class="programlisting">int	virNodeNumOfDevices		(<a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a> conn, <br/>					 const char * cap, <br/>					 unsigned int flags)<br/>
</pre><p>Provides the number of node devices.

If the optional 'cap' argument is non-NULL, then the count
will be restricted to devices with the specified capability</p>
<div class="variablelist"><table border="0"><col align="left"/><tbody><tr><td><span class="term"><i><tt>conn</tt></i>:</span></td><td>pointer to the hypervisor connection</td></tr><tr><td><span class="term"><i><tt>cap</tt></i>:</span></td><td>capability name</td></tr><tr><td><span class="term"><i><tt>flags</tt></i>:</span></td><td>extra flags; not used yet, so callers should always pass 0</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of node devices or -1 in case of error</td></tr></tbody></table></div></div>
        <hr/>
      </div>
    </div>
  </body>
</html>
